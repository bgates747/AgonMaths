PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004             0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD 7C 22 04 0016        call main
040050             0017    exit:
040050 FD E1       0018        pop iy
040052 DD E1       0019        pop ix
040054 D1          0020        pop de
040055 C1          0021        pop bc
040056 F1          0022        pop af
040057 21 00 00 00 0023        ld hl,0
04005B             0024    
04005B C9          0025        ret
04005C             0026    
04005C             0027    ; API INCLUDES
04005C             0028        include "../include/mos_api.inc"
04005C             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04005C             0002*   ; Title:	AGON MOS - API for user projects
04005C             0003*   ; Author:	Dean Belfield
04005C             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
04005C             0005*   ;			Added MOS error codes for return in HL
04005C             0006*   ; Created:	03/08/2022
04005C             0007*   ; Last Updated:	10/08/2023
04005C             0008*   ;
04005C             0009*   ; Modinfo:
04005C             0010*   ; 05/08/2022:	Added mos_feof
04005C             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
04005C             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04005C             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04005C             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
04005C             0015*   ; 13/10/2022:	Added mos_oscli
04005C             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04005C             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
04005C             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04005C             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04005C             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04005C             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
04005C             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04005C             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04005C             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04005C             0025*   ; 19/05/2023:	Added sysvar_scrMode
04005C             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
04005C             0027*   ; 03/08/2023:	Added mos_setkbvector
04005C             0028*   ; 10/08/2023:	Added mos_getkbmap
04005C             0029*   
04005C             0030*   ; VDP control (VDU 23, 0, n)
04005C             0031*   ;
04005C             0032*   vdp_gp:				EQU 80h
04005C             0033*   vdp_keycode:		EQU 81h
04005C             0034*   vdp_cursor:			EQU	82h
04005C             0035*   vdp_scrchar:		EQU	83h
04005C             0036*   vdp_scrpixel:		EQU	84h
04005C             0037*   vdp_audio:			EQU	85h
04005C             0038*   vdp_mode:			EQU	86h
04005C             0039*   vdp_rtc:			EQU	87h
04005C             0040*   vdp_keystate:		EQU	88h
04005C             0041*   vdp_logicalcoords:	EQU	C0h
04005C             0042*   vdp_terminalmode:	EQU	FFh
04005C             0043*   
04005C             0044*   ; MOS high level functions
04005C             0045*   ;
04005C             0046*   mos_getkey:			EQU	00h
04005C             0047*   mos_load:			EQU	01h
04005C             0048*   mos_save:			EQU	02h
04005C             0049*   mos_cd:				EQU	03h
04005C             0050*   mos_dir:			EQU	04h
04005C             0051*   mos_del:			EQU	05h
04005C             0052*   mos_ren:			EQU	06h
04005C             0053*   mos_mkdir:			EQU	07h
04005C             0054*   mos_sysvars:		EQU	08h
04005C             0055*   mos_editline:		EQU	09h
04005C             0056*   mos_fopen:			EQU	0Ah
04005C             0057*   mos_fclose:			EQU	0Bh
04005C             0058*   mos_fgetc:			EQU	0Ch
04005C             0059*   mos_fputc:			EQU	0Dh
04005C             0060*   mos_feof:			EQU	0Eh
04005C             0061*   mos_getError:		EQU	0Fh
04005C             0062*   mos_oscli:			EQU	10h
04005C             0063*   mos_copy:			EQU	11h
04005C             0064*   mos_getrtc:			EQU	12h
04005C             0065*   mos_setrtc:			EQU	13h
04005C             0066*   mos_setintvector:	EQU	14h
04005C             0067*   mos_uopen:			EQU	15h
04005C             0068*   mos_uclose:			EQU	16h
04005C             0069*   mos_ugetc:			EQU	17h
04005C             0070*   mos_uputc:			EQU	18h
04005C             0071*   mos_getfil:			EQU	19h
04005C             0072*   mos_fread:			EQU	1Ah
04005C             0073*   mos_fwrite:			EQU	1Bh
04005C             0074*   mos_flseek:			EQU	1Ch
04005C             0075*   mos_setkbvector:	EQU	1Dh
04005C             0076*   mos_getkbmap:		EQU	1Eh
04005C             0077*   
04005C             0078*   ; MOS program exit codes
04005C             0079*   ;
04005C             0080*   EXIT_OK:				EQU  0;	"OK",
04005C             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04005C             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04005C             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04005C             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04005C             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04005C             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04005C             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04005C             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04005C             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04005C             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04005C             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04005C             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04005C             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04005C             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04005C             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04005C             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04005C             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04005C             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04005C             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04005C             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04005C             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04005C             0102*   ; FatFS file access functions
04005C             0103*   ;
04005C             0104*   ffs_fopen:			EQU	80h
04005C             0105*   ffs_fclose:			EQU	81h
04005C             0106*   ffs_fread:			EQU	82h
04005C             0107*   ffs_fwrite:			EQU	83h
04005C             0108*   ffs_flseek:			EQU	84h
04005C             0109*   ffs_ftruncate:		EQU	85h
04005C             0110*   ffs_fsync:			EQU	86h
04005C             0111*   ffs_fforward:		EQU	87h
04005C             0112*   ffs_fexpand:		EQU	88h
04005C             0113*   ffs_fgets:			EQU	89h
04005C             0114*   ffs_fputc:			EQU	8Ah
04005C             0115*   ffs_fputs:			EQU	8Bh
04005C             0116*   ffs_fprintf:		EQU	8Ch
04005C             0117*   ffs_ftell:			EQU	8Dh
04005C             0118*   ffs_feof:			EQU	8Eh
04005C             0119*   ffs_fsize:			EQU	8Fh
04005C             0120*   ffs_ferror:			EQU	90h
04005C             0121*   
04005C             0122*   ; FatFS directory access functions
04005C             0123*   ;
04005C             0124*   ffs_dopen:			EQU	91h
04005C             0125*   ffs_dclose:			EQU	92h
04005C             0126*   ffs_dread:			EQU	93h
04005C             0127*   ffs_dfindfirst:		EQU	94h
04005C             0128*   ffs_dfindnext:		EQU	95h
04005C             0129*   
04005C             0130*   ; FatFS file and directory management functions
04005C             0131*   ;
04005C             0132*   ffs_stat:			EQU	96h
04005C             0133*   ffs_unlink:			EQU	97h
04005C             0134*   ffs_rename:			EQU	98h
04005C             0135*   ffs_chmod:			EQU	99h
04005C             0136*   ffs_utime:			EQU	9Ah
04005C             0137*   ffs_mkdir:			EQU	9Bh
04005C             0138*   ffs_chdir:			EQU	9Ch
04005C             0139*   ffs_chdrive:		EQU	9Dh
04005C             0140*   ffs_getcwd:			EQU	9Eh
04005C             0141*   
04005C             0142*   ; FatFS volume management and system configuration functions
04005C             0143*   ;
04005C             0144*   ffs_mount:			EQU	9Fh
04005C             0145*   ffs_mkfs:			EQU	A0h
04005C             0146*   ffs_fdisk:			EQU	A1h
04005C             0147*   ffs_getfree:		EQU	A2h
04005C             0148*   ffs_getlabel:		EQU	A3h
04005C             0149*   ffs_setlabel:		EQU	A4h
04005C             0150*   ffs_setcp:			EQU	A5h
04005C             0151*   
04005C             0152*   ; File access modes
04005C             0153*   ;
04005C             0154*   fa_read:			EQU	01h
04005C             0155*   fa_write:			EQU	02h
04005C             0156*   fa_open_existing:	EQU	00h
04005C             0157*   fa_create_new:		EQU	04h
04005C             0158*   fa_create_always:	EQU	08h
04005C             0159*   fa_open_always:		EQU	10h
04005C             0160*   fa_open_append:		EQU	30h
04005C             0161*   
04005C             0162*   ; System variable indexes for api_sysvars
04005C             0163*   ; Index into _sysvars in globals.inc
04005C             0164*   ;
04005C             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04005C             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04005C             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04005C             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04005C             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04005C             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04005C             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04005C             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04005C             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04005C             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04005C             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04005C             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04005C             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04005C             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04005C             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04005C             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04005C             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04005C             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04005C             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04005C             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04005C             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04005C             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04005C             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04005C             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04005C             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
04005C             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04005C             0191*   
04005C             0192*   ; Flags for the VPD protocol
04005C             0193*   ;
04005C             0194*   vdp_pflag_cursor:		EQU	00000001b
04005C             0195*   vdp_pflag_scrchar:		EQU	00000010b
04005C             0196*   vdp_pflag_point:		EQU	00000100b
04005C             0197*   vdp_pflag_audio:		EQU	00001000b
04005C             0198*   vdp_pflag_mode:			EQU	00010000b
04005C             0199*   vdp_pflag_rtc:			EQU	00100000b
04005C             0200*   
04005C             0201*   ;
04005C             0202*   ; FatFS structures
04005C             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04005C             0204*   ;
04005C             0205*   ; Object ID and allocation information (FFOBJID)
04005C             0206*   ;
04005C             0207*   ; Indexes into FFOBJID structure
04005C             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04005C             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04005C             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
04005C             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04005C             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04005C             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04005C             0214*   ;
04005C             0215*   ; File object structure (FIL)
04005C             0216*   ;
04005C             0217*   ; Indexes into FIL structure
04005C             0218*   fil_obj:		EQU 0	; 15: Object identifier
04005C             0219*   fil_flag:		EQU	15 	;  1: File status flags
04005C             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
04005C             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04005C             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04005C             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04005C             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04005C             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04005C             0226*   fil_struct_size: EQU fil_dir_ptr+3 ; size of the FIL structure
04005C             0227*   ;
04005C             0228*   ; Directory object structure (DIR)
04005C             0229*   ; Indexes into DIR structure
04005C             0230*   dir_obj:		EQU  0	; 15: Object identifier
04005C             0231*   dir_dptr:		EQU	15	;  4: Current read/write offset
04005C             0232*   dir_clust:		EQU	19	;  4: Current cluster
04005C             0233*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04005C             0234*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04005C             0235*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04005C             0236*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04005C             0237*   dir_struct_size:	EQU	46	;  4: Size of the struct
04005C             0238*   ;
04005C             0239*   ; File information structure (FILINFO)
04005C             0240*   ;
04005C             0241*   ; Indexes into FILINFO structure
04005C             0242*   filinfo_fsize:		EQU 0	;   4: File size
04005C             0243*   filinfo_fdate:		EQU	4	;   2: Modified date
04005C             0244*   filinfo_ftime:		EQU	6	;   2: Modified time
04005C             0245*   filinfo_fattrib:	EQU	8	;   1: File attribute
04005C             0246*   filinfo_altname:	EQU	9	;  13: Alternative file name
04005C             0247*   filinfo_fname:		EQU	22	; 256: Primary file name
04005C             0248*   filinfo_struct_size: EQU filinfo_fname+256 ; size of the FILINFO structure
04005C             0249*   
04005C             0250*   ; /* File attribute bits for directory entry (FILINFO.fattrib) */
04005C             0251*   AM_RDO: equ 0 ; Bit 0 - Read Only
04005C             0252*   AM_HID: equ 1 ; Bit 1 - Hidden
04005C             0253*   AM_SYS: equ 2 ; Bit 2 - System
04005C             0254*   AM_DIR: equ 4 ; Bit 4 - Directory
04005C             0255*   AM_ARC: equ 5 ; Bit 5 - Archive
04005C             0256*   
04005C             0257*   ;
04005C             0258*   ; Macro for calling the API
04005C             0259*   ; Parameters:
04005C             0260*   ; - function: One of the function numbers listed above
04005C             0261*   ;
04005C             0262*   	MACRO	MOSCALL	function
04005C             0263*   			LD	A, function
04005C             0264*   			RST.LIL	08h
04005C             0265*   	ENDMACRO
04005C             0266*   
04005C             0267*   ;
04005C             0268*   ; Same as above but keeps IY safe on FFS calls
04005C             0269*   ; (can be use for regular MOS calls as well)
04005C             0270*   ;
04005C             0271*   	MACRO	FFSCALL	function
04005C             0272*   			PUSH IY
04005C             0273*   			LD	A, function
04005C             0274*   			RST.LIL	08h
04005C             0275*   			POP IY
04005C             0276*   	ENDMACRO
04005C             0029        include "../include/macros.inc"
04005C             0001*   
04005C             0002*   ; test the sign of UHL
04005C             0003*   ; inputs: UHL obviously
04005C             0004*   ; outputs: sign flag set if UHL is negative, zero flag set if UHL is zero
04005C             0005*       MACRO SIGN_HLU
04005C             0006*       add hl,de ; 1 cycle
04005C             0007*       or a ; clear flags ; 1 cycle
04005C             0008*       sbc hl,de ; 2 cycles
04005C             0009*       ; 4 cycles total
04005C             0010*       ENDMACRO
04005C             0011*   
04005C             0012*   ; test the sign of HL
04005C             0013*   ; inputs: HL obviously
04005C             0014*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero, ***hlu is zeroed***
04005C             0015*       MACRO SIGN_HL
04005C             0016*       add hl,de
04005C             0017*       or a ; clear flags
04005C             0018*       sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
04005C             0019*       ENDMACRO
04005C             0020*   
04005C             0021*   ; put the value in A into HLU
04005C             0022*   ; affects: HLU
04005C             0023*   ; destroys: nothing
04005C             0024*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
04005C             0025*       MACRO A_TO_HLU
04005C             0026*       xor a ; 1 cycle
04005C             0027*       ld ($+8+1),hl ; 7 cycles
04005C             0028*       ld ($+4+3),a ; 5 cycles
04005C             0029*       ld hl,0x000000 ; 4 cycles
04005C             0030*       ; 17 cycles total
04005C             0031*       ENDMACRO
04005C             0032*   
04005C             0033*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
04005C             0034*   ; one cycle less but burns flags
04005C             0035*       MACRO A_TO_HLU_ALT
04005C             0036*       push hl ; 4 cycles
04005C             0037*       ld hl,2 ; 4 cycles
04005C             0038*       add hl,sp ; 1 cycle
04005C             0039*       ld (hl),a ; 2 cycles
04005C             0040*       pop hl ; 4 cycles
04005C             0041*       ; 15 cycles total
04005C             0042*       ENDMACRO
04005C             0043*   
04005C             0044*       MACRO hlu_mul256
04005C             0045*       add hl,hl ; * 2
04005C             0046*       add hl,hl ; * 4
04005C             0047*       add hl,hl ; * 8
04005C             0048*       add hl,hl ; * 16
04005C             0049*       add hl,hl ; * 32
04005C             0050*       add hl,hl ; * 64
04005C             0051*       add hl,hl ; * 128
04005C             0052*       add hl,hl ; * 256
04005C             0053*       ENDMACRO
04005C             0054*   
04005C             0055*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
04005C             0056*       MACRO SRL_UHL
04005C             0057*       dec sp ; 1 cycle
04005C             0058*       push hl ; 4 cycles
04005C             0059*       inc sp ; 1 cycle
04005C             0060*       pop hl ; 4 cycles
04005C             0061*       inc hl ; 1 cycle
04005C             0062*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04005C             0063*       ; 13 cycles total
04005C             0064*       ENDMACRO
04005C             0065*   
04005C             0066*       MACRO printChar char
04005C             0067*       LD A, char
04005C             0068*       RST.LIL 10h
04005C             0069*       ENDMACRO
04005C             0070*   
04005C             0071*   ; Simulated call to subroutine at HL
04005C             0072*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
04005C             0073*   ; outputs: whatever the subroutine does, including HL and BC
04005C             0074*   ; destroys: only what the subroutine does, but always BC
04005C             0075*       MACRO CALL_HL
04005C             0076*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0077*       push bc ; which constitutes the return address
04005C             0078*       jp (hl) ; Jump to the address in HL
04005C             0079*       ENDMACRO
04005C             0080*   
04005C             0081*   ; Simulated call to subroutine at IX
04005C             0082*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
04005C             0083*   ; outputs: whatever the subroutine does, including IX and BC
04005C             0084*   ; destroys: only what the subroutine does, but always BC
04005C             0085*       MACRO CALL_IX
04005C             0086*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0087*       push bc ; which constitutes the return address
04005C             0088*       jp (ix) ; Jump to the address in IX
04005C             0089*       ENDMACRO
04005C             0090*   
04005C             0091*   ; Simulated call to soubroutinte at IY
04005C             0092*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
04005C             0093*   ; outputs: whatever the subroutine does, including IY and BC
04005C             0094*   ; destroys: only what the subroutine does, but always BC
04005C             0095*       MACRO CALL_IY
04005C             0096*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0097*       push bc ; which constitutes the return address
04005C             0098*       jp (iy) ; Jump to the address in IY
04005C             0099*       ENDMACRO
04005C             0100*   
04005C             0101*   ; put the value in HLU into A
04005C             0102*   ; destroys: af
04005C             0103*       MACRO HLU_TO_A
04005C             0104*       dec sp ; 1 cycle
04005C             0105*       push hl ; 4 cycles
04005C             0106*       inc sp ; 1 cycle
04005C             0107*       pop af ; 4 cycles
04005C             0108*       ; 10 cycles total
04005C             0109*       ENDMACRO
04005C             0110*   
04005C             0111*       MACRO PUSH_ALL
04005C             0112*       ex af,af'
04005C             0113*       exx
04005C             0114*       push af
04005C             0115*       push hl
04005C             0116*       push bc
04005C             0117*       push de
04005C             0118*   
04005C             0119*       ex af,af'
04005C             0120*       exx
04005C             0121*       push af
04005C             0122*       push hl
04005C             0123*       push bc
04005C             0124*       push de
04005C             0125*       push ix
04005C             0126*       push iy
04005C             0127*       ENDMACRO
04005C             0128*   
04005C             0129*       MACRO POP_ALL
04005C             0130*       pop iy
04005C             0131*       pop ix
04005C             0132*       pop de
04005C             0133*       pop bc
04005C             0134*       pop hl
04005C             0135*       pop af
04005C             0136*       ex af,af'
04005C             0137*       exx
04005C             0138*   
04005C             0139*       pop de
04005C             0140*       pop bc
04005C             0141*       pop hl
04005C             0142*       pop af
04005C             0143*       ex af,af'
04005C             0144*       exx
04005C             0145*       ENDMACRO
04005C             0146*   
04005C             0147*       ; load hl with the 16-bit value at addr
04005C             0148*       MACRO LD_HL_mn addr
04005C             0149*       ld hl,(addr)
04005C             0150*       dec hl
04005C             0151*       inc.s hl ; zeros hlu
04005C             0152*       ENDMACRO
04005C             0153*   
04005C             0154*       ; load bc with the 16-bit value at addr
04005C             0155*       MACRO LD_BC_mn addr
04005C             0156*       ld bc,(addr)
04005C             0157*       dec bc
04005C             0158*       inc.s bc ; zeros bcu
04005C             0159*       ENDMACRO
04005C             0160*   
04005C             0161*       ; load de with the 16-bit value at addr
04005C             0162*       MACRO LD_DE_mn addr
04005C             0163*       ld de,(addr)
04005C             0164*       dec de
04005C             0165*       inc.s de ; zeros deu
04005C             0166*       ENDMACRO
04005C             0167*   
04005C             0168*       ; load ix with the 16-bit value at addr
04005C             0169*       MACRO LD_IX_mn addr
04005C             0170*       ld ix,(addr)
04005C             0171*       dec ix
04005C             0172*       inc.s ix ; zeros ixu
04005C             0173*       ENDMACRO
04005C             0174*   
04005C             0175*       ; load iy with the 16-bit value at addr
04005C             0176*       MACRO LD_IY_mn addr
04005C             0177*       ld iy,(addr)
04005C             0178*       dec iy
04005C             0179*       inc.s iy ; zeros iyu
04005C             0180*       ENDMACRO
04005C             0181*   
04005C             0182*       MACRO PRINT_UNPACK_F16 msg
04005C             0183*           ld a,'S'
04005C             0184*           rst.lil 0x10
04005C             0185*           signF16UI
04005C             0186*           call printHexA
04005C             0187*           ld a,'E'
04005C             0188*           rst.lil 0x10
04005C             0189*           expF16UI
04005C             0190*           call printHexA
04005C             0191*           push hl
04005C             0192*           call printInline
04005C             0193*           asciz "Sig"
04005C             0194*           pop hl
04005C             0195*           push hl
04005C             0196*           fracF16UI
04005C             0197*           call printHexHL
04005C             0198*           call printInline
04005C             0199*           asciz msg,"\r\n"
04005C             0200*           pop hl
04005C             0201*       ENDMACRO
04005C             0202*   
04005C             0203*       MACRO PRINT_HL_HEX_BIN msg
04005C             0204*           push de
04005C             0205*           push af
04005C             0206*           push hl
04005C             0207*           call printHLHexBin
04005C             0208*           pop hl
04005C             0209*           push hl
04005C             0210*           call printInline
04005C             0211*           asciz msg,"\r\n"
04005C             0212*           pop hl
04005C             0213*           pop af
04005C             0214*           pop de
04005C             0215*       ENDMACRO
04005C             0216*   
04005C             0217*       MACRO PRINT_A_HEX msg
04005C             0218*           push de
04005C             0219*           push hl
04005C             0220*           push af
04005C             0221*           ld a,'0'
04005C             0222*           rst.lil 0x10
04005C             0223*           ld a,'x'
04005C             0224*           rst.lil 0x10
04005C             0225*           pop af
04005C             0226*           push af
04005C             0227*           call printHexA
04005C             0228*           call printInline
04005C             0229*           asciz "  ",msg,"\r\n"
04005C             0230*           pop af
04005C             0231*           pop hl
04005C             0232*           pop de
04005C             0233*       ENDMACRO
04005C             0234*   
04005C             0235*       MACRO PRINT_HL_HEX msg
04005C             0236*           push de
04005C             0237*           push af
04005C             0238*           push hl
04005C             0239*           ld a,'0'
04005C             0240*           rst.lil 0x10
04005C             0241*           ld a,'x'
04005C             0242*           rst.lil 0x10
04005C             0243*           call printHexHL
04005C             0244*           call printInline
04005C             0245*           asciz msg,"\r\n"
04005C             0246*           pop hl
04005C             0247*           pop af
04005C             0248*           pop de
04005C             0249*       ENDMACRO
04005C             0250*   
04005C             0251*       MACRO PRINT_UHL_HEX msg
04005C             0252*           push de
04005C             0253*           push af
04005C             0254*           push hl
04005C             0255*           ld a,'0'
04005C             0256*           rst.lil 0x10
04005C             0257*           ld a,'x'
04005C             0258*           rst.lil 0x10
04005C             0259*           call printHexUHL
04005C             0260*           call printInline
04005C             0261*           asciz msg,"\r\n"
04005C             0262*           pop hl
04005C             0263*           pop af
04005C             0264*           pop de
04005C             0265*       ENDMACRO
04005C             0266*   
04005C             0267*       MACRO PRINT_AUHL_HEX msg
04005C             0268*           push af
04005C             0269*           push hl
04005C             0270*           push de
04005C             0271*           push af
04005C             0272*           ld a,'0'
04005C             0273*           rst.lil 0x10
04005C             0274*           ld a,'x'
04005C             0275*           rst.lil 0x10
04005C             0276*           pop af
04005C             0277*           call printHexAUHL
04005C             0278*           call printInline
04005C             0279*           asciz msg,"\r\n"
04005C             0280*           pop de
04005C             0281*           pop hl
04005C             0282*           pop af
04005C             0283*       ENDMACRO
04005C             0284*   
04005C             0285*       MACRO PRINT_BC_HEX msg
04005C             0286*           push de
04005C             0287*           push af
04005C             0288*           push hl
04005C             0289*           push bc
04005C             0290*           pop hl
04005C             0291*           ld a,'0'
04005C             0292*           rst.lil 0x10
04005C             0293*           ld a,'x'
04005C             0294*           rst.lil 0x10
04005C             0295*           call printHexHL
04005C             0296*           call printInline
04005C             0297*           asciz msg,"\r\n"
04005C             0298*           pop hl
04005C             0299*           pop af
04005C             0300*           pop de
04005C             0301*       ENDMACRO
04005C             0302*   
04005C             0303*       MACRO PRINT_DE_HEX msg
04005C             0304*           push de
04005C             0305*           push af
04005C             0306*           push hl
04005C             0307*           ex de,hl
04005C             0308*           ld a,'0'
04005C             0309*           rst.lil 0x10
04005C             0310*           ld a,'x'
04005C             0311*           rst.lil 0x10
04005C             0312*           call printHexHL
04005C             0313*           call printInline
04005C             0314*           asciz msg,"\r\n"
04005C             0315*           pop hl
04005C             0316*           pop af
04005C             0317*           pop de
04005C             0318*       ENDMACRO
04005C             0319*   
04005C             0320*       MACRO PRINT_HLDE_HEX msg
04005C             0321*           push de
04005C             0322*           push af
04005C             0323*           push hl
04005C             0324*           ld a,'0'
04005C             0325*           rst.lil 0x10
04005C             0326*           ld a,'x'
04005C             0327*           rst.lil 0x10
04005C             0328*           call printHexHLDE
04005C             0329*           call printInline
04005C             0330*           asciz msg,"\r\n"
04005C             0331*           pop hl
04005C             0332*           pop af
04005C             0333*           pop de
04005C             0334*       ENDMACRO
04005C             0335*   
04005C             0336*       MACRO PRINT_AHL_HEX msg
04005C             0337*           push de
04005C             0338*           push af
04005C             0339*           push hl
04005C             0340*           push af
04005C             0341*           ld a,'0'
04005C             0342*           rst.lil 0x10
04005C             0343*           ld a,'x'
04005C             0344*           rst.lil 0x10
04005C             0345*           pop af
04005C             0346*           call printHexAHL
04005C             0347*           call printInline
04005C             0348*           asciz msg,"\r\n"
04005C             0349*           pop hl
04005C             0350*           pop af
04005C             0351*           pop de
04005C             0352*       ENDMACRO
04005C             0353*   
04005C             0354*       MACRO PRINT_ADE_HEX msg
04005C             0355*           push de
04005C             0356*           push af
04005C             0357*           push hl
04005C             0358*           push af
04005C             0359*           ld a,'0'
04005C             0360*           rst.lil 0x10
04005C             0361*           ld a,'x'
04005C             0362*           rst.lil 0x10
04005C             0363*           pop af
04005C             0364*           call printHexADE
04005C             0365*           call printInline
04005C             0366*           asciz msg,"\r\n"
04005C             0367*           pop hl
04005C             0368*           pop af
04005C             0369*           pop de
04005C             0370*       ENDMACRO
04005C             0371*   
04005C             0372*       MACRO DUMP_REGISTERS_HEX msg
04005C             0373*           push de
04005C             0374*           push af
04005C             0375*           push hl
04005C             0376*           call printInline
04005C             0377*           asciz "\r\n",msg,"\r\n"
04005C             0378*           pop hl
04005C             0379*           pop af
04005C             0380*           pop de
04005C             0381*           call dumpRegistersHex
04005C             0382*           ; call dumpFlags
04005C             0383*       ENDMACRO
04005C             0030        include "../include/functions.inc"
04005C             0001*   ; Print a zero-terminated string inline with code, e.g.:
04005C             0002*   ;
04005C             0003*   ;    call printInline
04005C             0004*   ;    ASCIZ "Hello, world!\r\n"
04005C             0005*   ;
04005C             0006*   ; Destroys: HL,AF
04005C             0007*   printInline:
04005C E1          0008*       pop hl ; get the return address = pointer to start of string
04005D CD 63 00 04 0009*       call printString ; HL advances to end of string
040061 E5          0010*       push hl ; restore the return address = pointer to end of string
040062 C9          0011*       ret
040063             0012*   
040063             0013*   ; Print a zero-terminated string
040063             0014*   ; IX: Pointer to string, A: signed offset from IX
040063             0015*   printStringIX:
040063             0016*   
040063             0017*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040063             0018*   ; Print a zero-terminated string
040063             0019*   ; HL: Pointer to string
040063             0020*   ; returns: hl pointed to character after string terminator
040063             0021*   ; destroys: af, hl
040063             0022*   printString:
040063 C5          0023*       PUSH BC
040064 01 00 00 00 0024*       LD BC,0
040068 3E 00       0025*       LD A,0
04006A 5B DF       0026*       RST.LIL 18h
04006C C1          0027*       POP BC
04006D C9          0028*       RET
04006E             0029*   ; print a VDU sequence
04006E             0030*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
04006E             0031*   sendVDUsequence:
04006E C5          0032*       PUSH BC
04006F 01 00 00 00 0033*       LD BC, 0
040073 4E          0034*       LD C, (HL)
040074 5B DF       0035*       RST.LIL 18h
040076 C1          0036*       POP BC
040077 C9          0037*       RET
040078             0038*   ; Print Newline sequence to VDP
040078             0039*   ; destroys: nothing
040078             0040*   printNewLine:
040078 F5          0041*       push af ; for some reason rst.lil 10h sets carry flag
040079 3E 0D       0042*       LD A, '\r'
04007B 5B D7       0043*       RST.LIL 10h
04007D 3E 0A       0044*       LD A, '\n'
04007F 5B D7       0045*       RST.LIL 10h
040081 F1          0046*       pop af
040082 C9          0047*       RET
040083             0048*   
040083             0049*   ; print a zero-terminated string at a graphics coordinate
040083             0050*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
040083             0051*   printStringGfx:
040083 E5          0052*       push hl ; preserve string pointer
040084             0053*   ; move graphics cursor to x,y location
040084 3E 44       0054*       ld a,plot_pt+mv_abs
040086 CD 3D 19 04 0055*       call vdu_plot
04008A             0056*   ; print string
04008A E1          0057*       pop hl ; restore string pointer
04008B             0058*   @print_loop:
04008B 7E          0059*       ld a,(hl)
04008C B7          0060*       or a ; check for end of string
04008D C8          0061*       ret z ; if zero, we're done
04008E 08          0062*       ex af,af' ; preserve character
04008F 3E 05       0063*       ld a,5 ; VDU 5 char to gfx cursor
040091 5B D7       0064*       rst.lil 10h ; send it
040093 08          0065*       ex af,af' ; restore character
040094 5B D7       0066*       rst.lil 10h ; print character
040096 23          0067*       inc hl
040097 C3 8B 00 04 0068*       jp @print_loop
04009B C9          0069*       ret
04009C             0070*   ; end printStringGfx
04009C             0071*   
04009C             0072*   ; Print a 24-bit HEX number
04009C             0073*   ; HLU: Number to print
04009C             0074*   printHex24:
04009C             0075*       HLU_TO_A
                       M1 Args: none
04009C 3B          0001*M1     dec sp ; 1 cycle
04009D E5          0002*M1     push hl ; 4 cycles
04009E 33          0003*M1     inc sp ; 1 cycle
04009F F1          0004*M1     pop af ; 4 cycles
0400A0             0005*M1     ; 10 cycles total
0400A0 CD AA 00 04 0076*       CALL printHex8
0400A4             0077*   ; Print a 16-bit HEX number
0400A4             0078*   ; HL: Number to print
0400A4             0079*   printHex16:
0400A4 7C          0080*       LD A,H
0400A5 CD AA 00 04 0081*       CALL printHex8
0400A9 7D          0082*       LD A,L
0400AA             0083*   ; Print an 8-bit HEX number
0400AA             0084*   ; A: Number to print
0400AA             0085*   printHex8:
0400AA 4F          0086*       LD C,A
0400AB 1F          0087*       RRA
0400AC 1F          0088*       RRA
0400AD 1F          0089*       RRA
0400AE 1F          0090*       RRA
0400AF CD B4 00 04 0091*       CALL @F
0400B3 79          0092*       LD A,C
0400B4             0093*   @@:
0400B4 E6 0F       0094*       AND 0Fh
0400B6 C6 90       0095*       ADD A,90h
0400B8 27          0096*       DAA
0400B9 CE 40       0097*       ADC A,40h
0400BB 27          0098*       DAA
0400BC 5B D7       0099*       RST.LIL 10h
0400BE C9          0100*       RET
0400BF             0101*   
0400BF             0102*   ; Print a 0x HEX prefix
0400BF             0103*   DisplayHexPrefix:
0400BF 3E 30       0104*       LD A, '0'
0400C1 5B D7       0105*       RST.LIL 10h
0400C3 3E 78       0106*       LD A, 'x'
0400C5 5B D7       0107*       RST.LIL 10h
0400C7 C9          0108*       RET
0400C8             0109*   
0400C8             0110*       MACRO printDecBC
0400C8             0111*       push hl
0400C8             0112*       push bc
0400C8             0113*       pop hl
0400C8             0114*       call printDec
0400C8             0115*       pop hl
0400C8             0116*       ENDMACRO
0400C8             0117*   
0400C8             0118*       MACRO printDecDE
0400C8             0119*       push hl
0400C8             0120*       push de
0400C8             0121*       pop hl
0400C8             0122*       call printDec
0400C8             0123*       pop hl
0400C8             0124*       ENDMACRO
0400C8             0125*   
0400C8             0126*       MACRO printDecHL
0400C8             0127*       call printDec
0400C8             0128*       ENDMACRO
0400C8             0129*   
0400C8             0130*       MACRO printDecIX
0400C8             0131*       push hl
0400C8             0132*       push ix
0400C8             0133*       pop hl
0400C8             0134*       call printDec
0400C8             0135*       pop hl
0400C8             0136*       ENDMACRO
0400C8             0137*   
0400C8             0138*       MACRO printDecIY
0400C8             0139*       push hl
0400C8             0140*       push iy
0400C8             0141*       pop hl
0400C8             0142*       call printDec
0400C8             0143*       pop hl
0400C8             0144*       ENDMACRO
0400C8             0145*   
0400C8             0146*   
0400C8             0147*   ; Prints the right justified decimal value in UHL without leading zeroes
0400C8             0148*   ; UHL : Value to print
0400C8             0149*   ; preserves all registers and flags
0400C8             0150*   printDec:
0400C8             0151*   ; back up all the things
0400C8 F5          0152*       push af
0400C9 C5          0153*       push bc
0400CA D5          0154*       push de
0400CB E5          0155*       push hl
0400CC 11 F4 00 04 0156*       LD DE, _printDecBuffer
0400D0 CD A0 01 04 0157*       CALL u24_to_ascii
0400D4             0158*   ; replace leading zeroes with spaces
0400D4 21 F4 00 04 0159*       LD HL, _printDecBuffer
0400D8 06 07       0160*       ld B, 7 ; if HL was 0, we want to keep the final zero
0400DA             0161*   @loop:
0400DA 7E          0162*       LD A, (HL)
0400DB FE 30       0163*       CP '0'
0400DD C2 E7 00 04 0164*       JP NZ, @done
0400E1 3E 20       0165*       LD A, ' '
0400E3 77          0166*       LD (HL), A
0400E4 23          0167*       INC HL
0400E5 10 F3       0168*       DJNZ @loop
0400E7             0169*   @done:
0400E7 21 F4 00 04 0170*       LD HL, _printDecBuffer
0400EB CD 63 00 04 0171*       CALL printString
0400EF             0172*   ; restore all the things
0400EF E1          0173*       pop hl
0400F0 D1          0174*       pop de
0400F1 C1          0175*       pop bc
0400F2 F1          0176*       pop af
0400F3 C9          0177*       RET
0400F4 00 00 00 00 0178*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040104 00 00 00 00 0179*   _printDec168Buffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040114             0180*   
040114             0181*   ; same as printDec but signed
040114             0182*   printDecS:
040114             0183*   ; back up all the things
040114 F5          0184*       push af
040115 C5          0185*       push bc
040116 D5          0186*       push de
040117 E5          0187*       push hl
040118 CD FB 0F 04 0188*       call hlu_abs ; abs(hl), sign flag set if negative
04011C F5          0189*       push af ; save sign flag
04011D 11 F4 00 04 0190*       LD DE, _printDecBuffer
040121 CD A0 01 04 0191*       CALL u24_to_ascii
040125             0192*   ; replace leading zeroes with spaces
040125 21 F4 00 04 0193*       LD HL, _printDecBuffer
040129 06 07       0194*       ld B, 7 ; if HL was 0, we want to keep the final zero
04012B F1          0195*       pop af ; restore sign flag
04012C 3E 20       0196*       ld a,' ' ; assume positive
04012E F2 34 01 04 0197*       jp p,@print
040132 3E 2D       0198*       ld a,'-'
040134             0199*   @print:
040134 5B D7       0200*       rst.lil 10h
040136             0201*   @loop:
040136 7E          0202*       LD A, (HL)
040137 FE 30       0203*       CP '0'
040139 C2 43 01 04 0204*       JP NZ, @done
04013D 3E 20       0205*       LD A, ' '
04013F 77          0206*       LD (HL), A
040140 23          0207*       INC HL
040141 10 F3       0208*       DJNZ @loop
040143             0209*   @done:
040143 21 F4 00 04 0210*       LD HL, _printDecBuffer
040147 CD 63 00 04 0211*       CALL printString
04014B             0212*   ; restore all the things
04014B E1          0213*       pop hl
04014C D1          0214*       pop de
04014D C1          0215*       pop bc
04014E F1          0216*       pop af
04014F C9          0217*       RET
040150             0218*   
040150             0219*   printDec8:
040150             0220*   ; back up all the things
040150 F5          0221*       push af
040151 C5          0222*       push bc
040152 D5          0223*       push de
040153 E5          0224*       push hl
040154             0225*   ; initialize hl to 0 and load it with a
040154 21 00 00 00 0226*       ld hl,0
040158 6F          0227*       ld l,a
040159             0228*   ; convert l to ascii
040159 11 F4 00 04 0229*       LD DE, _printDecBuffer
04015D CD C0 01 04 0230*       CALL u8_to_ascii
040161             0231*   ; replace leading zeroes with spaces
040161 21 F4 00 04 0232*       LD HL, _printDecBuffer
040165 06 03       0233*       ld B, 3 ; if A was 0, we want to keep the final zero
040167             0234*   @loop:
040167 7E          0235*       LD A, (HL)
040168 FE 30       0236*       CP '0'
04016A C2 74 01 04 0237*       JP NZ, @done
04016E 3E 20       0238*       LD A, ' '
040170 77          0239*       LD (HL), A
040171 23          0240*       INC HL
040172 10 F3       0241*       DJNZ @loop
040174             0242*   @done:
040174 21 F5 00 04 0243*       LD HL, _printDecBuffer+1
040178 CD 63 00 04 0244*       CALL printString
04017C             0245*   ; restore all the things
04017C E1          0246*       pop hl
04017D D1          0247*       pop de
04017E C1          0248*       pop bc
04017F F1          0249*       pop af
040180 C9          0250*       RET
040181             0251*   ; end printDec8
040181             0252*   
040181             0253*   printDecS8:
040181 F5          0254*       push af
040182 CB 7F       0255*       bit 7,a
040184 28 0E       0256*       jr z,@F
040186 ED 44       0257*       neg
040188 F5          0258*       push af
040189 3E 2D       0259*       ld a,'-'
04018B 5B D7       0260*       rst.lil 10h
04018D F1          0261*       pop af
04018E CD 50 01 04 0262*       call printDec8
040192 F1          0263*       pop af
040193 C9          0264*       ret
040194             0265*   @@:
040194 F5          0266*       push af
040195 3E 2B       0267*       ld a,'+'
040197 5B D7       0268*       rst.lil 10h
040199 F1          0269*       pop af
04019A CD 50 01 04 0270*       call printDec8
04019E F1          0271*       pop af
04019F C9          0272*       ret
0401A0             0273*   
0401A0             0274*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
0401A0             0275*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401A0             0276*   ; so it will allways be 8 characters length
0401A0             0277*   ; HL : Value to convert to string
0401A0             0278*   ; DE : pointer to buffer, at least 8 byte + 0
0401A0             0279*   u24_to_ascii:
0401A0 01 80 69 67 0280*       LD BC,-10000000
0401A4 CD D7 01 04 0281*       CALL one_digit
0401A8 01 C0 BD F0 0282*       LD BC,-1000000
0401AC CD D7 01 04 0283*       CALL one_digit
0401B0 01 60 79 FE 0284*       LD BC,-100000
0401B4 CD D7 01 04 0285*       CALL one_digit
0401B8 01 F0 D8 FF 0286*       LD BC,-10000
0401BC CD D7 01 04 0287*       CALL one_digit
0401C0             0288*   u8_to_ascii: ; same arguments but hl <= 255, uhl and h = 0
0401C0 01 18 FC FF 0289*       LD BC,-1000
0401C4 CD D7 01 04 0290*       CALL one_digit
0401C8 01 9C FF FF 0291*       LD BC,-100
0401CC CD D7 01 04 0292*       CALL one_digit
0401D0 0E F6       0293*       LD C,-10
0401D2 CD D7 01 04 0294*       CALL one_digit
0401D6 48          0295*       LD C,B
0401D7             0296*   one_digit:
0401D7 3E 2F       0297*       LD A,'0'-1
0401D9             0298*   @divide_me:
0401D9 3C          0299*       INC A
0401DA 09          0300*       ADD HL,BC
0401DB 38 FC       0301*       JR C,@divide_me
0401DD ED 42       0302*       SBC HL,BC
0401DF 12          0303*       LD (DE),A
0401E0 13          0304*       INC DE
0401E1 C9          0305*       RET
0401E2             0306*   
0401E2             0307*   print_u24:
0401E2 D5          0308*       push de
0401E3 E5          0309*       push hl
0401E4 11 F4 00 04 0310*       ld de,_printDecBuffer
0401E8 CD A0 01 04 0311*       call u24_to_ascii
0401EC 21 F4 00 04 0312*       ld hl,_printDecBuffer
0401F0 CD 63 00 04 0313*       call printString
0401F4 3E 20       0314*       ld a,' '
0401F6 5B D7       0315*       rst.lil 10h
0401F8 E1          0316*       pop hl
0401F9 D1          0317*       pop de
0401FA C9          0318*       ret
0401FB             0319*   
0401FB             0320*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0401FB             0321*   ; HL : Value to convert to string (integer part in H, fractional part in L)
0401FB             0322*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0401FB             0323*   u168_to_ascii:
0401FB             0324*   ; add a leading space to make room for sign flag if needed
0401FB 3E 20       0325*       ld a,' '
0401FD 12          0326*       ld (de),a
0401FE 13          0327*       inc de
0401FF             0328*   ; Convert integer part
0401FF E5          0329*       push hl ; Save HL (we’ll need the fractional part later)
040200             0330*       ; call hlu_udiv256 ; Shift to get integer portion in HL
040200             0331*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
040200 3B          0001*M1     dec sp ; 1 cycle
040201 E5          0002*M1     push hl ; 4 cycles
040202 33          0003*M1     inc sp ; 1 cycle
040203 E1          0004*M1     pop hl ; 4 cycles
040204 23          0005*M1     inc hl ; 1 cycle
040205 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040207             0007*M1     ; 13 cycles total
040207 01 F0 D8 FF 0332*       ld bc, -10000
04020B CD 2E 02 04 0333*       call @one_int
04020F 01 18 FC FF 0334*       ld bc, -1000
040213 CD 2E 02 04 0335*       call @one_int
040217 01 9C FF FF 0336*       ld bc, -100
04021B CD 2E 02 04 0337*       call @one_int
04021F 0E F6       0338*       ld c, -10
040221 CD 2E 02 04 0339*       call @one_int
040225 48          0340*       ld c, b
040226 CD 2E 02 04 0341*       call @one_int
04022A C3 39 02 04 0342*       jp @frac ; Jump to fractional part conversion
04022E             0343*   @one_int:
04022E 3E 2F       0344*       ld a, '0' - 1 ; Start ASCII character at '0'
040230             0345*   @divide_me:
040230 3C          0346*       inc a
040231 09          0347*       add hl, bc ; Accumulate until overflow
040232 38 FC       0348*       jr c, @divide_me
040234 ED 42       0349*       sbc hl, bc ; Remove excess after overflow
040236 12          0350*       ld (de), a ; Store ASCII digit
040237 13          0351*       inc de
040238 C9          0352*       ret
040239             0353*   ; Convert fractional part
040239             0354*   @frac:
040239 3E 2E       0355*       ld a, '.' ; Decimal point
04023B 12          0356*       ld (de), a
04023C 13          0357*       inc de
04023D E1          0358*       pop hl ; Restore HL with original fraction
04023E 06 03       0359*       ld b, 3 ; Loop counter for 3 fractional digits
040240             0360*   @frac_loop:
040240 26 0A       0361*       ld h, 10 ; Load multiplier for fractional part
040242 ED 6C       0362*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040244 3E 30       0363*       ld a, '0'
040246 84          0364*       add a, h ; Convert integer part to ASCII
040247 12          0365*       ld (de), a
040248 13          0366*       inc de
040249 10 F5       0367*       djnz @frac_loop ; Repeat for each fractional digit
04024B             0368*   ; Add null terminator
04024B AF          0369*       xor a ; Null terminator
04024C 12          0370*       ld (de), a
04024D C9          0371*       ret
04024E             0372*   
04024E             0373*   print_u168:
04024E D5          0374*       push de
04024F E5          0375*       push hl
040250 11 F4 00 04 0376*       ld de,_printDecBuffer
040254 CD FB 01 04 0377*       call u168_to_ascii
040258 21 F4 00 04 0378*       ld hl,_printDecBuffer
04025C CD 63 00 04 0379*       call printString
040260 E1          0380*       pop hl
040261 D1          0381*       pop de
040262 C9          0382*       ret
040263             0383*   
040263             0384*   ; signed version of u168_to_ascii
040263             0385*   s168_to_ascii:
040263 D5          0386*       push de ; save starting address of buffer
040264 CD FB 0F 04 0387*       call hlu_abs
040268 F5          0388*       push af ; save sign flag
040269 CD FB 01 04 0389*       call u168_to_ascii
04026D F1          0390*       pop af ; restore sign flag
04026E D1          0391*       pop de ; restore starting address of buffer
04026F F0          0392*       ret p ; hlu was positive so nothing to do
040270 3E 2D       0393*       ld a,'-'
040272 12          0394*       ld (de),a
040273 C9          0395*       ret
040274             0396*   
040274             0397*   print_s168:
040274 D5          0398*       push de
040275 E5          0399*       push hl
040276 11 04 01 04 0400*       ld de,_printDec168Buffer
04027A CD 63 02 04 0401*       call s168_to_ascii
04027E 21 04 01 04 0402*       ld hl,_printDec168Buffer
040282 CD 63 00 04 0403*       call printString
040286 E1          0404*       pop hl
040287 D1          0405*       pop de
040288 C9          0406*       ret
040289             0407*   
040289             0408*   print_s168_hl:
040289 F5          0409*       push af
04028A E5          0410*       push hl
04028B CD 74 02 04 0411*       call print_s168
04028F 3E 20       0412*       ld a,' '
040291 5B D7       0413*       rst.lil 10h
040293 E1          0414*       pop hl
040294 F1          0415*       pop af
040295 C9          0416*       ret
040296             0417*   
040296             0418*   print_s168_bc:
040296 F5          0419*       push af
040297 C5          0420*       push bc
040298 E5          0421*       push hl
040299 C5          0422*       push bc
04029A E1          0423*       pop hl
04029B CD 74 02 04 0424*       call print_s168
04029F 3E 20       0425*       ld a,' '
0402A1 5B D7       0426*       rst.lil 10h
0402A3 E1          0427*       pop hl
0402A4 C1          0428*       pop bc
0402A5 F1          0429*       pop af
0402A6 C9          0430*       ret
0402A7             0431*   
0402A7             0432*   print_s168_de:
0402A7 F5          0433*       push af
0402A8 D5          0434*       push de
0402A9 E5          0435*       push hl
0402AA EB          0436*       ex de,hl
0402AB CD 74 02 04 0437*       call print_s168
0402AF 3E 20       0438*       ld a,' '
0402B1 5B D7       0439*       rst.lil 10h
0402B3 E1          0440*       pop hl
0402B4 D1          0441*       pop de
0402B5 F1          0442*       pop af
0402B6 C9          0443*       ret
0402B7             0444*   
0402B7             0445*   print_s168_hl_bc_de:
0402B7 F5          0446*       push af
0402B8 C5          0447*       push bc
0402B9 D5          0448*       push de
0402BA E5          0449*       push hl
0402BB CD 74 02 04 0450*       call print_s168
0402BF 3E 20       0451*       ld a,' '
0402C1 5B D7       0452*       rst.lil 10h
0402C3 C5          0453*       push bc
0402C4 E1          0454*       pop hl
0402C5 CD 74 02 04 0455*       call print_s168
0402C9 3E 20       0456*       ld a,' '
0402CB 5B D7       0457*       rst.lil 10h
0402CD EB          0458*       ex de,hl
0402CE CD 74 02 04 0459*       call print_s168
0402D2 3E 20       0460*       ld a,' '
0402D4 5B D7       0461*       rst.lil 10h
0402D6 E1          0462*       pop hl
0402D7 D1          0463*       pop de
0402D8 C1          0464*       pop bc
0402D9 F1          0465*       pop af
0402DA C9          0466*       ret
0402DB             0467*   
0402DB             0468*   print_s168_bc_de:
0402DB F5          0469*       push af
0402DC C5          0470*       push bc
0402DD D5          0471*       push de
0402DE C5          0472*       push bc
0402DF E1          0473*       pop hl
0402E0 CD 74 02 04 0474*       call print_s168
0402E4 3E 20       0475*       ld a,' '
0402E6 5B D7       0476*       rst.lil 10h
0402E8 EB          0477*       ex de,hl
0402E9 CD 74 02 04 0478*       call print_s168
0402ED 3E 20       0479*       ld a,' '
0402EF 5B D7       0480*       rst.lil 10h
0402F1 E1          0481*       pop hl
0402F2 D1          0482*       pop de
0402F3 C1          0483*       pop bc
0402F4 F1          0484*       pop af
0402F5 C9          0485*       ret
0402F6             0486*   
0402F6             0487*   print_s168_a:
0402F6 F5          0488*       push af
0402F7 C5          0489*       push bc
0402F8 E5          0490*       push hl
0402F9 21 00 00 00 0491*       ld hl,0
0402FD 6F          0492*       ld l,a
0402FE CD 89 02 04 0493*       call print_s168_hl
040302 E1          0494*       pop hl
040303 C1          0495*       pop bc
040304 F1          0496*       pop af
040305 C9          0497*       ret
040306             0498*   
040306             0499*   ; #### new functions added by Brandon R. Gates ####
040306             0500*   
040306             0501*   ; print the binary representation of the 8-bit value in a
040306             0502*   printBin8:
040306 F5          0503*       push af
040307 E5          0504*       push hl
040308 C5          0505*       push bc
040309 D5          0506*       push de ; TOD0: WHY?
04030A 06 08       0507*       ld b,8 ; loop counter for 8 bits
04030C 21 2B 03 04 0508*       ld hl,@cmd ; set hl to the low byte of the output string
040310             0509*       ; (which will be the high bit of the value in a)
040310             0510*   @loop:
040310 07          0511*       rlca ; put the next highest bit into carry
040311 38 04       0512*       jr c,@one
040313 36 30       0513*       ld (hl),'0'
040315 18 02       0514*       jr @next_bit
040317             0515*   @one:
040317 36 31       0516*       ld (hl),'1'
040319             0517*   @next_bit:
040319 23          0518*       inc hl
04031A 10 F4       0519*       djnz @loop
04031C             0520*   ; print it
04031C 21 2B 03 04 0521*       ld hl,@cmd
040320 01 08 00 00 0522*       ld bc,@end-@cmd
040324 5B DF       0523*       rst.lil $18
040326 D1          0524*       pop de
040327 C1          0525*       pop bc
040328 E1          0526*       pop hl
040329 F1          0527*       pop af
04032A C9          0528*       ret
04032B             0529*   @cmd: ds 8 ; eight bytes for eight bits
040333             0530*   @end:
040333             0531*   
040333             0532*   printBinUHL:
040333             0533*       PUSH_ALL
                       M1 Args: none
       FF FF FF FF 
       FF FF FF FF 
040333 08          0001*M1     ex af,af'
040334 D9          0002*M1     exx
040335 F5          0003*M1     push af
040336 E5          0004*M1     push hl
040337 C5          0005*M1     push bc
040338 D5          0006*M1     push de
040339             0007*M1 
040339 08          0008*M1     ex af,af'
04033A D9          0009*M1     exx
04033B F5          0010*M1     push af
04033C E5          0011*M1     push hl
04033D C5          0012*M1     push bc
04033E D5          0013*M1     push de
04033F DD E5       0014*M1     push ix
040341 FD E5       0015*M1     push iy
040343             0534*       HLU_TO_A
                       M1 Args: none
040343 3B          0001*M1     dec sp ; 1 cycle
040344 E5          0002*M1     push hl ; 4 cycles
040345 33          0003*M1     inc sp ; 1 cycle
040346 F1          0004*M1     pop af ; 4 cycles
040347             0005*M1     ; 10 cycles total
040347 CD 06 03 04 0535*       call printBin8
04034B 3E 20       0536*       ld a,' '
04034D 5B D7       0537*       rst.lil 10h
04034F 7C          0538*       ld a,h
040350 CD 06 03 04 0539*       call printBin8
040354 3E 20       0540*       ld a,' '
040356 5B D7       0541*       rst.lil 10h
040358 7D          0542*       ld a,l
040359 CD 06 03 04 0543*       call printBin8
04035D 3E 20       0544*       ld a,' '
04035F 5B D7       0545*       rst.lil 10h
040361             0546*       POP_ALL
                       M1 Args: none
040361 FD E1       0001*M1     pop iy
040363 DD E1       0002*M1     pop ix
040365 D1          0003*M1     pop de
040366 C1          0004*M1     pop bc
040367 E1          0005*M1     pop hl
040368 F1          0006*M1     pop af
040369 08          0007*M1     ex af,af'
04036A D9          0008*M1     exx
04036B             0009*M1 
04036B D1          0010*M1     pop de
04036C C1          0011*M1     pop bc
04036D E1          0012*M1     pop hl
04036E F1          0013*M1     pop af
04036F 08          0014*M1     ex af,af'
040370 D9          0015*M1     exx
040371 C9          0547*       ret
040372             0548*   
040372             0549*   printBinHL:
040372             0550*       PUSH_ALL
                       M1 Args: none
040372 08          0001*M1     ex af,af'
040373 D9          0002*M1     exx
040374 F5          0003*M1     push af
040375 E5          0004*M1     push hl
040376 C5          0005*M1     push bc
040377 D5          0006*M1     push de
040378             0007*M1 
040378 08          0008*M1     ex af,af'
040379 D9          0009*M1     exx
04037A F5          0010*M1     push af
04037B E5          0011*M1     push hl
04037C C5          0012*M1     push bc
04037D D5          0013*M1     push de
04037E DD E5       0014*M1     push ix
040380 FD E5       0015*M1     push iy
040382 7C          0551*       ld a,h
040383 CD 06 03 04 0552*       call printBin8
040387 3E 20       0553*       ld a,' '
040389 5B D7       0554*       rst.lil 10h
04038B 7D          0555*       ld a,l
04038C CD 06 03 04 0556*       call printBin8
040390 3E 20       0557*       ld a,' '
040392 5B D7       0558*       rst.lil 10h
040394             0559*       POP_ALL
                       M1 Args: none
040394 FD E1       0001*M1     pop iy
040396 DD E1       0002*M1     pop ix
040398 D1          0003*M1     pop de
040399 C1          0004*M1     pop bc
04039A E1          0005*M1     pop hl
04039B F1          0006*M1     pop af
04039C 08          0007*M1     ex af,af'
04039D D9          0008*M1     exx
04039E             0009*M1 
04039E D1          0010*M1     pop de
04039F C1          0011*M1     pop bc
0403A0 E1          0012*M1     pop hl
0403A1 F1          0013*M1     pop af
0403A2 08          0014*M1     ex af,af'
0403A3 D9          0015*M1     exx
0403A4 C9          0560*       ret
0403A5             0561*   
0403A5             0562*   ; print the binary representation of the 8-bit value in a
0403A5             0563*   ; in reverse order (lsb first)
0403A5             0564*   ; destroys a, hl, bc
0403A5             0565*   printBin8Rev:
0403A5 06 08       0566*       ld b,8 ; loop counter for 8 bits
0403A7 21 C2 03 04 0567*       ld hl,@cmd ; set hl to the low byte of the output string
0403AB             0568*       ; (which will be the high bit of the value in a)
0403AB             0569*   @loop:
0403AB 0F          0570*       rrca ; put the next lowest bit into carry
0403AC 38 04       0571*       jr c,@one
0403AE 36 30       0572*       ld (hl),'0'
0403B0 18 02       0573*       jr @next_bit
0403B2             0574*   @one:
0403B2 36 31       0575*       ld (hl),'1'
0403B4             0576*   @next_bit:
0403B4 23          0577*       inc hl
0403B5 10 F4       0578*       djnz @loop
0403B7             0579*   ; print it
0403B7 21 C2 03 04 0580*       ld hl,@cmd
0403BB 01 08 00 00 0581*       ld bc,@end-@cmd
0403BF 5B DF       0582*       rst.lil $18
0403C1 C9          0583*       ret
0403C2             0584*   @cmd: ds 8 ; eight bytes for eight bits
0403CA             0585*   @end:
0403CA             0586*   
       FF FF FF FF 
       FF FF FF FF 
0403CA 20 61 66 3D 0587*   str_afu: db " af=",0
       00          
0403CF 20 68 6C 3D 0588*   str_hlu: db " hl=",0
       00          
0403D4 20 62 63 3D 0589*   str_bcu: db " bc=",0
       00          
0403D9 20 64 65 3D 0590*   str_deu: db " de=",0
       00          
0403DE 20 69 78 3D 0591*   str_ixu: db " ix=",0
       00          
0403E3 20 69 79 3D 0592*   str_iyu: db " iy=",0
       00          
0403E8             0593*   
0403E8             0594*   ; print udeuhl to screen in hexidecimal format
0403E8             0595*   ; inputs: none
0403E8             0596*   ; outputs: concatenated hexidecimal udeuhl
0403E8             0597*   ; destroys: nothing
0403E8             0598*   dumpUDEUHLHex:
0403E8             0599*   ; store everything in scratch
0403E8 22 47 04 04 0600*       ld (uhl),hl
0403EC ED 43 4A 04 0601*       ld (ubc),bc
       04          
0403F1 ED 53 4D 04 0602*       ld (ude),de
       04          
0403F6 DD 22 50 04 0603*       ld (uix),ix
       04          
0403FB FD 22 53 04 0604*       ld (uiy),iy
       04          
040400 F5          0605*       push af
040401             0606*   
040401             0607*   ; print each register
040401             0608*   
040401 21 3B 04 04 0609*       ld hl,str_udeuhl
040405 CD 63 00 04 0610*       call printString
040409 2A 4D 04 04 0611*       ld hl,(ude)
04040D CD 9C 00 04 0612*       call printHex24
040411 3E 2E       0613*       ld a,'.' ; print a dot to separate the values
040413 5B D7       0614*       rst.lil 10h
040415 2A 47 04 04 0615*       ld hl,(uhl)
040419 CD 9C 00 04 0616*       call printHex24
04041D CD 78 00 04 0617*       call printNewLine
040421             0618*   
040421             0619*   ; restore everything
040421 2A 47 04 04 0620*       ld hl, (uhl)
040425 ED 4B 4A 04 0621*       ld bc, (ubc)
       04          
04042A ED 5B 4D 04 0622*       ld de, (ude)
       04          
04042F DD 2A 50 04 0623*       ld ix, (uix)
       04          
040434 FD 2A 53 04 0624*       ld iy, (uiy)
       04          
040439 F1          0625*       pop af
04043A             0626*   ; all done
04043A C9          0627*       ret
04043B             0628*   
04043B 75 64 65 2E 0629*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
040444             0630*   
040444             0631*   ; global scratch memory for registers
040444 00 00 00    0632*   uaf: dl 0
040447 00 00 00    0633*   uhl: dl 0
04044A 00 00 00    0634*   ubc: dl 0
04044D 00 00 00    0635*   ude: dl 0
040450 00 00 00    0636*   uix: dl 0
040453 00 00 00    0637*   uiy: dl 0
040456 00 00 00    0638*   usp: dl 0
040459 00 00 00    0639*   upc: dl 0
04045C             0640*   
04045C             0641*   
04045C             0642*   ; set all the bits in the flag register
04045C             0643*   ; more of an academic exercise than anything useful
04045C             0644*   ; inputs; none
04045C             0645*   ; outputs; a=0,f=255
04045C             0646*   ; destroys: flags, hl
04045C             0647*   ; preserves: a, because why not
04045C             0648*   setAllFlags:
04045C 21 FF 00 00 0649*       ld hl,255
040460 67          0650*       ld h,a ; four cycles to preserve a is cheap
040461 E5          0651*       push hl
040462 F1          0652*       pop af
040463 C9          0653*       ret
040464             0654*   
040464             0655*   ; reset all the bits in the flag register
040464             0656*   ; unlike its inverse counterpart, this may actually be useful
040464             0657*   ; inputs; none
040464             0658*   ; outputs; a=0,f=0
040464             0659*   ; destroys: flags, hl
040464             0660*   ; preserves: a, because why not
040464             0661*   resetAllFlags:
040464 21 00 00 00 0662*       ld hl,0
040468 67          0663*       ld h,a ; four cycles to preserve a is cheap
040469 E5          0664*       push hl
04046A F1          0665*       pop af
04046B C9          0666*       ret
04046C             0667*   
04046C             0668*   ; wait until user presses a key
04046C             0669*   ; inputs: none
04046C             0670*   ; outputs: ascii code of key pressed in a
04046C             0671*   ; destroys: af,ix
04046C             0672*   waitKeypress:
04046C             0673*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
04046C 3E 00       0001*M1 			LD	A, function
04046E 5B CF       0002*M1 			RST.LIL	08h
040470 C9          0674*       ret
040471             0675*   
040471             0676*   ; clear a block of memory by writing a prescribed value to each byte in the range
040471             0677*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
040471             0678*   ; outputs: memory block is cleared
040471             0679*   ; destroys: hl, bc, de
040471             0680*   clear_mem:
040471 0B          0681*       dec bc ; we do this because we will increment de before writing the first byte
040472 77          0682*       ld (hl),a
040473 E5          0683*       push hl
040474 D1          0684*       pop de
040475 13          0685*       inc de ; target address
040476 ED B0       0686*       ldir
040478 C9          0687*       ret
040479             0031        include "../include/arith24.inc"
040479             0001*   ;------------------------------------------------------------------------
040479             0002*   ;  arith24.asm
040479             0003*   ;  24-bit ez80 arithmetic routines
040479             0004*   ;  Copyright (c) Shawn Sijnstra 2024
040479             0005*   ;  MIT license
040479             0006*   ;
040479             0007*   ;  This library was created as a tool to help make ez80
040479             0008*   ;  24-bit native assembly routines for simple mathematical problems
040479             0009*   ;  more widely available.
040479             0010*   ;
040479             0011*   ;------------------------------------------------------------------------
040479             0012*   
040479             0013*   ;------------------------------------------------------------------------
040479             0014*   ; umul24:	HL = HL*DE (unsigned)
040479             0015*   ; Preserves AF, BC, DE
040479             0016*   ; Uses a fast multiply routine.
040479             0017*   ;------------------------------------------------------------------------
040479             0018*   umul24:
040479 D5          0019*   	push	DE
04047A C5          0020*   	push	BC
04047B F5          0021*   	push	AF
04047C E5          0022*   	push	HL
04047D C1          0023*   	pop		BC
04047E 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
040480 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040484             0026*   umul24_lp:
040484 29          0027*   	add	hl,hl
040485 EB          0028*   	ex	de,hl
040486 29          0029*   	add	hl,hl
040487 EB          0030*   	ex	de,hl
040488 30 01       0031*   	jr	nc,umul24_nc
04048A 09          0032*   	add	hl,bc
04048B             0033*   umul24_nc:
04048B 3D          0034*   	dec	a
04048C 20 F6       0035*   	jr	nz,umul24_lp
04048E F1          0036*   	pop	af
04048F C1          0037*   	pop	bc
040490 D1          0038*   	pop	de
040491 C9          0039*   	ret
040492             0040*   
040492             0041*   
040492             0042*   ;------------------------------------------------------------------------
040492             0043*   ; udiv24
040492             0044*   ; Unsigned 24-bit division
040492             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040492             0046*   ;
040492             0047*   ; Uses AF BC DE HL
040492             0048*   ; Uses Restoring Division algorithm
040492             0049*   ;------------------------------------------------------------------------
040492             0050*   
040492             0051*   udiv24:
040492 E5          0052*   	push	hl
040493 C1          0053*   	pop		bc	;move dividend to BCU
040494 21 00 00 00 0054*   	ld		hl,0	;result
040498 A7          0055*   	and		a
040499 ED 52       0056*   	sbc		hl,de	;test for div by 0
04049B C8          0057*   	ret		z		;it's zero, carry flag is clear
04049C 19          0058*   	add		hl,de	;HL is 0 again
04049D 3E 18       0059*   	ld		a,24	;number of loops through.
04049F             0060*   udiv1:
04049F C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
0404A0 E3          0062*   	ex		(sp),hl
0404A1 37          0063*   	scf
0404A2 ED 6A       0064*   	adc	hl,hl
0404A4 E3          0065*   	ex	(sp),hl
0404A5 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
0404A6             0067*   
0404A6 ED 6A       0068*   	adc	hl,hl
0404A8 A7          0069*   	and	a		;is this the bug
0404A9 ED 52       0070*   	sbc	hl,de
0404AB 30 02       0071*   	jr	nc,udiv2
0404AD 19          0072*   	add	hl,de
0404AE             0073*   ;	dec	c
0404AE 0B          0074*   	dec	bc
0404AF             0075*   udiv2:
0404AF 3D          0076*   	dec	a
0404B0 20 ED       0077*   	jr	nz,udiv1
0404B2 37          0078*   	scf		;flag used for div0 error
0404B3 C5          0079*   	push	bc
0404B4 D1          0080*   	pop		de	;remainder
0404B5 C9          0081*   	ret
0404B6             0082*   
0404B6             0083*   
0404B6             0084*   
0404B6             0085*   ;------------------------------------------------------------------------
0404B6             0086*   ; neg24
0404B6             0087*   ; Returns: HLU = 0-HLU
0404B6             0088*   ; preserves all other registers
0404B6             0089*   ;------------------------------------------------------------------------
0404B6             0090*   neg24:
0404B6 D5          0091*   	push	de
0404B7 EB          0092*   	ex		de,hl
0404B8 21 00 00 00 0093*   	ld		hl,0
0404BC B7          0094*   	or		a
0404BD ED 52       0095*   	sbc		hl,de
0404BF D1          0096*   	pop		de
0404C0 C9          0097*   	ret
0404C1             0098*   
0404C1             0099*   ;------------------------------------------------------------------------
0404C1             0100*   ; or_hlu_deu: 24 bit bitwise OR
0404C1             0101*   ; Returns: hlu = hlu OR deu
0404C1             0102*   ; preserves all other registers
0404C1             0103*   ;------------------------------------------------------------------------
0404C1             0104*   or_hlu_deu:
0404C1 22 4A 05 04 0105*   	ld	(bitbuf1),hl
0404C5 ED 53 4D 05 0106*   	ld	(bitbuf2),de
       04          
0404CA D5          0107*   	push	de	;preserve DEU
0404CB C5          0108*   	push	bc	;preserve BCU
0404CC 06 03       0109*   	ld		b,3
0404CE 21 4A 05 04 0110*   	ld	hl,bitbuf1
0404D2 11 4A 05 04 0111*   	ld	de,bitbuf1
0404D6             0112*   orloop_24:
0404D6 1A          0113*   	ld	a,(de)
0404D7 B6          0114*   	or	(hl)
0404D8 12          0115*   	ld	(de),a
0404D9 13          0116*   	inc	de
0404DA 23          0117*   	inc	hl
0404DB 10 F9       0118*   	djnz	orloop_24
0404DD 2A 4D 05 04 0119*   	ld	hl,(bitbuf2)
0404E1 C1          0120*   	pop		bc	;restore BC
0404E2 D1          0121*   	pop		de	;restore DE
0404E3             0122*   
0404E3             0123*   ;------------------------------------------------------------------------
0404E3             0124*   ; and_hlu_deu: 24 bit bitwise AND
0404E3             0125*   ; Returns: hlu = hlu AND deu
0404E3             0126*   ; preserves all other registers
0404E3             0127*   ;------------------------------------------------------------------------
0404E3             0128*   and_hlu_deu:
0404E3 22 4A 05 04 0129*   	ld	(bitbuf1),hl
0404E7 ED 53 4D 05 0130*   	ld	(bitbuf2),de
       04          
0404EC D5          0131*   	push	de	;preserve DEU
0404ED C5          0132*   	push	bc	;preserve BCU
0404EE 06 03       0133*   	ld		b,3
0404F0 21 4A 05 04 0134*   	ld	hl,bitbuf1
0404F4 11 4A 05 04 0135*   	ld	de,bitbuf1
0404F8             0136*   andloop_24:
0404F8 1A          0137*   	ld	a,(de)
0404F9 A6          0138*   	and	(hl)
0404FA 12          0139*   	ld	(de),a
0404FB 13          0140*   	inc	de
0404FC 23          0141*   	inc	hl
0404FD 10 F9       0142*   	djnz	andloop_24
0404FF 2A 4D 05 04 0143*   	ld	hl,(bitbuf2)
040503 C1          0144*   	pop		bc	;restore BC
040504 D1          0145*   	pop		de	;restore DE
040505             0146*   
040505             0147*   ;------------------------------------------------------------------------
040505             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
040505             0149*   ; Returns: hlu = hlu XOR deu
040505             0150*   ; preserves all other registers
040505             0151*   ;------------------------------------------------------------------------
040505             0152*   xor_hlu_deu:
040505 22 4A 05 04 0153*   	ld	(bitbuf1),hl
040509 ED 53 4D 05 0154*   	ld	(bitbuf2),de
       04          
04050E D5          0155*   	push	de	;preserve DEU
04050F C5          0156*   	push	bc	;preserve BCU
040510 06 03       0157*   	ld		b,3
040512 21 4A 05 04 0158*   	ld	hl,bitbuf1
040516 11 4A 05 04 0159*   	ld	de,bitbuf1
04051A             0160*   xorloop_24:
04051A 1A          0161*   	ld	a,(de)
04051B AE          0162*   	xor	(hl)
04051C 12          0163*   	ld	(de),a
04051D 13          0164*   	inc	de
04051E 23          0165*   	inc	hl
04051F 10 F9       0166*   	djnz	xorloop_24
040521 2A 4D 05 04 0167*   	ld	hl,(bitbuf2)
040525 C1          0168*   	pop		bc	;restore BC
040526 D1          0169*   	pop		de	;restore DE
040527             0170*   
040527             0171*   ;------------------------------------------------------------------------
040527             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
040527             0173*   ; Returns: hlu = hlu << a
040527             0174*   ;		   a = 0
040527             0175*   ; NOTE: only considers a up to 16 bits.
040527             0176*   ; preserves all other registers
040527             0177*   ; modified by Brandon R. Gates to use a instead of de
040527             0178*   ;------------------------------------------------------------------------
040527             0179*   shl_hlu:
040527 B7          0180*   	or a
040528 C8          0181*   	ret		z		;we're done
040529 29          0182*   	add		hl,hl	;shift HLU left
04052A 3D          0183*   	dec a
04052B 18 FA       0184*   	jr		shl_hlu
04052D             0185*   
04052D             0186*   ;------------------------------------------------------------------------
04052D             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
04052D             0188*   ; Returns: hlu = hlu >> a
04052D             0189*   ;		   a = 0
04052D             0190*   ; NOTE: only considers a up to 16 bits.
04052D             0191*   ; preserves all other registers
04052D             0192*   ; modified by Brandon R. Gates to use a instead of de
04052D             0193*   ;------------------------------------------------------------------------
04052D             0194*   shr_hlu:
04052D 22 4A 05 04 0195*   	ld		(bitbuf1),hl
040531 21 4C 05 04 0196*   	ld		hl,bitbuf1+2
040535             0197*   @shr_loop:
040535 B7          0198*   	or a
040536 28 0D       0199*   	jr		z,@shr_done		;we're done
040538             0200*   ;carry is clear from or instruction
040538 CB 1E       0201*   	rr		(hl)
04053A 2B          0202*   	dec		hl
04053B CB 1E       0203*   	rr		(hl)
04053D 2B          0204*   	dec		hl
04053E CB 1E       0205*   	rr		(hl)
040540 23          0206*   	inc		hl
040541 23          0207*   	inc		hl
040542 3D          0208*   	dec a
040543 18 F0       0209*   	jr		@shr_loop
040545             0210*   @shr_done:
040545 2A 4A 05 04 0211*   	ld		hl,(bitbuf1)	;collect result
040549 C9          0212*   	ret
04054A             0213*   
04054A             0214*   ;------------------------------------------------------------------------
04054A             0215*   ; Scratch area for calculations
04054A             0216*   ;------------------------------------------------------------------------
04054A 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
04054D 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
040550             0219*   
040550             0220*   ; -----------------------------------------------------------------------
040550             0221*   ; Functions added by Brandon R. Gates
040550             0222*   ; -----------------------------------------------------------------------
040550             0223*   
040550             0224*   ;------------------------------------------------------------------------
040550             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
040550             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
040550             0227*   ;              HLU = HLU >> LSB(A)
040550             0228*   ; Returns: HLU = HLU >> LSB(A)
040550             0229*   ; Destroys: af
040550             0230*   ;------------------------------------------------------------------------
040550             0231*   shr_hlu_log2a:
040550 B7          0232*   	or a    ; check for zero
040551 C8          0233*   	ret z   ; nothing to shift so we're done
040552 C5          0234*   	push 	bc ; preserve
040553 06 00       0235*   	ld		b,0 ; clear b
040555             0236*   @find_bit:
040555 0F          0237*   	rrca ; bit 0 to carry
040556 DA 5F 05 04 0238*   	jp c,@found_bit
04055A 04          0239*   	inc b ; next bit
04055B C3 55 05 04 0240*   	jp @find_bit
04055F             0241*   @found_bit:
04055F 78          0242*   	ld a,b
040560 CD 2D 05 04 0243*   	call shr_hlu
040564 C1          0244*   	pop 	bc ; restore
040565 C9          0245*   	ret
040566             0246*   ; end shr_hlu_log2a
040566             0247*   
040566             0248*   ;------------------------------------------------------------------------
040566             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040566             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
040566             0251*   ;                HLU = HLU << LSB(A)
040566             0252*   ; Returns: HLU = HLU << LSB(A)
040566             0253*   ; Destroys: af
040566             0254*   ;------------------------------------------------------------------------
040566             0255*   shl_hlu_log2a:
040566 B7          0256*   	or a    ; check for zero
040567 C8          0257*   	ret z   ; nothing to shift so we're done
040568 C5          0258*   	push 	bc ; preserve
040569 06 00       0259*   	ld		b,0 ; clear b
04056B             0260*   @find_bit:
04056B 0F          0261*   	rrca ; bit 0 to carry
04056C DA 75 05 04 0262*   	jp c,@found_bit
040570 04          0263*   	inc b ; next bit
040571 C3 6B 05 04 0264*   	jp @find_bit
040575             0265*   @found_bit:
040575 78          0266*   	ld a,b
040576 CD 27 05 04 0267*   	call shl_hlu
04057A C1          0268*   	pop 	bc ; restore
04057B C9          0269*   	ret
04057C             0270*   ; end shl_hlu_log2a
04057C             0271*   
04057C             0272*   
04057C             0273*   ; UHL / UDE --> UDE (signed), remainder UHL (unsigned)
04057C F5          0274*   push af ; dummy push to make IDE happy
04057D             0275*   sdiv24:
04057D             0276*   ; make everything positive and store sign flags
04057D CD FB 0F 04 0277*       call hlu_abs
040581 F5          0278*       push af
040582 EB          0279*       ex de,hl
040583 CD FB 0F 04 0280*       call hlu_abs
040587 EB          0281*       ex de,hl
040588 F5          0282*       push af
040589             0283*   ; do the division
040589 CD 92 04 04 0284*       call udiv24 ; de = quotient, hl = remainder
04058D             0285*   ; adjust sign of result
04058D F1          0286*       pop af ; sign de
04058E FA 9B 05 04 0287*       jp m,@de_neg
040592 F1          0288*       pop af ; sign hl
040593 F0          0289*       ret p ; both positive, nothing to do
040594             0290*   @hl_neg:
040594 EB          0291*       ex de,hl ; quotient to hl for sign adjustment
040595 CD 0B 10 04 0292*       call neg_hlu ; de pos, hl neg, result is negative
040599 EB          0293*       ex de,hl ; negated quotient to de
04059A C9          0294*       ret
04059B             0295*   @de_neg:
04059B F1          0296*       pop af
04059C F8          0297*       ret m ; both negative, nothing to do
04059D EB          0298*       ex de,hl ; quotient to hl for sign adjustment
04059E CD 0B 10 04 0299*       call neg_hlu ; result is negative
0405A2 EB          0300*       ex de,hl ; negated quotient to de
0405A3 C9          0301*       ret
0405A4             0032        include "../include/fixed168.inc"
0405A4             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0405A4             0002*   ; uses EZ80 MLT instruction for speed
0405A4             0003*   ; operation: UHL * A --> UHL
0405A4             0004*   ; destroys: AF, HL
0405A4             0005*   smul24x8:
0405A4             0006*   ; make hl positive and store sign flag
0405A4 CD FB 0F 04 0007*       call hlu_abs
0405A8 F5          0008*       push af
0405A9             0009*   ; do the multiplication
0405A9 CD B4 05 04 0010*       call mul24x8 ; hl = product
0405AD             0011*   ; adjust sign of result
0405AD F1          0012*       pop af ; sign de
0405AE F0          0013*       ret p ; hl was positive, nothing to do
0405AF CD 0B 10 04 0014*       call neg_hlu ; result is negative
0405B3 C9          0015*       ret
0405B4             0016*   
0405B4             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0405B4             0018*   ; uses EZ80 MLT instruction for speed
0405B4             0019*   ; operation: UHL * A --> AUHL
0405B4             0020*   ; destroys: AF, HL
0405B4             0021*   mul24x8:
0405B4 D5          0022*       push de ; preserve de
0405B5             0023*   ; low byte
0405B5 5D          0024*       ld e,l
0405B6 57          0025*       ld d,a
0405B7 ED 5C       0026*       mlt de
0405B9 6B          0027*       ld l,e ; product low byte
0405BA 08          0028*       ex af,af' ; save multiplier
0405BB 7A          0029*       ld a,d ; carry
0405BC 08          0030*       ex af,af' ; save carry, restore multiplier
0405BD             0031*   ; high byte
0405BD 5C          0032*       ld e,h
0405BE 57          0033*       ld d,a
0405BF ED 5C       0034*       mlt de
0405C1 08          0035*       ex af,af' ; save multiplier, restore carry
0405C2 83          0036*       add a,e ; add carry
0405C3 67          0037*       ld h,a ; product middle byte
0405C4 7A          0038*       ld a,d ; carry
0405C5 08          0039*       ex af,af' ; save carry, restore multiplier
0405C6             0040*   ; upper byte
0405C6 22 E1 05 04 0041*       ld (@scratch),hl ; 7 cycles
0405CA 5F          0042*       ld e,a
0405CB 3A E3 05 04 0043*       ld a,(@scratch+2)
0405CF 57          0044*       ld d,a
0405D0 ED 5C       0045*       mlt de
0405D2 08          0046*       ex af,af' ; restore carry
0405D3 8B          0047*       adc a,e ; add carry
0405D4 32 E3 05 04 0048*       ld (@scratch+2),a ; 5 cycles
0405D8 2A E1 05 04 0049*       ld hl,(@scratch) ; 7 cycles
0405DC             0050*   ; highest byte
0405DC 3E 00       0051*       ld a,0 ; preserve carry flag
0405DE 8A          0052*       adc a,d ; product highest byte
0405DF D1          0053*       pop de ; restore de
0405E0 C9          0054*       ret
0405E1             0055*   @scratch: ds 3
0405E4             0056*   
       FF FF FF 
0405E4 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
0405EA             0058*   
0405EA             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0405EA             0060*   ; operation: UHL * UDE --> mul24out
0405EA             0061*   mul24:
0405EA DD E5       0062*       push ix ; preserve
0405EC             0063*   ; point to output buffer and clear it
0405EC DD 21 E4 05 0064*       ld ix,mul24out
       04          
0405F1 C5          0065*       push bc
0405F2 01 00 00 00 0066*       ld bc,0
0405F6 DD 0F 00    0067*       ld (ix),bc
0405F9 DD 0F 03    0068*       ld (ix+3),bc
0405FC C1          0069*       pop bc
0405FD             0070*   ; STEP 1: UHL * E
0405FD 7B          0071*       ld a,e
0405FE E5          0072*       push hl
0405FF CD B4 05 04 0073*       call mul24x8
040603 DD 2F 00    0074*       ld (ix+0),hl
040606 DD 77 03    0075*       ld (ix+3),a
040609             0076*   ; STEP 2: UHL * D
040609 E1          0077*       pop hl
04060A E5          0078*       push hl
04060B 7A          0079*       ld a,d
04060C CD B4 05 04 0080*       call mul24x8
040610 CD 29 06 04 0081*       call @accumulate
040614             0082*   ; STEP 3: UHL * DEU
040614 E1          0083*       pop hl
040615 ED 53 59 06 0084*       ld (@de),de
       04          
04061A 3A 5B 06 04 0085*       ld a,(@de+2)
04061E CD B4 05 04 0086*       call mul24x8
040622 CD 29 06 04 0087*       call @accumulate
040626             0088*   ; all done
040626 DD E1       0089*       pop ix ; restore
040628 C9          0090*       ret
040629             0091*   @accumulate:
040629 DD 23       0092*       inc ix
04062B             0093*   ; highest byte of product to carry
04062B DD 77 03    0094*       ld (ix+3),a
04062E             0095*   ; low byte of product
04062E 7D          0096*       ld a,l
04062F DD 86 00    0097*       add a,(ix+0)
040632 DD 77 00    0098*       ld (ix+0),a
040635             0099*   ; high byte of product
040635 7C          0100*       ld a,h
040636 DD 8E 01    0101*       adc a,(ix+1)
040639 DD 77 01    0102*       ld (ix+1),a
04063C             0103*   ; uppper byte of product
04063C 22 56 06 04 0104*       ld (@hl),hl
040640 3A 58 06 04 0105*       ld a,(@hl+2)
040644 DD 8E 02    0106*       adc a,(ix+2)
040647 DD 77 02    0107*       ld (ix+2),a
04064A             0108*   ; carry
04064A 3E 00       0109*       ld a,0 ; preserve flags
04064C DD 8E 03    0110*       adc a,(ix+3)
04064F DD 77 03    0111*       ld (ix+3),a
040652 C9          0112*       ret
040653             0113*   
040653 00 00 00    0114*   @ix: dl 0
040656 00 00 00    0115*   @hl: dl 0
040659 00 00 00    0116*   @de: dl 0
04065C             0117*   
04065C             0118*   ; UH.L = UH.L*UD.E (unsigned)
04065C             0119*   umul168:
04065C CD EA 05 04 0120*       call mul24
040660 2A E5 05 04 0121*       ld hl,(mul24out+1)
040664 C9          0122*       ret
040665             0123*   
040665             0124*   ; UH.L * UD.E --> UH.L (signed)
040665             0125*   smul168:
040665             0126*   ; make everything positive and store sign flags
040665 CD FB 0F 04 0127*       call hlu_abs
040669 F5          0128*       push af
04066A EB          0129*       ex de,hl
04066B CD FB 0F 04 0130*       call hlu_abs
04066F EB          0131*       ex de,hl
040670 F5          0132*       push af
040671             0133*   ; do the division
040671 CD 5C 06 04 0134*       call umul168 ; hl = product
040675             0135*   ; adjust sign of result
040675 F1          0136*       pop af ; sign de
040676 FA 81 06 04 0137*       jp m,@de_neg
04067A F1          0138*       pop af ; sign hl
04067B F0          0139*       ret p ; both positive, nothing to do
04067C             0140*   @hl_neg:
04067C CD 0B 10 04 0141*       call neg_hlu ; de pos, hl neg, result is negative
040680 C9          0142*       ret
040681             0143*   @de_neg:
040681 F1          0144*       pop af
040682 F8          0145*       ret m ; both negative, nothing to do
040683 CD 0B 10 04 0146*       call neg_hlu ; result is negative
040687 C9          0147*       ret
040688             0148*   
040688             0149*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040688             0150*   ; perform unsigned division of 16.8 fixed place values
040688             0151*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
040688             0152*   udiv168:
040688             0153*   ; back up divisor
040688 ED 53 BF 06 0154*       ld (@ude),de
       04          
04068D             0155*   ; get the 16-bit integer part of the quotient
04068D CD 92 04 04 0156*       call udiv24 ; de = quotient, hl = remainder
040691             0157*   ; load quotient to upper three bytes of output
040691 ED 53 C6 06 0158*       ld (div168_out+1),de
       04          
040696             0159*   @div256:
040696             0160*   ; multiply remainder by 256
040696             0161*       hlu_mul256
                       M1 Args: none
040696 29          0001*M1     add hl,hl ; * 2
040697 29          0002*M1     add hl,hl ; * 4
040698 29          0003*M1     add hl,hl ; * 8
040699 29          0004*M1     add hl,hl ; * 16
04069A 29          0005*M1     add hl,hl ; * 32
04069B 29          0006*M1     add hl,hl ; * 64
04069C 29          0007*M1     add hl,hl ; * 128
04069D 29          0008*M1     add hl,hl ; * 256
04069E             0162*   ; skip fractional computation if remainder is zero
04069E             0163*       SIGN_HLU
                       M1 Args: none
04069E 19          0001*M1     add hl,de ; 1 cycle
04069F B7          0002*M1     or a ; clear flags ; 1 cycle
0406A0 ED 52       0003*M1     sbc hl,de ; 2 cycles
0406A2             0004*M1     ; 4 cycles total
0406A2 20 03       0164*       jr nz,@div_frac
0406A4 AF          0165*       xor a
0406A5 18 0A       0166*       jr @write_frac
0406A7             0167*   ; now divide the shifted remainder by the divisor
0406A7             0168*   @div_frac:
0406A7 ED 5B BF 06 0169*       ld de,(@ude) ; get back divisor
       04          
0406AC CD 92 04 04 0170*       call udiv24 ; de = quotient, hl = remainder
0406B0             0171*   ; load low byte of quotient to low byte of output
0406B0 7B          0172*       ld a,e
0406B1             0173*   @write_frac:
0406B1 32 C5 06 04 0174*       ld (div168_out),a
0406B5             0175*   ; load de with return value
0406B5 ED 5B C5 06 0176*       ld de,(div168_out)
       04          
0406BA             0177*   ; load a with any overflow
0406BA 3A C8 06 04 0178*       ld a,(div168_out+3)
0406BE C9          0179*       ret ; ud.e is the 16.8 result
0406BF             0180*   @ude: ds 6
0406C5             0181*   div168_out: ds 4 ; the extra byte is for overflow
0406C9             0182*   
0406C9             0183*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0406C9             0184*   ; perform signed division of 16.8 fixed place values
0406C9             0185*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0406C9             0186*   sdiv168:
0406C9             0187*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
0406C9 CD FB 0F 04 0188*       call hlu_abs
0406CD F5          0189*       push af
0406CE EB          0190*       ex de,hl
0406CF CD FB 0F 04 0191*       call hlu_abs
0406D3 EB          0192*       ex de,hl
0406D4 F5          0193*       push af
0406D5             0194*   ; do the division
0406D5 CD 88 06 04 0195*       call udiv168 ; de = quotient, hl = remainder
0406D9             0196*   ; adjust sign of result
0406D9 F1          0197*       pop af ; sign de
0406DA FA E7 06 04 0198*       jp m,@de_neg
0406DE F1          0199*       pop af ; sign hl
0406DF F0          0200*       ret p ; both positive, nothing to do
0406E0             0201*   @hl_neg:
0406E0 EB          0202*       ex de,hl ; hl = quotient, de = remainder
0406E1 CD 0B 10 04 0203*       call neg_hlu ; de pos, hl neg, result is negative
0406E5 EB          0204*       ex de,hl ; de = negated quotient, hl = remainder
0406E6 C9          0205*       ret
0406E7             0206*   @de_neg:
0406E7 F1          0207*       pop af
0406E8 F8          0208*       ret m ; both negative, nothing to do
0406E9 EB          0209*       ex de,hl ; hl = quotient, de = remainder
0406EA CD 0B 10 04 0210*       call neg_hlu ; result is negative
0406EE EB          0211*       ex de,hl ; de = negated quotient, hl = remainder
0406EF C9          0212*       ret
0406F0             0213*   
0406F0             0214*   ; convert signed angles from a 360 to 256 degree circle
0406F0             0215*   ; inputs: uh.l is the angle360 in 16.8 fixed format
0406F0             0216*   ; outputs: uh.l is the angle256 in 16.8 fixed format
0406F0             0217*   ; destroys: TODO
0406F0             0218*   deg_360_to_256:
0406F0 D5          0219*       push de ; preserve de
0406F1             0220*   ; make angle positive and store sign flag
0406F1 CD FB 0F 04 0221*       call hlu_abs
0406F5 F5          0222*       push af
0406F6             0223*   ; multiply by coversion factor of 256/360
0406F6 11 B6 00 00 0224*       ld de,0x0000B6 ; 0.711
0406FA CD 5C 06 04 0225*       call umul168 ; uh.l = uh.l * 0.711
0406FE             0226*   ; restore sign flag and adjust output accordingly
0406FE F1          0227*       pop af
0406FF F2 07 07 04 0228*       jp p,@pos ; positive number
040703 CD 0B 10 04 0229*       call neg_hlu
040707             0230*   @pos:
040707             0231*   ; restore de and return uh.l as the result
040707 D1          0232*       pop de
040708 C9          0233*       ret
040709             0234*   
040709             0235*   ; convert signed angles from a 256 to 360 degree circle
040709             0236*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040709             0237*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040709             0238*   ; destroys: TODO
040709             0239*   deg_256_to_360:
040709 D5          0240*       push de ; preserve de
04070A             0241*   ; make angle positive and store sign flag
04070A CD FB 0F 04 0242*       call hlu_abs
04070E F5          0243*       push af
04070F             0244*   ; multiply by coversion factor of 360/256
04070F 11 68 01 00 0245*       ld de,0x000168 ; 1.406
040713 CD 5C 06 04 0246*       call umul168 ; uh.l = uh.l * 1.406
040717             0247*   ; restore sign flag and adjust output accordingly
040717 F1          0248*       pop af
040718 F2 20 07 04 0249*       jp p,@pos ; positive number
04071C CD 0B 10 04 0250*       call neg_hlu
040720             0251*   @pos:
040720             0252*   ; restore de and return uh.l as the result
040720 D1          0253*       pop de
040721 C9          0254*       ret
040722             0255*   
040722             0256*   ; fixed 16.8 routine
040722             0257*   ; cos(uh.l) --> uh.l
040722             0258*   ; destroys: f, hl
040722             0259*   cos168:
040722 D5          0260*       push de ; preserve de
040723             0261*   ; for cos we simply increment the angle by 90 degrees
040723             0262*   ; or 0x004000 in 16.8 degrees256
040723             0263*   ; which makes it a sin problem
040723 11 00 40 00 0264*       ld de,0x004000
040727 19          0265*       add hl,de ; modulo 256 happens below
040728 D1          0266*       pop de ; restore de
040729             0267*   ; fall through to sin168
040729             0268*   
040729             0269*   ; ---------------------
040729             0270*   ; fixed 16.8 routine
040729             0271*   ; sin(uh.l) --> uh.l
040729             0272*   ; destroys: f, hl
040729             0273*   sin168:
040729 D5          0274*       push de
04072A             0275*   ; handle negative angles appropriately
04072A CD FB 0F 04 0276*       call hlu_abs
04072E F2 37 07 04 0277*       jp p,@F
040732 11 00 00 FF 0278*       ld de,-256*256
040736 19          0279*       add hl,de
040737             0280*   @@:
040737 2E 03       0281*       ld l,3 ; multiply by 3 to get our lookup index
040739 ED 6C       0282*       mlt hl
04073B 11 EF 09 04 0283*       ld de,sin_lut_168 ; grab the lut address
04073F 19          0284*       add hl,de ; bump hl by the index
040740 ED 27       0285*       ld hl,(hl) ; don't try this on a z80!
040742 D1          0286*       pop de
040743 C9          0287*       ret
040744             0288*   
040744             0289*   ; 16.8 fixed inputs / outputs
040744             0290*   ; takes: uh.l as angle in degrees 256
040744             0291*   ;        ud.e as radius
040744             0292*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
040744             0293*   ;        displacements from origin (0,0)
040744             0294*   ; destroys: everything except indexes
040744             0295*   polar_to_cartesian:
040744             0296*   ; back up input parameters
040744 22 73 07 04 0297*       ld (@angle), hl
040748 ED 53 76 07 0298*       ld (@radius), de
       04          
04074D             0299*   ; compute dx = sin(uh.l) * ud.e
04074D CD 29 07 04 0300*       call sin168 ; uh.l = sin(uh.l)
040751 ED 5B 76 07 0301*       ld de,(@radius)
       04          
040756 CD 65 06 04 0302*       call smul168 ; uh.l = dx
04075A E5          0303*       push hl
04075B             0304*   ; compute dy = -cos(uh.l) * ud.e
04075B 2A 73 07 04 0305*       ld hl,(@angle)
04075F CD 22 07 04 0306*       call cos168 ; uh.l = cos(uh.l)
040763 ED 5B 76 07 0307*       ld de,(@radius)
       04          
040768 CD 65 06 04 0308*       call smul168 ; uh.l = dy
04076C CD 0B 10 04 0309*       call neg_hlu ; invert dy for screen coords convention
040770 EB          0310*       ex de,hl ; de = dy for output
040771 C1          0311*       pop bc ; bc = dx for output
040772             0312*   ; and out
040772 C9          0313*       ret
040773             0314*   @angle: ds 3
040776             0315*   @radius: ds 3
040779             0316*   
040779             0317*   ; 16.8 fixed inputs / outputs
040779             0318*   ; inputs: ub.c as dx, ud.e as dy
040779             0319*   ;        displacements from origin (0,0)
040779             0320*   ; returns: uh.l as angle in degrees 256
040779             0321*   ;        ud.e as radius
040779             0322*   ; destroys: everything except indexes
040779             0323*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
040779 ED 43 D2 07 0324*       ld (dx168),bc ; dx argument for distance168
       04          
04077E ED 53 D8 07 0325*       ld (dy168),de ; dy argument for distance168
       04          
040783             0326*   ; compute radius
040783 CD DE 07 04 0327*       call distance168 ; uh.l = radius
040787 E5          0328*       push hl ; save radius
040788             0329*   ; compute angle
040788 ED 4B D2 07 0330*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
04078D ED 5B D8 07 0331*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040792 CD 3E 08 04 0332*       call atan2_168fast ; uh.l = angle
040796             0333*   ; return result
040796 D1          0334*       pop de ; de = radius (was hl)
040797 C9          0335*       ret
040798             0336*   ; end cartesian_to_polar
040798             0337*   
040798             0338*   ; 16.8 fixed inputs / outputs
040798             0339*   ; inputs: ub.c as dx, ud.e as dy
040798             0340*   ;        displacements from origin (0,0)
040798             0341*   ; returns: uh.l as angle in degrees 256
040798             0342*   ;        ud.e as radius
040798             0343*   ; destroys: everything except indexes
040798             0344*   ; note: uses distance168sm which is more accurate for small deltas
040798             0345*   cartesian_to_polar_sm:
040798 ED 43 D2 07 0346*       ld (dx168),bc ; dx argument for distance168
       04          
04079D ED 53 D8 07 0347*       ld (dy168),de ; dy argument for distance168
       04          
0407A2             0348*   ; compute radius
0407A2 CD 19 08 04 0349*       call distance168sm ; uh.l = radius
0407A6 E5          0350*       push hl ; save radius
0407A7             0351*   ; compute angle
0407A7 ED 4B D2 07 0352*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
0407AC ED 5B D8 07 0353*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
0407B1 CD 3E 08 04 0354*       call atan2_168fast ; uh.l = angle
0407B5             0355*   ; return result
0407B5 D1          0356*       pop de ; de = radius (was hl)
0407B6 C9          0357*       ret
0407B7             0358*   ; end cartesian_to_polar
0407B7             0359*   
0407B7             0360*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0407B7             0361*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0407B7             0362*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0407B7             0363*   ;         also populates scratch locations dx168 and dy168
0407B7             0364*   ; destroys: a,hl,bc,de
0407B7             0365*   dxy168:
0407B7             0366*   ; compute dx = x1-x0
0407B7 AF          0367*       xor a ; clear carry
0407B8 DD E5       0368*       push ix ; move ix to hl via the stack
0407BA E1          0369*       pop hl ; hl = x1
0407BB ED 42       0370*       sbc hl,bc ; hl = dx
0407BD 22 D2 07 04 0371*       ld (dx168),hl ; dx to scratch
0407C1             0372*   ; compute dy = y1-y0
0407C1 AF          0373*       xor a ; clear carry
0407C2 FD E5       0374*       push iy ; move iy to hl via the stack
0407C4 E1          0375*       pop hl ; hl = y1
0407C5 ED 52       0376*       sbc hl,de ; hl = dy
0407C7 22 D8 07 04 0377*       ld (dy168),hl ; dy to scratch
0407CB             0378*   ; populate output registers and return
0407CB EB          0379*       ex de,hl ; ud.e = dy
0407CC ED 4B D2 07 0380*       ld bc,(dx168) ; ub.c = dx
       04          
0407D1 C9          0381*       ret
0407D2 00 00 00 00 0382*   dx168: blkb 6,0
       00 00       
0407D8 00 00 00 00 0383*   dy168: blkb 6,0
       00 00       
0407DE             0384*   
0407DE             0385*   ; compute the euclidian distance between two cartesian coordinates
0407DE             0386*   ; using the formula d = sqrt(dx^2+dy^2)
0407DE             0387*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
0407DE             0388*   ; output; uh.l is the 16.8 fixed format distance
0407DE             0389*   ;         also populates scratch locations dx168 and dy168
0407DE             0390*   ; destroys: a,hl,bc,de
0407DE             0391*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0407DE             0392*   ;       thus the result will always be an integer, albeit in 16.8 format
0407DE             0393*   distance168:
0407DE             0394*   ; compute dy^2
0407DE 2A D8 07 04 0395*       ld hl,(dy168)
0407E2 CD FB 0F 04 0396*       call hlu_abs
0407E6             0397*       ; call hlu_udiv256 ; make integer to avoid overflow
0407E6             0398*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
0407E6 3B          0001*M1     dec sp ; 1 cycle
0407E7 E5          0002*M1     push hl ; 4 cycles
0407E8 33          0003*M1     inc sp ; 1 cycle
0407E9 E1          0004*M1     pop hl ; 4 cycles
0407EA 23          0005*M1     inc hl ; 1 cycle
0407EB 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0407ED             0007*M1     ; 13 cycles total
0407ED E5          0399*       push hl
0407EE D1          0400*       pop de
0407EF CD 79 04 04 0401*       call umul24 ; hl = dy^2
0407F3 E5          0402*       push hl ; save dy^2
0407F4             0403*   ; compute dx^2
0407F4 2A D2 07 04 0404*       ld hl,(dx168)
0407F8 CD FB 0F 04 0405*       call hlu_abs
0407FC             0406*       ; call hlu_udiv256 ; make integer to avoid overflow
0407FC             0407*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
0407FC 3B          0001*M1     dec sp ; 1 cycle
0407FD E5          0002*M1     push hl ; 4 cycles
0407FE 33          0003*M1     inc sp ; 1 cycle
0407FF E1          0004*M1     pop hl ; 4 cycles
040800 23          0005*M1     inc hl ; 1 cycle
040801 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040803             0007*M1     ; 13 cycles total
040803 E5          0408*       push hl
040804 D1          0409*       pop de
040805 CD 79 04 04 0410*       call umul24 ; hl = dx^2
040809             0411*   ; add dx^2 and dy^2
040809 D1          0412*       pop de ; de = dy^2 (was hl)
04080A 19          0413*       add hl,de ; hl = dx^2 + dy^2
04080B             0414*   ; compute the square root
04080B CD 09 09 04 0415*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
04080F EB          0416*       ex de,hl ; hl = distance
040810             0417*       hlu_mul256 ; convert back to 16.8 fixed
                       M1 Args: none
040810 29          0001*M1     add hl,hl ; * 2
040811 29          0002*M1     add hl,hl ; * 4
040812 29          0003*M1     add hl,hl ; * 8
040813 29          0004*M1     add hl,hl ; * 16
040814 29          0005*M1     add hl,hl ; * 32
040815 29          0006*M1     add hl,hl ; * 64
040816 29          0007*M1     add hl,hl ; * 128
040817 29          0008*M1     add hl,hl ; * 256
040818 C9          0418*       ret
040819             0419*   
040819             0420*   ; compute the euclidian distance between two cartesian coordinates
040819             0421*   ; using the formula d = sqrt(dx^2+dy^2)
040819             0422*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040819             0423*   ; output; uh.l is the 16.8 fixed format distance
040819             0424*   ;         also populates scratch locations dx168 and dy168
040819             0425*   ; destroys: a,hl,bc,de
040819             0426*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040819             0427*   ;       making it more accurate for small deltas,
040819             0428*   ;       but will overflow if used for screen-sized deltas
040819             0429*   distance168sm:
040819             0430*   ; compute dy^2
040819 2A D8 07 04 0431*       ld hl,(dy168)
04081D CD FB 0F 04 0432*       call hlu_abs
040821 E5          0433*       push hl
040822 D1          0434*       pop de
040823 CD 79 04 04 0435*       call umul24 ; hl = dy^2
040827 E5          0436*       push hl ; save dy^2
040828             0437*   ; compute dx^2
040828 2A D2 07 04 0438*       ld hl,(dx168)
04082C CD FB 0F 04 0439*       call hlu_abs
040830 E5          0440*       push hl
040831 D1          0441*       pop de
040832 CD 79 04 04 0442*       call umul24 ; hl = dx^2
040836             0443*   ; add dx^2 and dy^2
040836 D1          0444*       pop de ; de = dy^2 (was hl)
040837 19          0445*       add hl,de ; hl = dx^2 + dy^2
040838             0446*   ; compute the square root
040838 CD 09 09 04 0447*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
04083C EB          0448*       ex de,hl ; hl = distance
04083D C9          0449*       ret
04083E             0450*   
04083E             0451*   ; atan2_(ub.c,ud.e) --> uh.l
04083E             0452*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04083E             0453*   ;   whether inputs are integers or fractional doesn't matter
04083E             0454*   ;   so long as the sign bit of the upper byte is correct
04083E             0455*   ; output: uh.l is the 16.8 fixed angle in degrees 256
04083E             0456*   ; angles are COMPASS HEADINGS based on
04083E             0457*   ; screen coordinate conventions,where the y axis is flipped
04083E             0458*   ; #E0 224      0       32 #20
04083E             0459*   ;        -x,-y | +x,-y
04083E             0460*   ; #C0 192------+------ 64 #40
04083E             0461*   ;        -x,+y | +x,+y
04083E             0462*   ; #A0 160   128 #80   96 #60
04083E             0463*   atan2_168fast:
04083E             0464*   ; get signs and make everything positive
04083E             0465*   ; get abs(x) and store its original sign
04083E C5          0466*       push bc
04083F E1          0467*       pop hl
040840 CD FB 0F 04 0468*       call hlu_abs ; if x was negative this also sets the sign flag
040844 E5          0469*       push hl ; store abs(x)
040845 C1          0470*       pop bc ; bc = abs(x)
040846 F5          0471*       push af ; store sign of x
040847             0472*   ; get abs(y) and store its original sign
040847 EB          0473*       ex de,hl ; hl = y
040848 CD FB 0F 04 0474*       call hlu_abs ; if y was negative this also sets the sign flag
04084C EB          0475*       ex de,hl ; de = abs(y)
04084D F5          0476*       push af ; store sign of y
04084E             0477*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
04084E             0478*   ; this ensures that our lookup value is between 0 and 1 inclusive
04084E AF          0479*       xor a ; clear the carry flag
04084F D5          0480*       push de
040850 E1          0481*       pop hl
040851 ED 42       0482*       sbc hl,bc
040853 F5          0483*       push af ; save sign of de - bc
040854 F2 5D 08 04 0484*       jp p,@1 ; bc <= de, so we skip ahead
040858             0485*   ; otherwise we swap bc and de
040858 C5          0486*       push bc
040859 E1          0487*       pop hl
04085A EB          0488*       ex de,hl
04085B E5          0489*       push hl
04085C C1          0490*       pop bc
04085D             0491*   @1:
04085D             0492*   ; now we're ready to snag our preliminary result
04085D C5          0493*       push bc
04085E E1          0494*       pop hl
04085F CD CD 08 04 0495*       call atan_168fast ; uh.l comes back with prelim result
040863             0496*   ; now we adjust uh.l based on sign of de - bc
040863 F1          0497*       pop af
040864 F2 70 08 04 0498*       jp p,@2 ; bc <= de,so we skip ahead
040868 EB          0499*       ex de,hl
040869 21 00 40 00 0500*       ld hl,64*256 ; subtract from 64 (90) degrees
04086D AF          0501*       xor a ; clear the carry flag
04086E ED 52       0502*       sbc hl,de
040870             0503*   @2:
040870             0504*   ; adjust the result based on quadrant
040870             0505*   ; #E0 224      0       32 #20
040870             0506*   ;        -x,-y | +x,-y
040870             0507*   ; #C0 192------+------ 64 #40
040870             0508*   ;        -x,+y | +x,+y
040870             0509*   ; #A0 160   128 #80   96 #60
040870 F1          0510*       pop af ; sign of y
040871 CA AE 08 04 0511*       jp z,@y_zero
040875 F2 8E 08 04 0512*       jp p,@y_pos
040879             0513*   ; y neg,check x
040879 F1          0514*       pop af ; sign of x
04087A CA 88 08 04 0515*       jp z,@y_neg_x_zero
04087E F2 8D 08 04 0516*       jp p,@y_neg_x_pos
040882             0517*   ; y neg,x neg
040882             0518*   ; angle is 128 to 256 (270 to 360)
040882             0519*   ; negating the intermediate does the trick
040882 CD 0B 10 04 0520*       call neg_hlu
040886 18 31       0521*       jr @zero_hlu
040888             0522*   
040888             0523*   @y_neg_x_zero:
040888             0524*   ; y neg,x zero
040888             0525*   ; angle is 0
040888 21 00 00 00 0526*       ld hl,0
04088C C9          0527*       ret
04088D             0528*   @y_neg_x_pos:
04088D             0529*   ; y neg,x pos
04088D             0530*   ; angle is 0 to 64 (0 to 90)
04088D             0531*   ; so we're good
04088D C9          0532*       ret
04088E             0533*   
04088E             0534*   @y_pos:
04088E F1          0535*       pop af ; sign of x
04088F CA 9E 08 04 0536*       jp z,@y_pos_x_zero
040893 F2 A3 08 04 0537*       jp p,@y_pos_x_pos
040897             0538*   ; y pos,x neg
040897             0539*   ; angle is 128 to 192 (180-270)
040897             0540*   ; so we add 128 to intermediate
040897 11 00 80 00 0541*       ld de,128*256
04089B 19          0542*       add hl,de
04089C 18 1B       0543*       jr @zero_hlu
04089E             0544*   @y_pos_x_zero:
04089E             0545*   ; y pos,x zero
04089E             0546*   ; angle is 128 (180)
04089E 21 00 80 00 0547*       ld hl,128*256
0408A2 C9          0548*       ret
0408A3             0549*   @y_pos_x_pos:
0408A3             0550*   ; y pos,x pos
0408A3             0551*   ; angle is 64 to 128 (90 to 180)
0408A3             0552*   ; neg the intermediate and add 180 degrees
0408A3 CD 0B 10 04 0553*       call neg_hlu
0408A7 11 00 80 00 0554*       ld de,128*256
0408AB 19          0555*       add hl,de
0408AC 18 0B       0556*       jr @zero_hlu
0408AE             0557*   
0408AE             0558*   @y_zero:
0408AE F1          0559*       pop af ; sign of x
0408AF FA B4 08 04 0560*       jp m,@y_zero_x_neg
0408B3             0561*   ; y zero,x pos
0408B3             0562*   ; angle is 64 (90),nothing to do
0408B3 C9          0563*       ret
0408B4             0564*   @y_zero_x_neg:
0408B4             0565*   ; y zero ,x neg
0408B4             0566*   ; angle is 192 (270)
0408B4 21 00 C0 00 0567*       ld hl,192*256
0408B8 C9          0568*       ret
0408B9             0569*   @zero_hlu:
0408B9 AF          0570*       xor a
0408BA 22 C7 08 04 0571*       ld (@scratch),hl
0408BE 32 C9 08 04 0572*       ld (@scratch+2),a
0408C2 2A C7 08 04 0573*       ld hl,(@scratch)
0408C6 C9          0574*       ret
0408C7             0575*   @scratch: ds 6
0408CD             0576*   
0408CD             0577*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0408CD             0578*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
0408CD             0579*   ; destroys: a,hl,bc,de
0408CD             0580*   ; note: only works for angles from 0 to 32 (45) degrees
0408CD             0581*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
0408CD             0582*   atan_168fast:
0408CD             0583*   ; because we use compass headings instead of geometric angles
0408CD             0584*   ; we compute dx/dy which is 1/tan(theta) in the maths world
0408CD             0585*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
0408CD CD 88 06 04 0586*       call udiv168 ; ud.e = dx/dy
0408D1 EB          0587*       ex de,hl ; uh.l = dx/dy
0408D2             0588*   ; test uh.l for 0
0408D2 19          0589*       add hl,de
0408D3 B7          0590*       or a
0408D4 ED 52       0591*       sbc hl,de
0408D6 28 22       0592*       jr z,@is_zero
0408D8             0593*   ; test uh.l for 1
0408D8 AF          0594*       xor a ; clear carry
0408D9 EB          0595*       ex de,hl
0408DA 21 00 01 00 0596*       ld hl,1*256 ; 1 in 16.8 fixed format
0408DE ED 52       0597*       sbc hl,de
0408E0 28 13       0598*       jr z,@is_45
0408E2 EB          0599*       ex de,hl
0408E3             0600*   ; no special cases so we move on
0408E3             0601*   ; l contains the fractional portion of tan(uh.l)
0408E3             0602*   ; we multiply it by three to get our lookup table index
0408E3 26 03       0603*       ld h,3
0408E5 ED 6C       0604*       mlt hl ; index into lut
0408E7 11 00 00 00 0605*       ld de,0 ; clear deu
0408EB 54          0606*       ld d,h ; copy hl to de
0408EC 5D          0607*       ld e,l ; de contains our index
0408ED 21 F2 0C 04 0608*       ld hl,atan_lut_168 ; grab the lut address
0408F1 19          0609*       add hl,de ; bump hl by the index
0408F2 ED 27       0610*       ld hl,(hl) ; don't try this on a z80!
0408F4 C9          0611*       ret ; and out
0408F5             0612*   @is_45:
0408F5 21 00 20 00 0613*       ld hl,32*256
0408F9 C9          0614*       ret
0408FA             0615*   ; for the case tan(0)
0408FA             0616*   @is_zero:
0408FA 21 00 00 00 0617*       ld hl,0*256
0408FE C9          0618*       ret
0408FF             0619*   
0408FF             0620*   ; Expects  ADL mode
0408FF             0621*   ; Inputs:  UH.L
0408FF             0622*   ; Outputs: UH.L is the 16.8 square root
0408FF             0623*   ;          UDE is the integer difference inputHL-DE^2
0408FF             0624*   sqrt168:
0408FF CD 09 09 04 0625*       call sqrt24
040903 EB          0626*       ex de,hl
040904 29          0627*       add hl,hl
040905 29          0628*       add hl,hl
040906 29          0629*       add hl,hl
040907 29          0630*       add hl,hl
040908 C9          0631*       ret
040909             0632*   
040909             0633*   ; credit: xeda112358
040909             0634*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040909             0635*   sqrt24:
040909             0636*   ; Expects ADL mode
040909             0637*   ; Inputs: HL
040909             0638*   ; Outputs: DE is the integer square root
040909             0639*   ;  HL is the difference inputHL-DE^2
040909             0640*   ;  c flag reset
040909 01 00 00 00 0641*       ld bc,0 ; clear bcu
04090D 11 00 00 00 0642*       ld de,0 ; clear deu
040911 AF          0643*       xor a
040912 45          0644*       ld b,l
040913 C5          0645*       push bc
040914 47          0646*       ld b,a
040915 6F          0647*       ld l,a
040916             0648*   ; Iteration 1
040916 29          0649*       add hl,hl
040917 CB 11       0650*       rl c
040919 29          0651*       add hl,hl
04091A CB 11       0652*       rl c
04091C 91          0653*       sub c
04091D 30 04       0654*       jr nc,$+6
04091F 1C          0655*       inc e
040920 1C          0656*       inc e
040921 2F          0657*       cpl
040922 4F          0658*       ld c,a
040923             0659*   ; Iteration 2
040923 29          0660*       add hl,hl
040924 CB 11       0661*       rl c
040926 29          0662*       add hl,hl
040927 CB 11       0663*       rl c
040929 CB 13       0664*       rl e
04092B 7B          0665*       ld a,e
04092C 91          0666*       sub c
04092D 30 04       0667*       jr nc,$+6
04092F 1C          0668*       inc e
040930 1C          0669*       inc e
040931 2F          0670*       cpl
040932 4F          0671*       ld c,a
040933             0672*   ; Iteration 3
040933 29          0673*       add hl,hl
040934 CB 11       0674*       rl c
040936 29          0675*       add hl,hl
040937 CB 11       0676*       rl c
040939 CB 13       0677*       rl e
04093B 7B          0678*       ld a,e
04093C 91          0679*       sub c
04093D 30 04       0680*       jr nc,$+6
04093F 1C          0681*       inc e
040940 1C          0682*       inc e
040941 2F          0683*       cpl
040942 4F          0684*       ld c,a
040943             0685*   ; Iteration 4
040943 29          0686*       add hl,hl
040944 CB 11       0687*       rl c
040946 29          0688*       add hl,hl
040947 CB 11       0689*       rl c
040949 CB 13       0690*       rl e
04094B 7B          0691*       ld a,e
04094C 91          0692*       sub c
04094D 30 04       0693*       jr nc,$+6
04094F 1C          0694*       inc e
040950 1C          0695*       inc e
040951 2F          0696*       cpl
040952 4F          0697*       ld c,a
040953             0698*   ; Iteration 5
040953 29          0699*       add hl,hl
040954 CB 11       0700*       rl c
040956 29          0701*       add hl,hl
040957 CB 11       0702*       rl c
040959 CB 13       0703*       rl e
04095B 7B          0704*       ld a,e
04095C 91          0705*       sub c
04095D 30 04       0706*       jr nc,$+6
04095F 1C          0707*       inc e
040960 1C          0708*       inc e
040961 2F          0709*       cpl
040962 4F          0710*       ld c,a
040963             0711*   ; Iteration 6
040963 29          0712*       add hl,hl
040964 CB 11       0713*       rl c
040966 29          0714*       add hl,hl
040967 CB 11       0715*       rl c
040969 CB 13       0716*       rl e
04096B 7B          0717*       ld a,e
04096C 91          0718*       sub c
04096D 30 04       0719*       jr nc,$+6
04096F 1C          0720*       inc e
040970 1C          0721*       inc e
040971 2F          0722*       cpl
040972 4F          0723*       ld c,a
040973             0724*   ; Iteration 7
040973 29          0725*       add hl,hl
040974 CB 11       0726*       rl c
040976 29          0727*       add hl,hl
040977 CB 11       0728*       rl c
040979 CB 10       0729*       rl b
04097B EB          0730*       ex de,hl
04097C 29          0731*       add hl,hl
04097D E5          0732*       push hl
04097E ED 42       0733*       sbc hl,bc
040980 30 06       0734*       jr nc,$+8
040982 7C          0735*       ld a,h
040983 2F          0736*       cpl
040984 47          0737*       ld b,a
040985 7D          0738*       ld a,l
040986 2F          0739*       cpl
040987 4F          0740*       ld c,a
040988 E1          0741*       pop hl
040989 30 02       0742*       jr nc,$+4
04098B 23          0743*       inc hl
04098C 23          0744*       inc hl
04098D EB          0745*       ex de,hl
04098E             0746*   ; Iteration 8
04098E 29          0747*       add hl,hl
04098F 69          0748*       ld l,c
040990 60          0749*       ld h,b
040991 ED 6A       0750*       adc hl,hl
040993 ED 6A       0751*       adc hl,hl
040995 EB          0752*       ex de,hl
040996 29          0753*       add hl,hl
040997 ED 52       0754*       sbc hl,de
040999 19          0755*       add hl,de
04099A EB          0756*       ex de,hl
04099B 30 04       0757*       jr nc,$+6
04099D ED 52       0758*       sbc hl,de
04099F 13          0759*       inc de
0409A0 13          0760*       inc de
0409A1             0761*   ; Iteration 9
0409A1 F1          0762*       pop af
0409A2 17          0763*       rla
0409A3 ED 6A       0764*       adc hl,hl
0409A5 17          0765*       rla
0409A6 ED 6A       0766*       adc hl,hl
0409A8 EB          0767*       ex de,hl
0409A9 29          0768*       add hl,hl
0409AA ED 52       0769*       sbc hl,de
0409AC 19          0770*       add hl,de
0409AD EB          0771*       ex de,hl
0409AE 30 04       0772*       jr nc,$+6
0409B0 ED 52       0773*       sbc hl,de
0409B2 13          0774*       inc de
0409B3 13          0775*       inc de
0409B4             0776*   ; Iteration 10
0409B4 17          0777*       rla
0409B5 ED 6A       0778*       adc hl,hl
0409B7 17          0779*       rla
0409B8 ED 6A       0780*       adc hl,hl
0409BA EB          0781*       ex de,hl
0409BB 29          0782*       add hl,hl
0409BC ED 52       0783*       sbc hl,de
0409BE 19          0784*       add hl,de
0409BF EB          0785*       ex de,hl
0409C0 30 04       0786*       jr nc,$+6
0409C2 ED 52       0787*       sbc hl,de
0409C4 13          0788*       inc de
0409C5 13          0789*       inc de
0409C6             0790*   ; Iteration 11
0409C6 17          0791*       rla
0409C7 ED 6A       0792*       adc hl,hl
0409C9 17          0793*       rla
0409CA ED 6A       0794*       adc hl,hl
0409CC EB          0795*       ex de,hl
0409CD 29          0796*       add hl,hl
0409CE ED 52       0797*       sbc hl,de
0409D0 19          0798*       add hl,de
0409D1 EB          0799*       ex de,hl
0409D2 30 04       0800*       jr nc,$+6
0409D4 ED 52       0801*       sbc hl,de
0409D6 13          0802*       inc de
0409D7 13          0803*       inc de
0409D8             0804*   ; Iteration 12
0409D8 17          0805*       rla
0409D9 ED 6A       0806*       adc hl,hl
0409DB 17          0807*       rla
0409DC ED 6A       0808*       adc hl,hl
0409DE EB          0809*       ex de,hl
0409DF 29          0810*       add hl,hl
0409E0 ED 52       0811*       sbc hl,de
0409E2 19          0812*       add hl,de
0409E3 EB          0813*       ex de,hl
0409E4 30 04       0814*       jr nc,$+6
0409E6 ED 52       0815*       sbc hl,de
0409E8 13          0816*       inc de
0409E9 13          0817*       inc de
0409EA CB 1A       0818*       rr d
0409EC CB 1B       0819*       rr e
0409EE C9          0820*       ret
0409EF             0821*   
0409EF             0822*   sin_lut_168:
0409EF 00 00 00    0823*       dl 0x000000 ; 0.000 00, 0.000
0409F2 06 00 00    0824*       dl 0x000006 ; 1.406 01, 0.025
0409F5 0C 00 00    0825*       dl 0x00000C ; 2.813 02, 0.049
0409F8 12 00 00    0826*       dl 0x000012 ; 4.219 03, 0.074
0409FB 19 00 00    0827*       dl 0x000019 ; 5.625 04, 0.098
0409FE 1F 00 00    0828*       dl 0x00001F ; 7.031 05, 0.122
040A01 25 00 00    0829*       dl 0x000025 ; 8.438 06, 0.147
040A04 2B 00 00    0830*       dl 0x00002B ; 9.844 07, 0.171
040A07 31 00 00    0831*       dl 0x000031 ; 11.250 08, 0.195
040A0A 38 00 00    0832*       dl 0x000038 ; 12.656 09, 0.219
040A0D 3E 00 00    0833*       dl 0x00003E ; 14.063 0A, 0.243
040A10 44 00 00    0834*       dl 0x000044 ; 15.469 0B, 0.267
040A13 4A 00 00    0835*       dl 0x00004A ; 16.875 0C, 0.290
040A16 50 00 00    0836*       dl 0x000050 ; 18.281 0D, 0.314
040A19 56 00 00    0837*       dl 0x000056 ; 19.688 0E, 0.337
040A1C 5C 00 00    0838*       dl 0x00005C ; 21.094 0F, 0.360
040A1F 61 00 00    0839*       dl 0x000061 ; 22.500 10, 0.383
040A22 67 00 00    0840*       dl 0x000067 ; 23.906 11, 0.405
040A25 6D 00 00    0841*       dl 0x00006D ; 25.313 12, 0.428
040A28 73 00 00    0842*       dl 0x000073 ; 26.719 13, 0.450
040A2B 78 00 00    0843*       dl 0x000078 ; 28.125 14, 0.471
040A2E 7E 00 00    0844*       dl 0x00007E ; 29.531 15, 0.493
040A31 83 00 00    0845*       dl 0x000083 ; 30.938 16, 0.514
040A34 88 00 00    0846*       dl 0x000088 ; 32.344 17, 0.535
040A37 8E 00 00    0847*       dl 0x00008E ; 33.750 18, 0.556
040A3A 93 00 00    0848*       dl 0x000093 ; 35.156 19, 0.576
040A3D 98 00 00    0849*       dl 0x000098 ; 36.563 1A, 0.596
040A40 9D 00 00    0850*       dl 0x00009D ; 37.969 1B, 0.615
040A43 A2 00 00    0851*       dl 0x0000A2 ; 39.375 1C, 0.634
040A46 A7 00 00    0852*       dl 0x0000A7 ; 40.781 1D, 0.653
040A49 AB 00 00    0853*       dl 0x0000AB ; 42.188 1E, 0.672
040A4C B0 00 00    0854*       dl 0x0000B0 ; 43.594 1F, 0.690
040A4F B5 00 00    0855*       dl 0x0000B5 ; 45.000 20, 0.707
040A52 B9 00 00    0856*       dl 0x0000B9 ; 46.406 21, 0.724
040A55 BD 00 00    0857*       dl 0x0000BD ; 47.813 22, 0.741
040A58 C1 00 00    0858*       dl 0x0000C1 ; 49.219 23, 0.757
040A5B C5 00 00    0859*       dl 0x0000C5 ; 50.625 24, 0.773
040A5E C9 00 00    0860*       dl 0x0000C9 ; 52.031 25, 0.788
040A61 CD 00 00    0861*       dl 0x0000CD ; 53.438 26, 0.803
040A64 D1 00 00    0862*       dl 0x0000D1 ; 54.844 27, 0.818
040A67 D4 00 00    0863*       dl 0x0000D4 ; 56.250 28, 0.831
040A6A D8 00 00    0864*       dl 0x0000D8 ; 57.656 29, 0.845
040A6D DB 00 00    0865*       dl 0x0000DB ; 59.063 2A, 0.858
040A70 DE 00 00    0866*       dl 0x0000DE ; 60.469 2B, 0.870
040A73 E1 00 00    0867*       dl 0x0000E1 ; 61.875 2C, 0.882
040A76 E4 00 00    0868*       dl 0x0000E4 ; 63.281 2D, 0.893
040A79 E7 00 00    0869*       dl 0x0000E7 ; 64.688 2E, 0.904
040A7C EA 00 00    0870*       dl 0x0000EA ; 66.094 2F, 0.914
040A7F EC 00 00    0871*       dl 0x0000EC ; 67.500 30, 0.924
040A82 EE 00 00    0872*       dl 0x0000EE ; 68.906 31, 0.933
040A85 F1 00 00    0873*       dl 0x0000F1 ; 70.313 32, 0.942
040A88 F3 00 00    0874*       dl 0x0000F3 ; 71.719 33, 0.950
040A8B F4 00 00    0875*       dl 0x0000F4 ; 73.125 34, 0.957
040A8E F6 00 00    0876*       dl 0x0000F6 ; 74.531 35, 0.964
040A91 F8 00 00    0877*       dl 0x0000F8 ; 75.938 36, 0.970
040A94 F9 00 00    0878*       dl 0x0000F9 ; 77.344 37, 0.976
040A97 FB 00 00    0879*       dl 0x0000FB ; 78.750 38, 0.981
040A9A FC 00 00    0880*       dl 0x0000FC ; 80.156 39, 0.985
040A9D FD 00 00    0881*       dl 0x0000FD ; 81.563 3A, 0.989
040AA0 FE 00 00    0882*       dl 0x0000FE ; 82.969 3B, 0.992
040AA3 FE 00 00    0883*       dl 0x0000FE ; 84.375 3C, 0.995
040AA6 FF 00 00    0884*       dl 0x0000FF ; 85.781 3D, 0.997
040AA9 FF 00 00    0885*       dl 0x0000FF ; 87.188 3E, 0.999
040AAC FF 00 00    0886*       dl 0x0000FF ; 88.594 3F, 1.000
040AAF 00 01 00    0887*       dl 0x000100 ; 90.000 40, 1.000
040AB2 FF 00 00    0888*       dl 0x0000FF ; 91.406 41, 1.000
040AB5 FF 00 00    0889*       dl 0x0000FF ; 92.813 42, 0.999
040AB8 FF 00 00    0890*       dl 0x0000FF ; 94.219 43, 0.997
040ABB FE 00 00    0891*       dl 0x0000FE ; 95.625 44, 0.995
040ABE FE 00 00    0892*       dl 0x0000FE ; 97.031 45, 0.992
040AC1 FD 00 00    0893*       dl 0x0000FD ; 98.438 46, 0.989
040AC4 FC 00 00    0894*       dl 0x0000FC ; 99.844 47, 0.985
040AC7 FB 00 00    0895*       dl 0x0000FB ; 101.250 48, 0.981
040ACA F9 00 00    0896*       dl 0x0000F9 ; 102.656 49, 0.976
040ACD F8 00 00    0897*       dl 0x0000F8 ; 104.063 4A, 0.970
040AD0 F6 00 00    0898*       dl 0x0000F6 ; 105.469 4B, 0.964
040AD3 F4 00 00    0899*       dl 0x0000F4 ; 106.875 4C, 0.957
040AD6 F3 00 00    0900*       dl 0x0000F3 ; 108.281 4D, 0.950
040AD9 F1 00 00    0901*       dl 0x0000F1 ; 109.688 4E, 0.942
040ADC EE 00 00    0902*       dl 0x0000EE ; 111.094 4F, 0.933
040ADF EC 00 00    0903*       dl 0x0000EC ; 112.500 50, 0.924
040AE2 EA 00 00    0904*       dl 0x0000EA ; 113.906 51, 0.914
040AE5 E7 00 00    0905*       dl 0x0000E7 ; 115.313 52, 0.904
040AE8 E4 00 00    0906*       dl 0x0000E4 ; 116.719 53, 0.893
040AEB E1 00 00    0907*       dl 0x0000E1 ; 118.125 54, 0.882
040AEE DE 00 00    0908*       dl 0x0000DE ; 119.531 55, 0.870
040AF1 DB 00 00    0909*       dl 0x0000DB ; 120.938 56, 0.858
040AF4 D8 00 00    0910*       dl 0x0000D8 ; 122.344 57, 0.845
040AF7 D4 00 00    0911*       dl 0x0000D4 ; 123.750 58, 0.831
040AFA D1 00 00    0912*       dl 0x0000D1 ; 125.156 59, 0.818
040AFD CD 00 00    0913*       dl 0x0000CD ; 126.563 5A, 0.803
040B00 C9 00 00    0914*       dl 0x0000C9 ; 127.969 5B, 0.788
040B03 C5 00 00    0915*       dl 0x0000C5 ; 129.375 5C, 0.773
040B06 C1 00 00    0916*       dl 0x0000C1 ; 130.781 5D, 0.757
040B09 BD 00 00    0917*       dl 0x0000BD ; 132.188 5E, 0.741
040B0C B9 00 00    0918*       dl 0x0000B9 ; 133.594 5F, 0.724
040B0F B5 00 00    0919*       dl 0x0000B5 ; 135.000 60, 0.707
040B12 B0 00 00    0920*       dl 0x0000B0 ; 136.406 61, 0.690
040B15 AB 00 00    0921*       dl 0x0000AB ; 137.813 62, 0.672
040B18 A7 00 00    0922*       dl 0x0000A7 ; 139.219 63, 0.653
040B1B A2 00 00    0923*       dl 0x0000A2 ; 140.625 64, 0.634
040B1E 9D 00 00    0924*       dl 0x00009D ; 142.031 65, 0.615
040B21 98 00 00    0925*       dl 0x000098 ; 143.438 66, 0.596
040B24 93 00 00    0926*       dl 0x000093 ; 144.844 67, 0.576
040B27 8E 00 00    0927*       dl 0x00008E ; 146.250 68, 0.556
040B2A 88 00 00    0928*       dl 0x000088 ; 147.656 69, 0.535
040B2D 83 00 00    0929*       dl 0x000083 ; 149.063 6A, 0.514
040B30 7E 00 00    0930*       dl 0x00007E ; 150.469 6B, 0.493
040B33 78 00 00    0931*       dl 0x000078 ; 151.875 6C, 0.471
040B36 73 00 00    0932*       dl 0x000073 ; 153.281 6D, 0.450
040B39 6D 00 00    0933*       dl 0x00006D ; 154.688 6E, 0.428
040B3C 67 00 00    0934*       dl 0x000067 ; 156.094 6F, 0.405
040B3F 61 00 00    0935*       dl 0x000061 ; 157.500 70, 0.383
040B42 5C 00 00    0936*       dl 0x00005C ; 158.906 71, 0.360
040B45 56 00 00    0937*       dl 0x000056 ; 160.313 72, 0.337
040B48 50 00 00    0938*       dl 0x000050 ; 161.719 73, 0.314
040B4B 4A 00 00    0939*       dl 0x00004A ; 163.125 74, 0.290
040B4E 44 00 00    0940*       dl 0x000044 ; 164.531 75, 0.267
040B51 3E 00 00    0941*       dl 0x00003E ; 165.938 76, 0.243
040B54 38 00 00    0942*       dl 0x000038 ; 167.344 77, 0.219
040B57 31 00 00    0943*       dl 0x000031 ; 168.750 78, 0.195
040B5A 2B 00 00    0944*       dl 0x00002B ; 170.156 79, 0.171
040B5D 25 00 00    0945*       dl 0x000025 ; 171.563 7A, 0.147
040B60 1F 00 00    0946*       dl 0x00001F ; 172.969 7B, 0.122
040B63 19 00 00    0947*       dl 0x000019 ; 174.375 7C, 0.098
040B66 12 00 00    0948*       dl 0x000012 ; 175.781 7D, 0.074
040B69 0C 00 00    0949*       dl 0x00000C ; 177.188 7E, 0.049
040B6C 06 00 00    0950*       dl 0x000006 ; 178.594 7F, 0.025
040B6F 00 00 00    0951*       dl 0x000000 ; 180.000 80, 0.000
040B72 FA FF FF    0952*       dl 0xFFFFFA ; 181.406 81, -0.025
040B75 F4 FF FF    0953*       dl 0xFFFFF4 ; 182.813 82, -0.049
040B78 EE FF FF    0954*       dl 0xFFFFEE ; 184.219 83, -0.074
040B7B E7 FF FF    0955*       dl 0xFFFFE7 ; 185.625 84, -0.098
040B7E E1 FF FF    0956*       dl 0xFFFFE1 ; 187.031 85, -0.122
040B81 DB FF FF    0957*       dl 0xFFFFDB ; 188.438 86, -0.147
040B84 D5 FF FF    0958*       dl 0xFFFFD5 ; 189.844 87, -0.171
040B87 CF FF FF    0959*       dl 0xFFFFCF ; 191.250 88, -0.195
040B8A C8 FF FF    0960*       dl 0xFFFFC8 ; 192.656 89, -0.219
040B8D C2 FF FF    0961*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040B90 BC FF FF    0962*       dl 0xFFFFBC ; 195.469 8B, -0.267
040B93 B6 FF FF    0963*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040B96 B0 FF FF    0964*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040B99 AA FF FF    0965*       dl 0xFFFFAA ; 199.688 8E, -0.337
040B9C A4 FF FF    0966*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040B9F 9F FF FF    0967*       dl 0xFFFF9F ; 202.500 90, -0.383
040BA2 99 FF FF    0968*       dl 0xFFFF99 ; 203.906 91, -0.405
040BA5 93 FF FF    0969*       dl 0xFFFF93 ; 205.313 92, -0.428
040BA8 8D FF FF    0970*       dl 0xFFFF8D ; 206.719 93, -0.450
040BAB 88 FF FF    0971*       dl 0xFFFF88 ; 208.125 94, -0.471
040BAE 82 FF FF    0972*       dl 0xFFFF82 ; 209.531 95, -0.493
040BB1 7D FF FF    0973*       dl 0xFFFF7D ; 210.938 96, -0.514
040BB4 78 FF FF    0974*       dl 0xFFFF78 ; 212.344 97, -0.535
040BB7 72 FF FF    0975*       dl 0xFFFF72 ; 213.750 98, -0.556
040BBA 6D FF FF    0976*       dl 0xFFFF6D ; 215.156 99, -0.576
040BBD 68 FF FF    0977*       dl 0xFFFF68 ; 216.563 9A, -0.596
040BC0 63 FF FF    0978*       dl 0xFFFF63 ; 217.969 9B, -0.615
040BC3 5E FF FF    0979*       dl 0xFFFF5E ; 219.375 9C, -0.634
040BC6 59 FF FF    0980*       dl 0xFFFF59 ; 220.781 9D, -0.653
040BC9 55 FF FF    0981*       dl 0xFFFF55 ; 222.188 9E, -0.672
040BCC 50 FF FF    0982*       dl 0xFFFF50 ; 223.594 9F, -0.690
040BCF 4B FF FF    0983*       dl 0xFFFF4B ; 225.000 A0, -0.707
040BD2 47 FF FF    0984*       dl 0xFFFF47 ; 226.406 A1, -0.724
040BD5 43 FF FF    0985*       dl 0xFFFF43 ; 227.813 A2, -0.741
040BD8 3F FF FF    0986*       dl 0xFFFF3F ; 229.219 A3, -0.757
040BDB 3B FF FF    0987*       dl 0xFFFF3B ; 230.625 A4, -0.773
040BDE 37 FF FF    0988*       dl 0xFFFF37 ; 232.031 A5, -0.788
040BE1 33 FF FF    0989*       dl 0xFFFF33 ; 233.438 A6, -0.803
040BE4 2F FF FF    0990*       dl 0xFFFF2F ; 234.844 A7, -0.818
040BE7 2C FF FF    0991*       dl 0xFFFF2C ; 236.250 A8, -0.831
040BEA 28 FF FF    0992*       dl 0xFFFF28 ; 237.656 A9, -0.845
040BED 25 FF FF    0993*       dl 0xFFFF25 ; 239.063 AA, -0.858
040BF0 22 FF FF    0994*       dl 0xFFFF22 ; 240.469 AB, -0.870
040BF3 1F FF FF    0995*       dl 0xFFFF1F ; 241.875 AC, -0.882
040BF6 1C FF FF    0996*       dl 0xFFFF1C ; 243.281 AD, -0.893
040BF9 19 FF FF    0997*       dl 0xFFFF19 ; 244.688 AE, -0.904
040BFC 16 FF FF    0998*       dl 0xFFFF16 ; 246.094 AF, -0.914
040BFF 14 FF FF    0999*       dl 0xFFFF14 ; 247.500 B0, -0.924
040C02 12 FF FF    1000*       dl 0xFFFF12 ; 248.906 B1, -0.933
040C05 0F FF FF    1001*       dl 0xFFFF0F ; 250.313 B2, -0.942
040C08 0D FF FF    1002*       dl 0xFFFF0D ; 251.719 B3, -0.950
040C0B 0C FF FF    1003*       dl 0xFFFF0C ; 253.125 B4, -0.957
040C0E 0A FF FF    1004*       dl 0xFFFF0A ; 254.531 B5, -0.964
040C11 08 FF FF    1005*       dl 0xFFFF08 ; 255.938 B6, -0.970
040C14 07 FF FF    1006*       dl 0xFFFF07 ; 257.344 B7, -0.976
040C17 05 FF FF    1007*       dl 0xFFFF05 ; 258.750 B8, -0.981
040C1A 04 FF FF    1008*       dl 0xFFFF04 ; 260.156 B9, -0.985
040C1D 03 FF FF    1009*       dl 0xFFFF03 ; 261.563 BA, -0.989
040C20 02 FF FF    1010*       dl 0xFFFF02 ; 262.969 BB, -0.992
040C23 02 FF FF    1011*       dl 0xFFFF02 ; 264.375 BC, -0.995
040C26 01 FF FF    1012*       dl 0xFFFF01 ; 265.781 BD, -0.997
040C29 01 FF FF    1013*       dl 0xFFFF01 ; 267.188 BE, -0.999
040C2C 01 FF FF    1014*       dl 0xFFFF01 ; 268.594 BF, -1.000
040C2F 00 FF FF    1015*       dl 0xFFFF00 ; 270.000 C0, -1.000
040C32 01 FF FF    1016*       dl 0xFFFF01 ; 271.406 C1, -1.000
040C35 01 FF FF    1017*       dl 0xFFFF01 ; 272.813 C2, -0.999
040C38 01 FF FF    1018*       dl 0xFFFF01 ; 274.219 C3, -0.997
040C3B 02 FF FF    1019*       dl 0xFFFF02 ; 275.625 C4, -0.995
040C3E 02 FF FF    1020*       dl 0xFFFF02 ; 277.031 C5, -0.992
040C41 03 FF FF    1021*       dl 0xFFFF03 ; 278.438 C6, -0.989
040C44 04 FF FF    1022*       dl 0xFFFF04 ; 279.844 C7, -0.985
040C47 05 FF FF    1023*       dl 0xFFFF05 ; 281.250 C8, -0.981
040C4A 07 FF FF    1024*       dl 0xFFFF07 ; 282.656 C9, -0.976
040C4D 08 FF FF    1025*       dl 0xFFFF08 ; 284.063 CA, -0.970
040C50 0A FF FF    1026*       dl 0xFFFF0A ; 285.469 CB, -0.964
040C53 0C FF FF    1027*       dl 0xFFFF0C ; 286.875 CC, -0.957
040C56 0D FF FF    1028*       dl 0xFFFF0D ; 288.281 CD, -0.950
040C59 0F FF FF    1029*       dl 0xFFFF0F ; 289.688 CE, -0.942
040C5C 12 FF FF    1030*       dl 0xFFFF12 ; 291.094 CF, -0.933
040C5F 14 FF FF    1031*       dl 0xFFFF14 ; 292.500 D0, -0.924
040C62 16 FF FF    1032*       dl 0xFFFF16 ; 293.906 D1, -0.914
040C65 19 FF FF    1033*       dl 0xFFFF19 ; 295.313 D2, -0.904
040C68 1C FF FF    1034*       dl 0xFFFF1C ; 296.719 D3, -0.893
040C6B 1F FF FF    1035*       dl 0xFFFF1F ; 298.125 D4, -0.882
040C6E 22 FF FF    1036*       dl 0xFFFF22 ; 299.531 D5, -0.870
040C71 25 FF FF    1037*       dl 0xFFFF25 ; 300.938 D6, -0.858
040C74 28 FF FF    1038*       dl 0xFFFF28 ; 302.344 D7, -0.845
040C77 2C FF FF    1039*       dl 0xFFFF2C ; 303.750 D8, -0.831
040C7A 2F FF FF    1040*       dl 0xFFFF2F ; 305.156 D9, -0.818
040C7D 33 FF FF    1041*       dl 0xFFFF33 ; 306.563 DA, -0.803
040C80 37 FF FF    1042*       dl 0xFFFF37 ; 307.969 DB, -0.788
040C83 3B FF FF    1043*       dl 0xFFFF3B ; 309.375 DC, -0.773
040C86 3F FF FF    1044*       dl 0xFFFF3F ; 310.781 DD, -0.757
040C89 43 FF FF    1045*       dl 0xFFFF43 ; 312.188 DE, -0.741
040C8C 47 FF FF    1046*       dl 0xFFFF47 ; 313.594 DF, -0.724
040C8F 4B FF FF    1047*       dl 0xFFFF4B ; 315.000 E0, -0.707
040C92 50 FF FF    1048*       dl 0xFFFF50 ; 316.406 E1, -0.690
040C95 55 FF FF    1049*       dl 0xFFFF55 ; 317.813 E2, -0.672
040C98 59 FF FF    1050*       dl 0xFFFF59 ; 319.219 E3, -0.653
040C9B 5E FF FF    1051*       dl 0xFFFF5E ; 320.625 E4, -0.634
040C9E 63 FF FF    1052*       dl 0xFFFF63 ; 322.031 E5, -0.615
040CA1 68 FF FF    1053*       dl 0xFFFF68 ; 323.438 E6, -0.596
040CA4 6D FF FF    1054*       dl 0xFFFF6D ; 324.844 E7, -0.576
040CA7 72 FF FF    1055*       dl 0xFFFF72 ; 326.250 E8, -0.556
040CAA 78 FF FF    1056*       dl 0xFFFF78 ; 327.656 E9, -0.535
040CAD 7D FF FF    1057*       dl 0xFFFF7D ; 329.063 EA, -0.514
040CB0 82 FF FF    1058*       dl 0xFFFF82 ; 330.469 EB, -0.493
040CB3 88 FF FF    1059*       dl 0xFFFF88 ; 331.875 EC, -0.471
040CB6 8D FF FF    1060*       dl 0xFFFF8D ; 333.281 ED, -0.450
040CB9 93 FF FF    1061*       dl 0xFFFF93 ; 334.688 EE, -0.428
040CBC 99 FF FF    1062*       dl 0xFFFF99 ; 336.094 EF, -0.405
040CBF 9F FF FF    1063*       dl 0xFFFF9F ; 337.500 F0, -0.383
040CC2 A4 FF FF    1064*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040CC5 AA FF FF    1065*       dl 0xFFFFAA ; 340.313 F2, -0.337
040CC8 B0 FF FF    1066*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040CCB B6 FF FF    1067*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040CCE BC FF FF    1068*       dl 0xFFFFBC ; 344.531 F5, -0.267
040CD1 C2 FF FF    1069*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040CD4 C8 FF FF    1070*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040CD7 CF FF FF    1071*       dl 0xFFFFCF ; 348.750 F8, -0.195
040CDA D5 FF FF    1072*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040CDD DB FF FF    1073*       dl 0xFFFFDB ; 351.563 FA, -0.147
040CE0 E1 FF FF    1074*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040CE3 E7 FF FF    1075*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040CE6 EE FF FF    1076*       dl 0xFFFFEE ; 355.781 FD, -0.074
040CE9 F4 FF FF    1077*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040CEC FA FF FF    1078*       dl 0xFFFFFA ; 358.594 FF, -0.025
040CEF 00 00 00    1079*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040CF2             1080*   
040CF2             1081*   atan_lut_168:
040CF2 00 00 00    1082*       dl 0x000000 ; 000000, 0.000
040CF5 28 00 00    1083*       dl 0x000028 ; 000001, 0.224
040CF8 51 00 00    1084*       dl 0x000051 ; 000002, 0.448
040CFB 7A 00 00    1085*       dl 0x00007A ; 000003, 0.671
040CFE A2 00 00    1086*       dl 0x0000A2 ; 000004, 0.895
040D01 CB 00 00    1087*       dl 0x0000CB ; 000005, 1.119
040D04 F4 00 00    1088*       dl 0x0000F4 ; 000006, 1.343
040D07 1D 01 00    1089*       dl 0x00011D ; 000007, 1.566
040D0A 45 01 00    1090*       dl 0x000145 ; 000008, 1.790
040D0D 6E 01 00    1091*       dl 0x00016E ; 000009, 2.013
040D10 97 01 00    1092*       dl 0x000197 ; 00000A, 2.237
040D13 BF 01 00    1093*       dl 0x0001BF ; 00000B, 2.460
040D16 E8 01 00    1094*       dl 0x0001E8 ; 00000C, 2.684
040D19 11 02 00    1095*       dl 0x000211 ; 00000D, 2.907
040D1C 39 02 00    1096*       dl 0x000239 ; 00000E, 3.130
040D1F 62 02 00    1097*       dl 0x000262 ; 00000F, 3.353
040D22 8B 02 00    1098*       dl 0x00028B ; 000010, 3.576
040D25 B3 02 00    1099*       dl 0x0002B3 ; 000011, 3.799
040D28 DC 02 00    1100*       dl 0x0002DC ; 000012, 4.022
040D2B 04 03 00    1101*       dl 0x000304 ; 000013, 4.245
040D2E 2D 03 00    1102*       dl 0x00032D ; 000014, 4.467
040D31 55 03 00    1103*       dl 0x000355 ; 000015, 4.690
040D34 7E 03 00    1104*       dl 0x00037E ; 000016, 4.912
040D37 A6 03 00    1105*       dl 0x0003A6 ; 000017, 5.134
040D3A CE 03 00    1106*       dl 0x0003CE ; 000018, 5.356
040D3D F7 03 00    1107*       dl 0x0003F7 ; 000019, 5.578
040D40 1F 04 00    1108*       dl 0x00041F ; 00001A, 5.799
040D43 48 04 00    1109*       dl 0x000448 ; 00001B, 6.021
040D46 70 04 00    1110*       dl 0x000470 ; 00001C, 6.242
040D49 98 04 00    1111*       dl 0x000498 ; 00001D, 6.463
040D4C C0 04 00    1112*       dl 0x0004C0 ; 00001E, 6.684
040D4F E8 04 00    1113*       dl 0x0004E8 ; 00001F, 6.905
040D52 11 05 00    1114*       dl 0x000511 ; 000020, 7.125
040D55 39 05 00    1115*       dl 0x000539 ; 000021, 7.345
040D58 61 05 00    1116*       dl 0x000561 ; 000022, 7.565
040D5B 89 05 00    1117*       dl 0x000589 ; 000023, 7.785
040D5E B1 05 00    1118*       dl 0x0005B1 ; 000024, 8.005
040D61 D9 05 00    1119*       dl 0x0005D9 ; 000025, 8.224
040D64 01 06 00    1120*       dl 0x000601 ; 000026, 8.443
040D67 28 06 00    1121*       dl 0x000628 ; 000027, 8.662
040D6A 50 06 00    1122*       dl 0x000650 ; 000028, 8.881
040D6D 78 06 00    1123*       dl 0x000678 ; 000029, 9.099
040D70 A0 06 00    1124*       dl 0x0006A0 ; 00002A, 9.317
040D73 C7 06 00    1125*       dl 0x0006C7 ; 00002B, 9.535
040D76 EF 06 00    1126*       dl 0x0006EF ; 00002C, 9.752
040D79 16 07 00    1127*       dl 0x000716 ; 00002D, 9.970
040D7C 3E 07 00    1128*       dl 0x00073E ; 00002E, 10.187
040D7F 65 07 00    1129*       dl 0x000765 ; 00002F, 10.403
040D82 8D 07 00    1130*       dl 0x00078D ; 000030, 10.620
040D85 B4 07 00    1131*       dl 0x0007B4 ; 000031, 10.836
040D88 DB 07 00    1132*       dl 0x0007DB ; 000032, 11.051
040D8B 03 08 00    1133*       dl 0x000803 ; 000033, 11.267
040D8E 2A 08 00    1134*       dl 0x00082A ; 000034, 11.482
040D91 51 08 00    1135*       dl 0x000851 ; 000035, 11.697
040D94 78 08 00    1136*       dl 0x000878 ; 000036, 11.911
040D97 9F 08 00    1137*       dl 0x00089F ; 000037, 12.125
040D9A C6 08 00    1138*       dl 0x0008C6 ; 000038, 12.339
040D9D ED 08 00    1139*       dl 0x0008ED ; 000039, 12.553
040DA0 13 09 00    1140*       dl 0x000913 ; 00003A, 12.766
040DA3 3A 09 00    1141*       dl 0x00093A ; 00003B, 12.978
040DA6 61 09 00    1142*       dl 0x000961 ; 00003C, 13.191
040DA9 87 09 00    1143*       dl 0x000987 ; 00003D, 13.403
040DAC AE 09 00    1144*       dl 0x0009AE ; 00003E, 13.614
040DAF D4 09 00    1145*       dl 0x0009D4 ; 00003F, 13.825
040DB2 FB 09 00    1146*       dl 0x0009FB ; 000040, 14.036
040DB5 21 0A 00    1147*       dl 0x000A21 ; 000041, 14.247
040DB8 47 0A 00    1148*       dl 0x000A47 ; 000042, 14.457
040DBB 6D 0A 00    1149*       dl 0x000A6D ; 000043, 14.666
040DBE 94 0A 00    1150*       dl 0x000A94 ; 000044, 14.876
040DC1 BA 0A 00    1151*       dl 0x000ABA ; 000045, 15.085
040DC4 E0 0A 00    1152*       dl 0x000AE0 ; 000046, 15.293
040DC7 05 0B 00    1153*       dl 0x000B05 ; 000047, 15.501
040DCA 2B 0B 00    1154*       dl 0x000B2B ; 000048, 15.709
040DCD 51 0B 00    1155*       dl 0x000B51 ; 000049, 15.916
040DD0 77 0B 00    1156*       dl 0x000B77 ; 00004A, 16.123
040DD3 9C 0B 00    1157*       dl 0x000B9C ; 00004B, 16.329
040DD6 C2 0B 00    1158*       dl 0x000BC2 ; 00004C, 16.535
040DD9 E7 0B 00    1159*       dl 0x000BE7 ; 00004D, 16.740
040DDC 0C 0C 00    1160*       dl 0x000C0C ; 00004E, 16.945
040DDF 32 0C 00    1161*       dl 0x000C32 ; 00004F, 17.150
040DE2 57 0C 00    1162*       dl 0x000C57 ; 000050, 17.354
040DE5 7C 0C 00    1163*       dl 0x000C7C ; 000051, 17.558
040DE8 A1 0C 00    1164*       dl 0x000CA1 ; 000052, 17.761
040DEB C6 0C 00    1165*       dl 0x000CC6 ; 000053, 17.964
040DEE EB 0C 00    1166*       dl 0x000CEB ; 000054, 18.166
040DF1 0F 0D 00    1167*       dl 0x000D0F ; 000055, 18.368
040DF4 34 0D 00    1168*       dl 0x000D34 ; 000056, 18.569
040DF7 58 0D 00    1169*       dl 0x000D58 ; 000057, 18.770
040DFA 7D 0D 00    1170*       dl 0x000D7D ; 000058, 18.970
040DFD A1 0D 00    1171*       dl 0x000DA1 ; 000059, 19.170
040E00 C6 0D 00    1172*       dl 0x000DC6 ; 00005A, 19.370
040E03 EA 0D 00    1173*       dl 0x000DEA ; 00005B, 19.569
040E06 0E 0E 00    1174*       dl 0x000E0E ; 00005C, 19.767
040E09 32 0E 00    1175*       dl 0x000E32 ; 00005D, 19.965
040E0C 56 0E 00    1176*       dl 0x000E56 ; 00005E, 20.163
040E0F 7A 0E 00    1177*       dl 0x000E7A ; 00005F, 20.360
040E12 9E 0E 00    1178*       dl 0x000E9E ; 000060, 20.556
040E15 C1 0E 00    1179*       dl 0x000EC1 ; 000061, 20.752
040E18 E5 0E 00    1180*       dl 0x000EE5 ; 000062, 20.947
040E1B 08 0F 00    1181*       dl 0x000F08 ; 000063, 21.142
040E1E 2C 0F 00    1182*       dl 0x000F2C ; 000064, 21.337
040E21 4F 0F 00    1183*       dl 0x000F4F ; 000065, 21.531
040E24 72 0F 00    1184*       dl 0x000F72 ; 000066, 21.724
040E27 95 0F 00    1185*       dl 0x000F95 ; 000067, 21.917
040E2A B8 0F 00    1186*       dl 0x000FB8 ; 000068, 22.109
040E2D DB 0F 00    1187*       dl 0x000FDB ; 000069, 22.301
040E30 FE 0F 00    1188*       dl 0x000FFE ; 00006A, 22.493
040E33 21 10 00    1189*       dl 0x001021 ; 00006B, 22.683
040E36 44 10 00    1190*       dl 0x001044 ; 00006C, 22.874
040E39 66 10 00    1191*       dl 0x001066 ; 00006D, 23.063
040E3C 89 10 00    1192*       dl 0x001089 ; 00006E, 23.253
040E3F AB 10 00    1193*       dl 0x0010AB ; 00006F, 23.441
040E42 CD 10 00    1194*       dl 0x0010CD ; 000070, 23.629
040E45 EF 10 00    1195*       dl 0x0010EF ; 000071, 23.817
040E48 11 11 00    1196*       dl 0x001111 ; 000072, 24.004
040E4B 33 11 00    1197*       dl 0x001133 ; 000073, 24.191
040E4E 55 11 00    1198*       dl 0x001155 ; 000074, 24.376
040E51 77 11 00    1199*       dl 0x001177 ; 000075, 24.562
040E54 99 11 00    1200*       dl 0x001199 ; 000076, 24.747
040E57 BA 11 00    1201*       dl 0x0011BA ; 000077, 24.931
040E5A DC 11 00    1202*       dl 0x0011DC ; 000078, 25.115
040E5D FD 11 00    1203*       dl 0x0011FD ; 000079, 25.298
040E60 1E 12 00    1204*       dl 0x00121E ; 00007A, 25.481
040E63 3F 12 00    1205*       dl 0x00123F ; 00007B, 25.663
040E66 60 12 00    1206*       dl 0x001260 ; 00007C, 25.844
040E69 81 12 00    1207*       dl 0x001281 ; 00007D, 26.025
040E6C A2 12 00    1208*       dl 0x0012A2 ; 00007E, 26.206
040E6F C3 12 00    1209*       dl 0x0012C3 ; 00007F, 26.386
040E72 E4 12 00    1210*       dl 0x0012E4 ; 000080, 26.565
040E75 04 13 00    1211*       dl 0x001304 ; 000081, 26.744
040E78 25 13 00    1212*       dl 0x001325 ; 000082, 26.922
040E7B 45 13 00    1213*       dl 0x001345 ; 000083, 27.100
040E7E 65 13 00    1214*       dl 0x001365 ; 000084, 27.277
040E81 85 13 00    1215*       dl 0x001385 ; 000085, 27.453
040E84 A5 13 00    1216*       dl 0x0013A5 ; 000086, 27.629
040E87 C5 13 00    1217*       dl 0x0013C5 ; 000087, 27.805
040E8A E5 13 00    1218*       dl 0x0013E5 ; 000088, 27.979
040E8D 05 14 00    1219*       dl 0x001405 ; 000089, 28.154
040E90 24 14 00    1220*       dl 0x001424 ; 00008A, 28.327
040E93 44 14 00    1221*       dl 0x001444 ; 00008B, 28.501
040E96 63 14 00    1222*       dl 0x001463 ; 00008C, 28.673
040E99 83 14 00    1223*       dl 0x001483 ; 00008D, 28.845
040E9C A2 14 00    1224*       dl 0x0014A2 ; 00008E, 29.017
040E9F C1 14 00    1225*       dl 0x0014C1 ; 00008F, 29.187
040EA2 E0 14 00    1226*       dl 0x0014E0 ; 000090, 29.358
040EA5 FF 14 00    1227*       dl 0x0014FF ; 000091, 29.527
040EA8 1E 15 00    1228*       dl 0x00151E ; 000092, 29.697
040EAB 3C 15 00    1229*       dl 0x00153C ; 000093, 29.865
040EAE 5B 15 00    1230*       dl 0x00155B ; 000094, 30.033
040EB1 79 15 00    1231*       dl 0x001579 ; 000095, 30.201
040EB4 98 15 00    1232*       dl 0x001598 ; 000096, 30.368
040EB7 B6 15 00    1233*       dl 0x0015B6 ; 000097, 30.534
040EBA D4 15 00    1234*       dl 0x0015D4 ; 000098, 30.700
040EBD F2 15 00    1235*       dl 0x0015F2 ; 000099, 30.865
040EC0 10 16 00    1236*       dl 0x001610 ; 00009A, 31.030
040EC3 2E 16 00    1237*       dl 0x00162E ; 00009B, 31.194
040EC6 4C 16 00    1238*       dl 0x00164C ; 00009C, 31.357
040EC9 6A 16 00    1239*       dl 0x00166A ; 00009D, 31.520
040ECC 87 16 00    1240*       dl 0x001687 ; 00009E, 31.682
040ECF A5 16 00    1241*       dl 0x0016A5 ; 00009F, 31.844
040ED2 C2 16 00    1242*       dl 0x0016C2 ; 0000A0, 32.005
040ED5 DF 16 00    1243*       dl 0x0016DF ; 0000A1, 32.166
040ED8 FC 16 00    1244*       dl 0x0016FC ; 0000A2, 32.326
040EDB 19 17 00    1245*       dl 0x001719 ; 0000A3, 32.486
040EDE 36 17 00    1246*       dl 0x001736 ; 0000A4, 32.645
040EE1 53 17 00    1247*       dl 0x001753 ; 0000A5, 32.803
040EE4 70 17 00    1248*       dl 0x001770 ; 0000A6, 32.961
040EE7 8C 17 00    1249*       dl 0x00178C ; 0000A7, 33.118
040EEA A9 17 00    1250*       dl 0x0017A9 ; 0000A8, 33.275
040EED C5 17 00    1251*       dl 0x0017C5 ; 0000A9, 33.431
040EF0 E2 17 00    1252*       dl 0x0017E2 ; 0000AA, 33.587
040EF3 FE 17 00    1253*       dl 0x0017FE ; 0000AB, 33.742
040EF6 1A 18 00    1254*       dl 0x00181A ; 0000AC, 33.896
040EF9 36 18 00    1255*       dl 0x001836 ; 0000AD, 34.050
040EFC 52 18 00    1256*       dl 0x001852 ; 0000AE, 34.203
040EFF 6E 18 00    1257*       dl 0x00186E ; 0000AF, 34.356
040F02 8A 18 00    1258*       dl 0x00188A ; 0000B0, 34.509
040F05 A5 18 00    1259*       dl 0x0018A5 ; 0000B1, 34.660
040F08 C1 18 00    1260*       dl 0x0018C1 ; 0000B2, 34.811
040F0B DC 18 00    1261*       dl 0x0018DC ; 0000B3, 34.962
040F0E F7 18 00    1262*       dl 0x0018F7 ; 0000B4, 35.112
040F11 13 19 00    1263*       dl 0x001913 ; 0000B5, 35.262
040F14 2E 19 00    1264*       dl 0x00192E ; 0000B6, 35.410
040F17 49 19 00    1265*       dl 0x001949 ; 0000B7, 35.559
040F1A 64 19 00    1266*       dl 0x001964 ; 0000B8, 35.707
040F1D 7F 19 00    1267*       dl 0x00197F ; 0000B9, 35.854
040F20 99 19 00    1268*       dl 0x001999 ; 0000BA, 36.001
040F23 B4 19 00    1269*       dl 0x0019B4 ; 0000BB, 36.147
040F26 CE 19 00    1270*       dl 0x0019CE ; 0000BC, 36.293
040F29 E9 19 00    1271*       dl 0x0019E9 ; 0000BD, 36.438
040F2C 03 1A 00    1272*       dl 0x001A03 ; 0000BE, 36.582
040F2F 1D 1A 00    1273*       dl 0x001A1D ; 0000BF, 36.726
040F32 37 1A 00    1274*       dl 0x001A37 ; 0000C0, 36.870
040F35 51 1A 00    1275*       dl 0x001A51 ; 0000C1, 37.013
040F38 6B 1A 00    1276*       dl 0x001A6B ; 0000C2, 37.155
040F3B 85 1A 00    1277*       dl 0x001A85 ; 0000C3, 37.297
040F3E 9F 1A 00    1278*       dl 0x001A9F ; 0000C4, 37.439
040F41 B9 1A 00    1279*       dl 0x001AB9 ; 0000C5, 37.579
040F44 D2 1A 00    1280*       dl 0x001AD2 ; 0000C6, 37.720
040F47 EC 1A 00    1281*       dl 0x001AEC ; 0000C7, 37.859
040F4A 05 1B 00    1282*       dl 0x001B05 ; 0000C8, 37.999
040F4D 1E 1B 00    1283*       dl 0x001B1E ; 0000C9, 38.137
040F50 37 1B 00    1284*       dl 0x001B37 ; 0000CA, 38.276
040F53 50 1B 00    1285*       dl 0x001B50 ; 0000CB, 38.413
040F56 69 1B 00    1286*       dl 0x001B69 ; 0000CC, 38.550
040F59 82 1B 00    1287*       dl 0x001B82 ; 0000CD, 38.687
040F5C 9B 1B 00    1288*       dl 0x001B9B ; 0000CE, 38.823
040F5F B4 1B 00    1289*       dl 0x001BB4 ; 0000CF, 38.959
040F62 CC 1B 00    1290*       dl 0x001BCC ; 0000D0, 39.094
040F65 E5 1B 00    1291*       dl 0x001BE5 ; 0000D1, 39.228
040F68 FD 1B 00    1292*       dl 0x001BFD ; 0000D2, 39.362
040F6B 16 1C 00    1293*       dl 0x001C16 ; 0000D3, 39.496
040F6E 2E 1C 00    1294*       dl 0x001C2E ; 0000D4, 39.629
040F71 46 1C 00    1295*       dl 0x001C46 ; 0000D5, 39.762
040F74 5E 1C 00    1296*       dl 0x001C5E ; 0000D6, 39.894
040F77 76 1C 00    1297*       dl 0x001C76 ; 0000D7, 40.025
040F7A 8E 1C 00    1298*       dl 0x001C8E ; 0000D8, 40.156
040F7D A5 1C 00    1299*       dl 0x001CA5 ; 0000D9, 40.286
040F80 BD 1C 00    1300*       dl 0x001CBD ; 0000DA, 40.416
040F83 D5 1C 00    1301*       dl 0x001CD5 ; 0000DB, 40.546
040F86 EC 1C 00    1302*       dl 0x001CEC ; 0000DC, 40.675
040F89 04 1D 00    1303*       dl 0x001D04 ; 0000DD, 40.803
040F8C 1B 1D 00    1304*       dl 0x001D1B ; 0000DE, 40.931
040F8F 32 1D 00    1305*       dl 0x001D32 ; 0000DF, 41.059
040F92 49 1D 00    1306*       dl 0x001D49 ; 0000E0, 41.186
040F95 60 1D 00    1307*       dl 0x001D60 ; 0000E1, 41.312
040F98 77 1D 00    1308*       dl 0x001D77 ; 0000E2, 41.438
040F9B 8E 1D 00    1309*       dl 0x001D8E ; 0000E3, 41.564
040F9E A5 1D 00    1310*       dl 0x001DA5 ; 0000E4, 41.689
040FA1 BB 1D 00    1311*       dl 0x001DBB ; 0000E5, 41.814
040FA4 D2 1D 00    1312*       dl 0x001DD2 ; 0000E6, 41.938
040FA7 E9 1D 00    1313*       dl 0x001DE9 ; 0000E7, 42.061
040FAA FF 1D 00    1314*       dl 0x001DFF ; 0000E8, 42.184
040FAD 15 1E 00    1315*       dl 0x001E15 ; 0000E9, 42.307
040FB0 2C 1E 00    1316*       dl 0x001E2C ; 0000EA, 42.429
040FB3 42 1E 00    1317*       dl 0x001E42 ; 0000EB, 42.551
040FB6 58 1E 00    1318*       dl 0x001E58 ; 0000EC, 42.672
040FB9 6E 1E 00    1319*       dl 0x001E6E ; 0000ED, 42.793
040FBC 84 1E 00    1320*       dl 0x001E84 ; 0000EE, 42.913
040FBF 99 1E 00    1321*       dl 0x001E99 ; 0000EF, 43.033
040FC2 AF 1E 00    1322*       dl 0x001EAF ; 0000F0, 43.152
040FC5 C5 1E 00    1323*       dl 0x001EC5 ; 0000F1, 43.271
040FC8 DA 1E 00    1324*       dl 0x001EDA ; 0000F2, 43.390
040FCB F0 1E 00    1325*       dl 0x001EF0 ; 0000F3, 43.508
040FCE 05 1F 00    1326*       dl 0x001F05 ; 0000F4, 43.625
040FD1 1B 1F 00    1327*       dl 0x001F1B ; 0000F5, 43.742
040FD4 30 1F 00    1328*       dl 0x001F30 ; 0000F6, 43.859
040FD7 45 1F 00    1329*       dl 0x001F45 ; 0000F7, 43.975
040FDA 5A 1F 00    1330*       dl 0x001F5A ; 0000F8, 44.091
040FDD 6F 1F 00    1331*       dl 0x001F6F ; 0000F9, 44.206
040FE0 84 1F 00    1332*       dl 0x001F84 ; 0000FA, 44.321
040FE3 99 1F 00    1333*       dl 0x001F99 ; 0000FB, 44.435
040FE6 AD 1F 00    1334*       dl 0x001FAD ; 0000FC, 44.549
040FE9 C2 1F 00    1335*       dl 0x001FC2 ; 0000FD, 44.662
040FEC D7 1F 00    1336*       dl 0x001FD7 ; 0000FE, 44.775
040FEF EB 1F 00    1337*       dl 0x001FEB ; 0000FF, 44.888
040FF2 00 20 00    1338*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
040FF5             0033        include "../include/maths.inc"
040FF5             0001*   ;------------------------------------------------------------------------
040FF5             0002*   ; Scratch area for calculations
040FF5             0003*   ;------------------------------------------------------------------------
040FF5 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
040FF8 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
040FFB             0006*   
040FFB             0007*   ; absolute value of hlu
040FFB             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040FFB             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040FFB             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040FFB             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040FFB             0012*   ; destroys: a
040FFB             0013*   hlu_abs:
040FFB 19          0014*       add hl,de
040FFC B7          0015*       or a
040FFD ED 52       0016*       sbc hl,de
040FFF FA 04 10 04 0017*       jp m,@is_neg
041003 C9          0018*       ret ; hlu is positive or zero so we're done
041004             0019*   @is_neg:
041004 F5          0020*       push af ; otherwise, save current flags for return
041005 CD 0B 10 04 0021*       call neg_hlu ; negate hlu
041009 F1          0022*       pop af ; get back flags
04100A C9          0023*       ret
04100B             0024*   
04100B             0025*   ; flip the sign of hlu
04100B             0026*   ; inputs: hlu
04100B             0027*   ; returns: 0-hlu, flags set appropriately for the result:
04100B             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
04100B             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
04100B             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
04100B             0031*   ; destroys a
04100B             0032*   neg_hlu:
04100B D5          0033*       push de ; save de
04100C EB          0034*       ex de,hl ; put hl into de
04100D 21 00 00 00 0035*       ld hl,0 ; clear hl
041011 AF          0036*       xor a ; clear carry
041012 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
041014 D1          0038*       pop de ; get de back
041015 C9          0039*       ret ; easy peasy
041016             0040*   
041016             0041*   ;------------------------------------------------------------------------
041016             0042*   ; divide hlu by 2, inspired by above
041016             0043*   ;------------------------------------------------------------------------
041016             0044*   hlu_div2:
041016 22 F5 0F 04 0045*       ld (scratch1),hl
04101A 21 F7 0F 04 0046*       ld hl,scratch1+2
04101E CB 1E       0047*       rr (hl)
041020 2B          0048*       dec hl
041021 CB 1E       0049*       rr (hl)
041023 2B          0050*       dec hl
041024 CB 1E       0051*       rr (hl)
041026 23          0052*       inc hl
041027 23          0053*       inc hl
041028 2A F5 0F 04 0054*       ld hl,(scratch1)
04102C C9          0055*       ret
04102D             0056*   
04102D             0057*   ; this is my little hack to divide by 16
04102D             0058*   hlu_div16:
04102D AF          0059*       xor a
04102E 29          0060*       add hl,hl
04102F 17          0061*       rla
041030 29          0062*       add hl,hl
041031 17          0063*       rla
041032 29          0064*       add hl,hl
041033 17          0065*       rla
041034 29          0066*       add hl,hl
041035 17          0067*       rla
041036 22 43 10 04 0068*       ld (@scratch),hl
04103A 32 46 10 04 0069*       ld (@scratch+3),a
04103E 2A 44 10 04 0070*       ld hl,(@scratch+1)
041042 C9          0071*       ret
041043             0072*   @scratch: ds 4
041047             0073*   
041047             0074*   ; hlu signed division by 256
041047             0075*   ; returns: hlu / 256
041047             0076*   ; destroys: af
041047             0077*   hlu_sdiv256:
       FF FF FF FF 
041047 AF          0078*       xor a ; assume hl is positive
041048 22 5E 10 04 0079*       ld (@buffer),hl
04104C             0080*       SIGN_HLU
                       M1 Args: none
04104C 19          0001*M1     add hl,de ; 1 cycle
04104D B7          0002*M1     or a ; clear flags ; 1 cycle
04104E ED 52       0003*M1     sbc hl,de ; 2 cycles
041050             0004*M1     ; 4 cycles total
041050 F2 55 10 04 0081*       jp p,@hl_pos
041054 3D          0082*       dec a
041055             0083*   @hl_pos:
041055 32 61 10 04 0084*       ld (@buffer+3),a
041059 2A 5F 10 04 0085*       ld hl,(@buffer+1)
04105D C9          0086*       ret
04105E             0087*   @buffer: ds 4
041062             0088*   
041062             0089*   ; hlu 1 byte right shift, unsigned
041062             0090*   ; returns: hlu / 256, fractional portion in a
041062             0091*   ; destroys: af
041062             0092*   hlu_udiv256:
       FF FF FF FF 
041062 AF          0093*       xor a
041063 32 74 10 04 0094*       ld (@buffer+3),a
041067 7D          0095*       ld a,l ; save the fractional portion
041068 22 71 10 04 0096*       ld (@buffer),hl
04106C 2A 72 10 04 0097*       ld hl,(@buffer+1)
041070 C9          0098*       ret
041071             0099*   @buffer: ds 4
041075             0100*   
041075             0101*   ; floor(value,n)
041075             0102*   ; inputs: hl = value to floor, de = n
041075             0103*   ; outputs: hl = value floored to n
041075             0104*   ; destroys: af, hl, bc, de
041075             0105*   hlu_floor:
       FF FF FF FF 
041075 D5          0106*       push de ; save n
041076 CD 92 04 04 0107*       call udiv24 ; de = quotient, hl = remainder
04107A E1          0108*       pop hl ; get n back (was de)
04107B CD 79 04 04 0109*       call umul24 ; hl = n * quotient
04107F C9          0110*       ret
041080             0111*   ; end hlu_floor
041080             0112*   
041080             0113*   ; ceil(value,n)
041080             0114*   ; inputs: hl = value to ceil, de = n
041080             0115*   ; outputs: hl = value ceiled to n
041080             0116*   ; destroys: af, hl, bc, de
041080             0117*   hlu_ceiling:
041080 D5          0118*       push de ; save n
041081 CD 92 04 04 0119*       call udiv24 ; de = quotient, hl = remainder
041085             0120*       SIGN_HLU ; test remaider for zero
                       M1 Args: none
041085 19          0001*M1     add hl,de ; 1 cycle
041086 B7          0002*M1     or a ; clear flags ; 1 cycle
041087 ED 52       0003*M1     sbc hl,de ; 2 cycles
041089             0004*M1     ; 4 cycles total
041089 CA 8E 10 04 0121*       jp z,@F ; if zero, nothing to add
04108D 13          0122*       inc de ; add 1 to quotient for the ceiling
04108E             0123*   @@:
04108E E1          0124*       pop hl ; get n back (was de)
04108F CD 79 04 04 0125*       call umul24 ; hl = n * quotient
041093 C9          0126*       ret
041094             0127*   ; end hlu_ceiling
041094             0128*   
041094 C9          0129*       ret
041095             0130*   
041095 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
041099 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
04109D             0133*   
04109D             0134*   ; set bcd values in a scratch memory address from registers bcde
04109D             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
04109D             0136*   ; destroys ; hl
04109D             0137*   set_bcd:
04109D 73          0138*       ld (hl),e
04109E 23          0139*       inc hl
04109F 72          0140*       ld (hl),d
0410A0 23          0141*       inc hl
0410A1 71          0142*       ld (hl),c
0410A2 23          0143*       inc hl
0410A3 70          0144*       ld (hl),b
0410A4 C9          0145*       ret
0410A5             0146*   
0410A5             0147*   ; load bcd values from a scratch memory address to bcde
0410A5             0148*   ; input: hl; scratch address
0410A5             0149*   ; output: bcde; 8-place bcd number
0410A5             0150*   ; destroys: hl
0410A5             0151*   get_bcd:
0410A5 5E          0152*       ld e,(hl)
0410A6 23          0153*       inc hl
0410A7 56          0154*       ld d,(hl)
0410A8 23          0155*       inc hl
0410A9 4E          0156*       ld c,(hl)
0410AA 23          0157*       inc hl
0410AB 46          0158*       ld b,(hl)
0410AC C9          0159*       ret
0410AD             0160*   
0410AD             0161*   ; BCD addition
0410AD             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0410AD             0163*   ;       a is the number of bytes holding each number (number of places/2)
0410AD             0164*   ; outputs: (hl) + (de) --> (hl)
0410AD             0165*   ; destroys: a,b,de,hl
0410AD             0166*   add_bcd:
0410AD 47          0167*       ld b,a ; loop counter
0410AE AF          0168*       xor a ; reset a, clear carry flag
0410AF             0169*   adcec:
0410AF 1A          0170*       ld a,(de) ; addend to acc
0410B0 8E          0171*       adc a,(hl) ; add (hl) to acc
0410B1 27          0172*       daa ; adjust result to bcd
0410B2 77          0173*       ld (hl),a ; store result
0410B3 23          0174*       inc hl ; advance memory pointers
0410B4 13          0175*       inc de
0410B5 10 F8       0176*       djnz adcec ; loop until b == 0
0410B7 C9          0177*       ret
0410B8             0178*   
0410B8             0179*   ; BCD subtraction
0410B8             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0410B8             0181*   ;       a is the number of bytes holding each number (number of places/2)
0410B8             0182*   ; outputs: (hl) - (de) --> (hl)
0410B8             0183*   ; destroys: a,b,de,hl
0410B8             0184*   sub_bcd:
0410B8 47          0185*       ld b,a ; loop counter
0410B9 AF          0186*       xor a ; reset a,clear carry flag
0410BA             0187*   subdec:
0410BA 1A          0188*       ld a,(de) ; subtrahend to acc
0410BB 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
0410BC 27          0190*       daa ; adjust result to bcd
0410BD 77          0191*       ld (hl),a ; store result
0410BE 23          0192*       inc hl ; advance memory pointers
0410BF 13          0193*       inc de
0410C0 10 F8       0194*       djnz subdec ; loop until b == 0
0410C2 C9          0195*       ret
0410C3             0196*   
0410C3             0197*   ; http://www.z80.info/pseudo-random.txt
0410C3             0198*   rand_8:
0410C3 C5          0199*       push bc
0410C4 3A D7 10 04 0200*       ld a,(r_seed)
0410C8 4F          0201*       ld c,a
0410C9             0202*   
0410C9 0F          0203*       rrca ; multiply by 32
0410CA 0F          0204*       rrca
0410CB 0F          0205*       rrca
0410CC EE 1F       0206*       xor 0x1f
0410CE             0207*   
0410CE 81          0208*       add a,c
0410CF DE FF       0209*       sbc a,255 ; carry
0410D1             0210*   
0410D1 32 D7 10 04 0211*       ld (r_seed),a
0410D5 C1          0212*       pop bc
0410D6 C9          0213*       ret
0410D7 50          0214*   r_seed: defb $50
0410D8             0215*   
0410D8             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
0410D8             0217*   prng24:
0410D8             0218*   ;;Expects ADL mode.
0410D8             0219*   ;;Output: HL
0410D8             0220*   ;;50cc
0410D8             0221*   ;;33 bytes
0410D8             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
0410D8 ED 5B F9 10 0223*       ld de,(seed1)
       04          
0410DD B7          0224*       or a
0410DE ED 62       0225*       sbc hl,hl
0410E0 19          0226*       add hl,de
0410E1 29          0227*       add hl,hl
0410E2 29          0228*       add hl,hl
0410E3 2C          0229*       inc l
0410E4 19          0230*       add hl,de
0410E5 22 F9 10 04 0231*       ld (seed1),hl
0410E9 2A FC 10 04 0232*       ld hl,(seed2)
0410ED 29          0233*       add hl,hl
0410EE 9F          0234*       sbc a,a
0410EF E6 1B       0235*       and %00011011
0410F1 AD          0236*       xor l
0410F2 6F          0237*       ld l,a
0410F3 22 FC 10 04 0238*       ld (seed2),hl
0410F7 19          0239*       add hl,de
0410F8 C9          0240*       ret
0410F9 00 00 00    0241*   seed1: dl 0
0410FC 00 00 00    0242*   seed2: dl 0
0410FF             0243*   
0410FF             0244*   
0410FF             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
0410FF             0246*   ; h / l -> h, remain a
0410FF             0247*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
0410FF             0248*   ; Input: H = Dividend, L = Divisor, A = 0
0410FF             0249*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
0410FF             0250*   udiv8:
0410FF AF          0251*       xor a
041100 06 08       0252*       ld b,8
041102             0253*   @loop:
041102 CB 24       0254*       sla h
041104 17          0255*       rla
041105 BD          0256*       cp l
041106 38 02       0257*       jr c,$+4
041108 95          0258*       sub l
041109 24          0259*       inc h
04110A 10 F6       0260*       djnz @loop
04110C C9          0261*       ret
04110D             0262*   
04110D             0263*   ; https://www.omnimaga.org/asm-language/(z80)-32-bit-by-16-bits-division-and-32-bit-square-root/msg406903/#msg406903
04110D             0264*   ; This divides HLIX by BC
04110D             0265*   ; The result is stored in HLIX, the remainder in DE
04110D             0266*   ; BC is unmodified
04110D             0267*   ; A is 0
04110D             0268*   udiv3216:
04110D 11 00 00 00 0269*       ld de,0		; 10
041111 3E 20       0270*       ld a,32		; 7
041113             0271*   @loop:
041113 52 DD 29    0272*       add.s ix,ix		; 15
041116 52 ED 6A    0273*       adc.s hl,hl		; 15
041119 EB          0274*       ex de,hl		; 4
04111A 52 ED 6A    0275*       adc.s hl,hl		; 15
04111D B7          0276*       or a			; 4
04111E 52 ED 42    0277*       sbc.s hl,bc		; 15
041121 52 DD 23    0278*       inc.s ix		; 10
041124 30 05       0279*       jr nc,@cansub		; 12/7
041126 52 09       0280*       add.s hl,bc		; 11
041128 52 DD 2B    0281*       dec.s ix		; 10
04112B             0282*   @cansub:
04112B EB          0283*       ex de,hl		; 4
04112C 3D          0284*       dec a		; 4
04112D 20 E4       0285*       jr nz,@loop	; 12/7
04112F C9          0286*       ret			; 10
041130             0287*   ; end udiv3216
041130             0288*   
041130             0289*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1329274504022720512
041130             0290*   ; calc84maniac's 32-bit by 23-bit division routine
041130             0291*   ; This divides AUIX by UDE (maximum 23 bits)
041130             0292*   ; The result is stored in AUIX, the remainder in UHL
041130             0293*   ; UDE, C are unmodified
041130             0294*   ; B is 0
041130             0295*   udiv3223:
041130 B7          0296*       or a,a         ; 1
041131 ED 62       0297*       sbc hl,hl      ; 2
041133 06 20       0298*       ld b,32        ; 2
041135             0299*   @loop:
041135 DD 29       0300*       add ix,ix      ; 2
041137 8F          0301*       adc a,a        ; 1
041138 ED 6A       0302*       adc hl,hl      ; 2
04113A ED 52       0303*       sbc hl,de      ; 2
04113C DD 23       0304*       inc ix         ; 2
04113E 30 03       0305*       jr nc,@cansub  ; 2/4
041140 19          0306*       add hl,de      ; 1
041141 DD 2B       0307*       dec ix         ; 2
041143             0308*   @cansub:
041143 10 F0       0309*       djnz @loop     ; 2/4
041145 C9          0310*       ret            ; 10
041146             0311*   ; end udiv3223
041146             0312*   
041146             0313*   ; calc84maniac https://discord.com/channels/1158535358624039014/1282290921815408681/1330991583369101322
041146             0314*   ; add uhl to signed integer a
041146             0315*   add_uhl_a_signed:
041146 D5          0316*       push de    ; 4 cycles
041147 EB          0317*       ex de, hl  ; 1 cycle  UDE = UHL
041148 07          0318*       rlca       ; 1 cycle  CF = signbit(A)
041149 ED 62       0319*       sbc hl, hl ; 2 cycles UHL = -signbit(A)
04114B 0F          0320*       rrca       ; 1 cycle  Restore A
04114C 6F          0321*       ld l, a    ; 1 cycle  UHL = signext(A)
04114D 19          0322*       add hl, de ; 1 cycle  UHL = UDE + signext(A)
04114E D1          0323*       pop de     ; 4 cycles
04114F             0324*                  ; 15 cycles total
04114F C9          0325*       ret
041150             0326*   ; end hlu_add_a_signed
041150             0034        include "../include/timer.inc"
041150             0001*   ; Table 32. Timer Control Registers
041150             0002*   TMR0_CTL: equ 80h
041150             0003*   TMR1_CTL: equ 83h
041150             0004*   TMR2_CTL: equ 86h
041150             0005*   TMR3_CTL: equ 89h
041150             0006*   TMR4_CTL: equ 8Ch
041150             0007*   TMR5_CTL: equ 8Fh
041150             0008*   
041150             0009*   ; each timer register takes three bytes:
041150             0010*   ;   0: control register
041150             0011*   ;   1: low byte of timer reset value
041150             0012*   ;   2: high byte of timer reset value
041150             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041150             0014*   ; which correctly force the high and upper bytes of the address bus to zero
041150             0015*   
041150             0016*   TMR_REG_CTL: equ 0
041150             0017*   TMR_RES_LOW: equ 1
041150             0018*   TMR_RES_HIGH: equ 2
041150             0019*   
041150             0020*   ; Timer Control Register Bit Definitions
041150             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041150             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
041150             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041150             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
041150             0025*                               ; the TMRx_CTL register is read.
041150             0026*   
041150             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041150             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041150             0029*   
041150             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041150             0031*                               ;  0,and counting stops when the end-of-count value is reached.
041150             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041150             0033*                               ; written to the counter when the end-of-count value is reached.
041150             0034*   
041150             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041150             0036*   CLK_DIV_256:  equ %00001100 ;
041150             0037*   CLK_DIV_64:   equ %00001000 ;
041150             0038*   CLK_DIV_16:   equ %00000100 ;
041150             0039*   CLK_DIV_4:    equ %00000000 ;
041150             0040*   
041150             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041150             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041150             0043*                               ; When a 1 is written to this bit,the values in the reload registers
041150             0044*                               ;  are loaded into the downcounter when the timer restarts. The
041150             0045*                               ; programmer must ensure that this bit is set to 1 each time
041150             0046*                               ; SINGLE-PASS mode is used.
041150             0047*   
041150             0048*   ; disable/enable the programmable reload timer
041150             0049*   PRT_EN_0:     equ %00000000 ;
041150             0050*   PRT_EN_1:     equ %00000001 ;
041150             0051*   
041150             0052*   ; Table 37. Timer Input Source Select Register
041150             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
041150             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041150             0055*   ;   00: System clock / CLK_DIV
041150             0056*   ;   01: RTC / CLK_DIV
041150             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
041150             0058*   ;   10: GPIO port B pin 1.
041150             0059*   ;   11: GPIO port B pin 1.
041150             0060*   TMR_ISS:   equ 92h ; register address
041150             0061*   
041150             0062*   ; Table 51. Real-Time Clock Control Register
041150             0063*   RTC_CTRL: equ EDh ; register address
041150             0064*   
041150             0065*   ; alarm interrupt disable/enable
041150             0066*   RTC_ALARM_0:    equ %00000000
041150             0067*   RTC_ALARM_1:    equ %10000000
041150             0068*   
041150             0069*   ; interrupt on alarm disable/enable
041150             0070*   RTC_INT_ENT_0:  equ %00000000
041150             0071*   RTC_INT_ENT_1:  equ %01000000
041150             0072*   
041150             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041150             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041150             0075*   
041150             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041150             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
041150             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041150             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
041150             0080*   
041150             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041150             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041150             0083*   
041150             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041150             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041150             0086*   
041150             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041150             0088*                                   ; RTC counter is enabled.
041150             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041150             0090*                                   ; RTC counter is disabled.
041150             0091*   
041150             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041150             0093*   
041150             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041150             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041150 00 00 00    0096*   prt_reload: dl 0x000000
041153             0097*   
041153             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
041153             0099*   ;          de = number PRT interrupts during test interval
041153             0100*   prt_calibrate:
041153 CD 62 14 04 0101*       call vdu_vblank
041157             0102*   ; set a MOS timer
041157 21 78 00 00 0103*       ld hl,120*1 ; 1 second
04115B FD 21 DB 12 0104*       ld iy,tmr_test
       04          
041160 CD B9 12 04 0105*       call tmr_set
041164             0106*   ; set a PRT timer
041164             0107*       ; ld hl,prt_reload_hardware
041164             0108*       ; ld hl,prt_reload_emulator
041164 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
041168 22 50 11 04 0110*       ld (prt_reload),hl
04116C CD F4 11 04 0111*       call prt_set
041170             0112*   @loop:
041170             0113*   ; check time remaining on MOS timer
041170 CD C7 12 04 0114*       call tmr_get
041174 CA 7E 11 04 0115*       jp z,@done ; time expired,so quit
041178 FA 7E 11 04 0116*       jp m,@done ; time past expiration (negative),so quit
04117C 18 F2       0117*       jr @loop
04117E             0118*   @done:
04117E ED 5B 42 12 0119*       ld de,(prt_irq_counter)
       04          
041183 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
041187 ED 43 50 11 0121*       ld (prt_reload),bc
       04          
04118C 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
041190 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
041191 32 B3 11 04 0124*       ld (is_emulator),a
041195 ED 52       0125*       sbc hl,de
041197 21 B4 11 04 0126*       ld hl,on_hardware ; default message for running on hardware
04119B CA 53 11 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
04119F F8          0128*       ret m ; negative result means we're on hardware
0411A0 3C          0129*       inc a ; we're on emulator
0411A1 32 B3 11 04 0130*       ld (is_emulator),a
0411A5 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
0411A9 ED 43 50 11 0132*       ld (prt_reload),bc
       04          
0411AE 21 CA 11 04 0133*       ld hl,on_emulator
0411B2 C9          0134*       ret
0411B3 00          0135*   is_emulator: db 0
0411B4 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
0411CA 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
0411E0             0138*   
0411E0 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
0411F4             0140*   
0411F4             0141*   ; set PRT timer
0411F4             0142*   prt_set:
0411F4 21 00 00 00 0143*       ld hl,0
0411F8 22 42 12 04 0144*       ld (prt_irq_counter),hl
0411FC 2A 50 11 04 0145*       ld hl,(prt_reload)
041200 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
041203 ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
041206             0148*   ; disable timer
041206 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041208 ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
04120B             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04120B 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04120D ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
041210 C9          0154*       ret
041211             0155*   
041211             0156*   ; ===============================================
041211             0157*   ; PRT Timer Interrupt Handling
041211             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
041211             0159*   ; -----------------------------------------------
041211             0160*   prt_irq_init:
041211             0161*       ; set up interrupt vector table 2
041211 21 00 00 00 0162*   	ld hl,0
041215 3A 0C 01 00 0163*   	ld a,($10c)
041219 6F          0164*   	ld l,a
04121A 3A 0D 01 00 0165*   	ld a,($10d)
04121E 67          0166*   	ld h,a
04121F             0167*   
04121F             0168*   	; skip over CALL ($c3)
04121F 23          0169*   	inc hl
041220             0170*   	; load address of jump into vector table 2 (in ram)
041220 ED 27       0171*   	ld hl,(hl)
041222             0172*   
041222             0173*   	; write CALL prt_irq_handler to vector table 2
041222 3E C3       0174*   	ld a,$c3
041224 77          0175*   	ld (hl),a
041225 23          0176*   	inc hl
041226 11 2D 12 04 0177*   	ld de,prt_irq_handler
04122A ED 1F       0178*   	ld (hl),de
04122C             0179*   
04122C C9          0180*       ret
04122D             0181*   
04122D             0182*   prt_irq_handler:
04122D F3          0183*   	di
04122E F5          0184*   	push af
04122F E5          0185*       push hl
041230 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
041233 2A 42 12 04 0187*   	ld hl,(prt_irq_counter)
041237 23          0188*   	inc hl
041238 22 42 12 04 0189*   	ld (prt_irq_counter),hl
04123C E1          0190*       pop hl
04123D F1          0191*   	pop af
04123E FB          0192*   	ei
04123F 5B ED 4D    0193*   	reti.l
041242             0194*   
041242             0195*   prt_irq_counter:
041242 00 00 00    0196*   	.dl 0
041245             0197*   prt_irq_counter_saved:
041245 00 00 00    0198*       .dl 0
041248             0199*   
041248             0200*   prt_loop_reset:
041248 E5          0201*       push hl
041249 21 00 00 00 0202*   	ld hl,0
04124D 22 42 12 04 0203*   	ld (prt_irq_counter),hl
041251 22 B3 12 04 0204*       ld (prt_loop_counter),hl
041255 22 B6 12 04 0205*       ld (prt_loops),hl
041259 CD F4 11 04 0206*       call prt_set
04125D E1          0207*       pop hl
04125E C9          0208*       ret
04125F             0209*   
04125F             0210*   prt_loop_start:
04125F E5          0211*       push hl
041260 21 00 00 00 0212*   	ld hl,0
041264 22 42 12 04 0213*   	ld (prt_irq_counter),hl
041268 E1          0214*       pop hl
041269 C9          0215*       ret
04126A             0216*   
04126A             0217*   prt_loop_stop:
04126A E5          0218*       push hl
04126B D5          0219*       push de
04126C 2A 42 12 04 0220*       ld hl,(prt_irq_counter)
041270 ED 5B B3 12 0221*       ld de,(prt_loop_counter)
       04          
041275 19          0222*       add hl,de
041276 22 B3 12 04 0223*       ld (prt_loop_counter),hl
04127A 21 00 00 00 0224*       ld hl,0
04127E 22 42 12 04 0225*       ld (prt_irq_counter),hl
041282 2A B6 12 04 0226*       ld hl,(prt_loops)
041286 23          0227*       inc hl
041287 22 B6 12 04 0228*       ld (prt_loops),hl
04128B D1          0229*       pop de
04128C E1          0230*       pop hl
04128D C9          0231*       ret
04128E             0232*   
04128E             0233*   ; inputs: bc = y,x text coordinates to print
04128E             0234*   prt_loop_print:
04128E F5          0235*       push af
04128F E5          0236*       push hl
041290 C5          0237*       push bc
041291 D5          0238*       push de
041292 DD E5       0239*       push ix
041294 FD E5       0240*       push iy
041296 CD C6 13 04 0241*       call vdu_move_cursor
04129A             0242*   
04129A 2A B3 12 04 0243*       ld hl,(prt_loop_counter)
04129E CD C8 00 04 0244*       call printDec
0412A2             0245*   
0412A2 2A B6 12 04 0246*       ld hl,(prt_loops)
0412A6 CD C8 00 04 0247*       call printDec
0412AA             0248*   
0412AA FD E1       0249*       pop iy
0412AC DD E1       0250*       pop ix
0412AE D1          0251*       pop de
0412AF C1          0252*       pop bc
0412B0 E1          0253*       pop hl
0412B1 F1          0254*       pop af
0412B2 C9          0255*       ret
0412B3             0256*   
0412B3             0257*   prt_loop_counter:
0412B3 00 00 00    0258*       .dl 0
0412B6             0259*   prt_loops:
0412B6 00 00 00    0260*       .dl 0
0412B9             0261*   
0412B9             0262*   ; ===============================================
0412B9             0263*   ; Timer functions
0412B9             0264*   ; -----------------------------------------------
0412B9             0265*   ; set a countdown timer
0412B9             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412B9             0267*   ; returns: hl = current time
0412B9             0268*   tmr_set:
0412B9 FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
0412BC             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0412BC 3E 08       0001*M1 			LD	A, function
0412BE 5B CF       0002*M1 			RST.LIL	08h
0412C0 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
0412C3 FD 2F 00    0272*       ld (iy+0),hl            ; set start time
0412C6 C9          0273*       ret
0412C7             0274*   
0412C7             0275*   ; gets time remaining on a countdown timer
0412C7             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412C7             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0412C7             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
0412C7             0279*   tmr_get:
0412C7             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0412C7 3E 08       0001*M1 			LD	A, function
0412C9 5B CF       0002*M1 			RST.LIL	08h
0412CB DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
0412CE FD 27 00    0282*       ld hl,(iy+0)            ; get start time
0412D1 AF          0283*       xor a                   ; clear carry
0412D2 ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0412D4 FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
0412D7 AF          0286*       xor a                   ; clear carry
0412D8 ED 5A       0287*       adc hl,de               ; hl = time remaining
0412DA             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0412DA C9          0289*       ret
0412DB             0290*   
0412DB             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
0412E1             0292*   
       FF FF FF FF 
       FF FF 
0412E1 00 00 00    0293*   timestamp_now: dl 0
0412E4 00 00 00    0294*   timestamp_old: dl 0
0412E7 00 00 00    0295*   timestamp_chg: dl 0
0412EA             0296*   
0412EA             0297*   ; update the global timestamp from the system clock
0412EA             0298*   ; inputs: none
0412EA             0299*   ; returns: hl = time elapsed in 1/120ths of a second
0412EA             0300*   ;          de = current time
0412EA             0301*   ;          ix = pointer to syvars table
0412EA             0302*   ; destroys: af,hl,de,ix
0412EA             0303*   timestamp_tick:
0412EA ED 5B E1 12 0304*       ld de,(timestamp_now)   ; get previous time
       04          
0412EF ED 53 E4 12 0305*       ld (timestamp_old),de   ; save previous time
       04          
0412F4             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0412F4 3E 08       0001*M1 			LD	A, function
0412F6 5B CF       0002*M1 			RST.LIL	08h
0412F8 DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
0412FB 22 E1 12 04 0308*       ld (timestamp_now),hl   ; save current time
0412FF AF          0309*       xor a                   ; clear carry
041300 ED 52       0310*       sbc hl,de               ; hl = time elapsed
041302 22 E7 12 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
041306 C9          0312*       ret
041307             0313*   
041307             0314*   ; set a countdown timer
041307             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041307             0316*   ; requires: timestamp_tick to be called at least once before this function
041307             0317*   ; returns: hl = current time
041307             0318*   ; destroys: hl
041307             0319*   timestamp_tmr_set:
041307 FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
04130A 2A E1 12 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
04130E FD 2F 00    0322*       ld (iy+0),hl            ; set start time
041311 C9          0323*       ret
041312             0324*   
041312             0325*   ; gets time remaining on a countdown timer following the global timestamp
041312             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041312             0327*   ; requires: timestamp_tick to be called at least once before this function
041312             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041312             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
041312             0330*   ; destroys: af,hl,de
041312             0331*   timestamp_tmr_get:
041312 ED 5B E1 12 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
041317 FD 27 00    0333*       ld hl,(iy+0)            ; get start time
04131A AF          0334*       xor a                   ; clear carry
04131B ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04131D FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
041320 AF          0337*       xor a                   ; clear carry
041321 ED 5A       0338*       adc hl,de               ; hl = time remaining
041323             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041323 C9          0340*       ret
041324             0341*   
041324             0342*   ; set a stopwatch
041324             0343*   ; returns: hl = start time
041324             0344*   ; destroys: hl,ix
041324             0345*   stopwatch_set:
041324             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041324 3E 08       0001*M1 			LD	A, function
041326 5B CF       0002*M1 			RST.LIL	08h
041328 DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
04132B 22 40 13 04 0348*       ld (stopwatch_started),hl            ; set start time
04132F C9          0349*       ret
041330             0350*   
041330             0351*   ; gets time elapsed on a stopwatch
041330             0352*   ; returns: hl = time elapsed in 1/120ths of a second
041330             0353*   ; destroys: af,hl,de,ix
041330             0354*   stopwatch_get:
041330             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
041330 3E 08       0001*M1 			LD	A, function
041332 5B CF       0002*M1 			RST.LIL	08h
041334 DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
041337 ED 5B 40 13 0357*       ld de,(stopwatch_started)            ; get start time
       04          
04133C AF          0358*       xor a                   ; clear carry
04133D ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04133F C9          0360*       ret
041340             0361*   
041340             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041343             0363*   
041343             0364*   ; ------------------
041343             0365*   ; delay routine
041343             0366*   ; Author: Richard Turrnidge
041343             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
041343             0368*   ; routine waits a fixed time,then returns
041343             0369*   ; arrive with A =  the delay byte. One bit to be set only.
041343             0370*   ; eg. ld A,00000100b
041343             0371*   
041343             0372*   multiPurposeDelay:
       FF FF FF 
041343 F5          0373*       push af
041344 C5          0374*       push bc
041345 DD E5       0375*       push ix
041347 47          0376*       ld b,a
041348 3E 08       0377*       ld a,$08
04134A 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
04134C             0379*   
04134C             0380*   waitLoop:
04134C             0381*   
04134C DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04134F             0383*   
04134F             0384*                                   ;   we check if bit set is same as last time we checked.
04134F             0385*                                   ;   bit 0 - don't use
04134F             0386*                                   ;   bit 1 - changes 64 times per second
04134F             0387*                                   ;   bit 2 - changes 32 times per second
04134F             0388*                                   ;   bit 3 - changes 16 times per second
04134F             0389*   
04134F             0390*                                   ;   bit 4 - changes 8 times per second
04134F             0391*                                   ;   bit 5 - changes 4 times per second
04134F             0392*                                   ;   bit 6 - changes 2 times per second
04134F             0393*                                   ;   bit 7 - changes 1 times per second
04134F A0          0394*       and b
041350 4F          0395*       ld c,a
041351 3A 62 13 04 0396*       ld a,(oldTimeStamp)
041355 B9          0397*       cp c                        ; is A same as last value?
041356 28 F4       0398*       jr z,waitLoop              ; loop here if it is
041358 79          0399*       ld a,c
041359 32 62 13 04 0400*       ld (oldTimeStamp),a        ; set new value
04135D             0401*   
04135D DD E1       0402*       pop ix
04135F C1          0403*       pop bc
041360 F1          0404*       pop af
041361 C9          0405*       ret
041362             0406*   
041362 00          0407*   oldTimeStamp:   .db 00h
041363             0035        include "../include/vdu.inc"
041363             0001*       MACRO VDU_BEEP
041363             0002*       ld a,7
041363             0003*       rst.lil $10
041363             0004*       ENDMACRO
041363             0005*   
041363             0006*   ; VDU 30: Home cursor
041363             0007*   vdu_home_cursor:
041363 3E 1E       0008*       ld a,30
041365 5B D7       0009*   	rst.lil $10
041367 C9          0010*   	ret
041368             0011*   
041368             0012*   vdu_cursor_on:
041368 21 73 13 04 0013*   	ld hl,@cmd
04136C 01 03 00 00 0014*   	ld bc,@end-@cmd
041370 5B DF       0015*   	rst.lil $18
041372 C9          0016*   	ret
041373             0017*   @cmd:
041373 17 01 01    0018*   	db 23,1,1
041376             0019*   @end:
041376             0020*   
041376             0021*   vdu_cursor_off:
041376 21 81 13 04 0022*   	ld hl,@cmd
04137A 01 03 00 00 0023*   	ld bc,@end-@cmd
04137E 5B DF       0024*   	rst.lil $18
041380 C9          0025*   	ret
041381             0026*   @cmd:
041381 17 01 00    0027*   	db 23,1,0
041384             0028*   @end:
041384             0029*   
041384             0030*   ; VDU 4: Write text at text cursor
041384             0031*   ; This causes text to be written at th current text cursor position. This is the default mode for text display.
041384             0032*   ; inputs: none
041384             0033*   ; prerequisites: the text cursor at the intended position on screen
041384             0034*   ; outputs: none
041384             0035*   ; destroys: af
041384             0036*   vdu_text_to_text_cursor:
041384 3E 04       0037*       ld a,4
041386 5B D7       0038*       rst.lil $10
041388 C9          0039*       ret
041389             0040*   ; end vdu_text_to_text_cursor
041389             0041*   
041389             0042*   ; set the text cursor to a specified location and print a string there
041389             0043*   ; inputs: hl = address of string to print, c,b = x,y text coordinates
041389             0044*   ; outputs: text
041389             0045*   ; destroys: af, bc, hl
041389             0046*   ; affects: moves text cursor to position after final char printed by default
041389             0047*   ;          unless overridden by VDU 23, 16 cursor control command settings
041389             0048*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the text cursor
041389             0049*   vdu_print_to_text_location:
041389 E5          0050*       push hl ; preserve string pointer
04138A 3E 04       0051*       ld a,4 ; VDU 4 char to text cursor
04138C 5B D7       0052*       rst.lil $10
04138E CD C6 13 04 0053*       call vdu_move_cursor
041392 E1          0054*       pop hl ; restore string pointer
041393 CD 63 00 04 0055*       call printString
041397 C9          0056*       ret
041398             0057*   ; end vdu_print_at_text_location
041398             0058*   
041398             0059*   ; VDU 5: Write text at graphics cursor
041398             0060*   ; inputs: none
041398             0061*   ; prerequisites: the graphics cursor at the intended position on screen
041398             0062*   ; outputs: none
041398             0063*   ; destroys: af
041398             0064*   vdu_text_to_gfx_cursor:
041398 3E 05       0065*       ld a,5
04139A 5B D7       0066*   	rst.lil $10
04139C C9          0067*   	ret
04139D             0068*   ; end vdu_char_to_gfx_cursor
04139D             0069*   
04139D             0070*   ; set the graphics cursor to a specified location and print a string there
04139D             0071*   ; inputs: hl = address of string to print, bc,de = x,y graphics coordinates
04139D             0072*   ; outputs: text
04139D             0073*   ; destroys: af, bc, de, hl
04139D             0074*   ; affects: moves graphics cursor to position after final char printed by default
04139D             0075*   ;          unless overridden by setting bit 6 of the cursor control register (VDU 23, 16)
04139D             0076*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the graphics cursor
04139D             0077*   vdu_print_to_gfx_location:
04139D E5          0078*       push hl ; preserve string pointer
04139E 3E 44       0079*       ld a,plot_pt+mv_abs
0413A0 CD 3D 19 04 0080*       call vdu_plot ; moves the graphics cursor to the specified location
0413A4 3E 05       0081*       ld a,5 ; VDU 5 char to gfx cursor
0413A6 5B D7       0082*       rst.lil $10
0413A8 E1          0083*       pop hl ; restore string pointer
0413A9 01 00 00 00 0084*       ld bc,0
0413AD 3E 00       0085*       ld a,0
0413AF 5B DF       0086*       rst.lil $18 ; print the string
0413B1 C9          0087*       ret
0413B2             0088*   ; end vdu_print_at_gfx_location
0413B2             0089*   
0413B2             0090*   ; VDU 8: Move cursor back one character
0413B2             0091*   vdu_cursor_back:
0413B2 3E 08       0092*       ld a,8
0413B4 5B D7       0093*       rst.lil $10
0413B6 C9          0094*       ret
0413B7             0095*   ; end vdu_cursor_back
0413B7             0096*   
0413B7             0097*   ; VDU 9: Move cursor forward one character
0413B7             0098*   vdu_cursor_forward:
0413B7 3E 09       0099*       ld a,9
0413B9 5B D7       0100*   	rst.lil $10
0413BB C9          0101*   	ret
0413BC             0102*   ; end vdu_cursor_forward
0413BC             0103*   
0413BC             0104*   ; VDU 10: Move cursor down one line
0413BC             0105*   vdu_cursor_down:
0413BC 3E 0A       0106*       ld a,10
0413BE 5B D7       0107*       rst.lil $10
0413C0 C9          0108*       ret
0413C1             0109*   ; end vdu_cursor_down
0413C1             0110*   
0413C1             0111*   ; VDU 11: Move cursor up one line
0413C1             0112*   vdu_cursor_up:
0413C1 3E 0B       0113*       ld a,11
0413C3 5B D7       0114*       rst.lil $10
0413C5 C9          0115*       ret
0413C6             0116*   ; end vdu_cursor_up
0413C6             0117*   
0413C6             0118*   
0413C6             0119*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0413C6             0120*   ; inputs: c=x, b=y 8-bit unsigned integers
0413C6             0121*   vdu_move_cursor:
0413C6 ED 43 D7 13 0122*       ld (@x0),bc
       04          
0413CB 21 D6 13 04 0123*   	ld hl,@cmd
0413CF 01 03 00 00 0124*   	ld bc,@end-@cmd
0413D3 5B DF       0125*   	rst.lil $18
0413D5 C9          0126*   	ret
0413D6 1F          0127*   @cmd: 	db 31
0413D7 00          0128*   @x0:	db 0
0413D8 00          0129*   @y0: 	db 0
0413D9 00          0130*   @end: 	db 0 ; padding
0413DA             0131*   
0413DA             0132*   ; https://agonconsole8.github.io/agon-docs/vdp/VDU-Commands/#vdu-23-1-n-cursor-control
0413DA             0133*   ; VDU 23, 16, setting, mask: Define cursor movement behaviour
0413DA             0134*   ; inputs: l = setting, h = mask
0413DA             0135*   ; new_setting = (current_setting AND mask) EOR setting
0413DA             0136*   ; in English: mask controls which bit to turn on or off, setting is the value of the bits to set or reset
0413DA             0137*   vdu_cursor_behaviour:
0413DA 22 EB 13 04 0138*       ld (@setting),hl ; little-endian!
0413DE 21 E9 13 04 0139*       ld hl,@cmd
0413E2 01 04 00 00 0140*       ld bc,@end-@cmd
0413E6 5B DF       0141*       rst.lil $18
0413E8 C9          0142*       ret
0413E9 17 10       0143*   @cmd: db 23,16
0413EB 00          0144*   @setting: db 0
0413EC 00          0145*   @mask: db 0
0413ED 00          0146*   @end: db 0 ; padding
0413EE             0147*   
0413EE             0148*   ; VDU 12: Clear text area (CLS)
0413EE             0149*   vdu_cls:
0413EE 3E 0C       0150*       ld a,12
0413F0 5B D7       0151*   	rst.lil $10
0413F2 C9          0152*   	ret
0413F3             0153*   
0413F3             0154*   vdu_flip:
0413F3 21 FE 13 04 0155*   	ld hl,@cmd
0413F7 01 03 00 00 0156*   	ld bc,@end-@cmd
0413FB 5B DF       0157*   	rst.lil $18
0413FD C9          0158*   	ret
0413FE 17 00 C3    0159*   @cmd: db 23,0,0xC3
041401             0160*   @end:
041401             0161*   
041401             0162*   ; VDU 16: Clear graphics area (CLG)
041401             0163*   vdu_clg:
041401 3E 10       0164*       ld a,16
041403 5B D7       0165*   	rst.lil $10
041405 C9          0166*   	ret
041406             0167*   
041406             0168*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041406             0169*   ; VDU 23, 7: Scrolling
041406             0170*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041406             0171*   ; inputs: a, extent; l, direction; h; speed
041406             0172*   vdu_scroll_down:
041406 32 1B 14 04 0173*   	ld (@extent),a
04140A 22 1C 14 04 0174*   	ld (@dir),hl ; implicitly populates @speed
04140E 21 19 14 04 0175*   	ld hl,@cmd
041412 01 05 00 00 0176*   	ld bc,@end-@cmd
041416 5B DF       0177*   	rst.lil $18     ;; Sending command to VDP
041418 C9          0178*   	ret
041419 17 07       0179*   @cmd:       db 23,7
04141B 00          0180*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
04141C 00          0181*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
04141D 00          0182*   @speed:     db 0x00 ; pixels
04141E 00          0183*   @end:		db 0x00 ; padding
04141F             0184*   
04141F             0185*   ; COLOUR MODES
04141F             0186*   ; Mode	Effect
04141F             0187*   ; 0	Set on-screen pixel to target colour value
04141F             0188*   ; 1	OR value with the on-screen pixel
04141F             0189*   ; 2	AND value with the on-screen pixel
04141F             0190*   ; 3	XOR value with the on-screen pixel
04141F             0191*   ; 4	Invert the on-screen pixel
04141F             0192*   ; 5	No operation
04141F             0193*   ; 6	AND the inverse of the specified colour with the on-screen pixel
04141F             0194*   ; 7	OR the inverse of the specified colour with the on-screen pixel
04141F             0195*   
04141F             0196*   ; VDU 17, colour: Define text colour (COLOUR)
04141F             0197*   vdu_colour_text:
04141F 32 2F 14 04 0198*   	ld (@arg),a
041423 21 2E 14 04 0199*   	ld hl,@cmd
041427 01 02 00 00 0200*   	ld bc,@end-@cmd
04142B 5B DF       0201*   	rst.lil $18
04142D C9          0202*   	ret
04142E 11          0203*   @cmd: db 17
04142F 00          0204*   @arg: db 0
041430             0205*   @end:
041430             0206*   
041430             0207*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041430             0208*   ; inputs: a=mode, c=colour (add 128 to set background colour)
041430             0209*   vdu_gcol:
041430 32 45 14 04 0210*   	ld (@mode),a
041434 79          0211*       ld a,c
041435 32 46 14 04 0212*       ld (@col),a
041439 21 44 14 04 0213*   	ld hl,@cmd
04143D 01 03 00 00 0214*   	ld bc,@end-@cmd
041441 5B DF       0215*   	rst.lil $18
041443 C9          0216*   	ret
041444 12          0217*   @cmd:  db 18
041445 00          0218*   @mode: db 0
041446 00          0219*   @col:  db 0
041447             0220*   @end:
041447             0221*   
041447             0222*   
041447             0223*   ; VDU 28, left, bottom, right, top: Set text viewport **
041447             0224*   ; MIND THE LITTLE-ENDIANESS
041447             0225*   ; inputs: c=left,b=bottom,e=right,d=top
041447             0226*   ; outputs; nothing
041447             0227*   ; destroys: af, hl, bc, de
041447             0228*   vdu_set_txt_viewport:
041447 ED 43 5D 14 0229*       ld (@lb),bc
       04          
04144C ED 53 5F 14 0230*   	ld (@rt),de
       04          
041451 21 5C 14 04 0231*   	ld hl,@cmd
041455 01 05 00 00 0232*   	ld bc,@end-@cmd
041459 5B DF       0233*   	rst.lil $18
04145B C9          0234*   	ret
04145C 1C          0235*   @cmd:   db 28 ; set text viewport command
04145D 00 00       0236*   @lb: 	dw 0x0000 ; set by bc
04145F 00 00       0237*   @rt: 	dw 0x0000 ; set by de
041461 00          0238*   @end:   db 0x00	  ; padding
041462             0239*   
041462             0240*   ; Wait for VBLANK interrupt
041462             0241*   vdu_vblank:
041462 DD E5       0242*       PUSH 	IX
041464             0243*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
041464 3E 08       0001*M1 			LD	A, function
041466 5B CF       0002*M1 			RST.LIL	08h
041468 DD 7E 00    0244*   	LD	A, (IX + sysvar_time + 0)
04146B             0245*   @wait:
04146B DD BE 00    0246*       CP 	A, (IX + sysvar_time + 0)
04146E 28 FB       0247*       JR	Z, @wait
041470 DD E1       0248*       POP	IX
041472 C9          0249*       RET
041473             0250*   
041473             0251*   ; VDU 29, x; y;: Set graphics origin
041473             0252*   ; This command sets the graphics origin.
041473             0253*   ; The origin is the point on the screen where the coordinates (0,0) are located.
041473             0254*   ; inputs: bc=x0,de=y0
041473             0255*   ; outputs; nothing
041473             0256*   ; destroys: a might make it out alive
041473             0257*   vdu_set_gfx_origin:
041473 ED 43 89 14 0258*       ld (@x0),bc
       04          
041478 ED 53 8B 14 0259*       ld (@y0),de
       04          
04147D 21 88 14 04 0260*       ld hl,@cmd
041481 01 05 00 00 0261*       ld bc,@end-@cmd
041485 5B DF       0262*       rst.lil $18
041487 C9          0263*       ret
041488 1D          0264*   @cmd:   db 29 ; set graphics origin command
041489 00 00       0265*   @x0: 	dw 0x0000 ; set by bc
04148B 00 00       0266*   @y0: 	dw 0x0000 ; set by de
04148D 00          0267*   @end:   db 0x00	  ; padding
04148E             0268*   
04148E             0269*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
04148E             0270*   ; NOTE: the order of the y-coordinate parameters are inverted
04148E             0271*   ; 	because we have turned off logical screen scaling
04148E             0272*   ; NOTE: coordinates are relative to current gfx origin
04148E             0273*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04148E             0274*   ; outputs; nothing
04148E             0275*   ; destroys: a might make it out alive
04148E             0276*   vdu_set_gfx_viewport:
04148E ED 43 AE 14 0277*       ld (@x0),bc
       04          
041493 FD 22 B0 14 0278*       ld (@y1),iy
       04          
041498 DD 22 B2 14 0279*   	ld (@x1),ix
       04          
04149D ED 53 B4 14 0280*   	ld (@y0),de
       04          
0414A2 21 AD 14 04 0281*   	ld hl,@cmd
0414A6 01 09 00 00 0282*   	ld bc,@end-@cmd
0414AA 5B DF       0283*   	rst.lil $18
0414AC C9          0284*   	ret
0414AD 18          0285*   @cmd:   db 24 ; set graphics viewport command
0414AE 00 00       0286*   @x0: 	dw 0x0000 ; set by bc
0414B0 00 00       0287*   @y1: 	dw 0x0000 ; set by iy
0414B2 00 00       0288*   @x1: 	dw 0x0000 ; set by ix
0414B4 00 00       0289*   @y0: 	dw 0x0000 ; set by de
0414B6 00          0290*   @end:   db 0x00	  ; padding
0414B7             0291*   
0414B7             0292*   ; VDU 26: Reset graphics and text viewports
0414B7             0293*   vdu_reset_viewports:
0414B7 3E 1A       0294*       ld a,26
0414B9 5B D7       0295*       rst.lil $10
0414BB C9          0296*       ret
0414BC             0297*   
0414BC             0298*   ; SCREEN MODES
0414BC             0299*   ; ===============================
0414BC             0300*   ; Mode  Horz  Vert  Cols  Refresh
0414BC             0301*   ; ---   ----  ----  ----  -------
0414BC             0302*   ; 11    320   240   2     60hz
0414BC             0303*   ; 139   320   240   2     60hz
0414BC             0304*   ; 23    512   384   2     60hz
0414BC             0305*   ; 151   512   384   2     60hz
0414BC             0306*   ; 6     640   240   2     60hz
0414BC             0307*   ; 134   640   240   2     60hz
0414BC             0308*   ; 2     640   480   2     60hz
0414BC             0309*   ; 130   640   480   2     60hz
0414BC             0310*   ; 17    800   600   2     60hz
0414BC             0311*   ; 145   800   600   2     60hz
0414BC             0312*   ; 18    1024  768   2     60hz
0414BC             0313*   ; 146   1024  768   2     60hz
0414BC             0314*   ; ---   ----  ----  ----  -------
0414BC             0315*   ; 10    320   240   4     60hz
0414BC             0316*   ; 138   320   240   4     60hz
0414BC             0317*   ; 22    512   384   4     60hz
0414BC             0318*   ; 150   512   384   4     60hz
0414BC             0319*   ; 5     640   240   4     60hz
0414BC             0320*   ; 133   640   240   4     60hz
0414BC             0321*   ; 1     640   480   4     60hz
0414BC             0322*   ; 129   640   480   4     60hz
0414BC             0323*   ; 16    800   600   4     60hz
0414BC             0324*   ; 19    1024  768   4     60hz
0414BC             0325*   ; ---   ----  ----  ----  -------
0414BC             0326*   ; 9     320   240   16    60hz
0414BC             0327*   ; 137   320   240   16    60hz
0414BC             0328*   ; 21    512   384   16    60hz
0414BC             0329*   ; 149   512   384   16    60hz
0414BC             0330*   ; 4     640   240   16    60hz
0414BC             0331*   ; 132   640   240   16    60hz
0414BC             0332*   ; 0     640   480   16    60hz
0414BC             0333*   ; 7     n/a   n/a   16    60hz
0414BC             0334*   ; ---   ----  ----  ----  -------
0414BC             0335*   ; 8     320   240   64    60hz
0414BC             0336*   ; 136   320   240   64    60hz
0414BC             0337*   ; 20    512   384   64    60hz
0414BC             0338*   ; 3     640   240   64    60hz
0414BC             0339*   ; ---   ----  ----  ----  -------
0414BC             0340*   vdu_set_screen_mode:
0414BC 32 CC 14 04 0341*   	ld (@arg),a
0414C0 21 CB 14 04 0342*   	ld hl,@cmd
0414C4 01 02 00 00 0343*   	ld bc,@end-@cmd
0414C8 5B DF       0344*   	rst.lil $18
0414CA C9          0345*   	ret
0414CB 16          0346*   @cmd: db 22 ; set screen mode
0414CC 00          0347*   @arg: db 0  ; screen mode parameter
0414CD             0348*   @end:
0414CD             0349*   
0414CD             0350*   ; get the current screen mode
0414CD             0351*   ; inputs: none
0414CD             0352*   ; outputs: a=screen mode
0414CD             0353*   ; destroys: af, ix
0414CD             0354*   vdu_get_screen_mode:
0414CD             0355*       MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
0414CD 3E 08       0001*M1 			LD	A, function
0414CF 5B CF       0002*M1 			RST.LIL	08h
0414D1 DD 7E 27    0356*       ld a,(IX+sysvar_scrMode)
0414D4 C9          0357*       ret
0414D5             0358*   ; end vdu_get_screen_mode
0414D5             0359*   
0414D5             0360*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0414D5             0361*   ; inputs: a is scaling mode, 1=on, 0=off
0414D5             0362*   ; note: default setting on boot is scaling ON
0414D5             0363*   vdu_set_scaling:
0414D5 32 E7 14 04 0364*   	ld (@arg),a
0414D9 21 E4 14 04 0365*   	ld hl,@cmd
0414DD 01 04 00 00 0366*   	ld bc,@end-@cmd
0414E1 5B DF       0367*   	rst.lil $18
0414E3 C9          0368*   	ret
0414E4 17 00 C0    0369*   @cmd: db 23,0,0xC0
0414E7 00          0370*   @arg: db 0  ; scaling on/off
0414E8             0371*   @end:
0414E8             0372*   
0414E8             0373*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0414E8             0374*   ; inputs: hl=bufferId
0414E8             0375*   vdu_buff_select:
0414E8 22 FA 14 04 0376*   	ld (@bufferId),hl
0414EC 21 F7 14 04 0377*   	ld hl,@cmd
0414F0 01 05 00 00 0378*   	ld bc,@end-@cmd
0414F4 5B DF       0379*   	rst.lil $18
0414F6 C9          0380*   	ret
0414F7 17 1B 20    0381*   @cmd: db 23,27,0x20
0414FA 00 00       0382*   @bufferId: dw 0x0000
0414FC 00          0383*   @end: db 0x00 ; padding
0414FD             0384*   
0414FD             0385*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0414FD             0386*   ; inputs: a=format; bc=width; de=height
0414FD             0387*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0414FD             0388*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0414FD             0389*   ; 0 	RGBA8888 (4-bytes per pixel)
0414FD             0390*   ; 1 	RGBA2222 (1-bytes per pixel)
0414FD             0391*   ; 2 	Mono/Mask (1-bit per pixel)
0414FD             0392*   ; 3 	Reserved for internal use by VDP (“native” format)
0414FD             0393*   vdu_bmp_create:
0414FD ED 43 19 15 0394*       ld (@width),bc
       04          
041502 ED 53 1B 15 0395*       ld (@height),de
       04          
041507 32 1D 15 04 0396*       ld (@fmt),a
04150B 21 16 15 04 0397*   	ld hl,@cmd
04150F 01 08 00 00 0398*   	ld bc,@end-@cmd
041513 5B DF       0399*   	rst.lil $18
041515 C9          0400*   	ret
041516 17 1B 21    0401*   @cmd:       db 23,27,0x21
041519 00 00       0402*   @width:     dw 0x0000
04151B 00 00       0403*   @height:    dw 0x0000
04151D 00          0404*   @fmt:       db 0x00
04151E             0405*   @end:
04151E             0406*   
04151E             0407*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04151E             0408*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04151E             0409*   vdu_load_img_rgba2_to_8:
04151E             0410*   ; backup the target buffer id and image dimensions
04151E E5          0411*       push hl
04151F D5          0412*       push de
041520 C5          0413*       push bc
041521             0414*   ; load the rgba2 image to working buffer 65534
041521 21 FE FF 00 0415*       ld hl,65534 ; temporary working buffer id
041525 CD FC 15 04 0416*   	call vdu_load_buffer_from_file
041529             0417*   ; restore the image dimensions and target buffer id
041529 C1          0418*       pop bc
04152A D1          0419*       pop de
04152B E1          0420*       pop hl
04152C             0421*   ; fall through to vdu_rgba2_to_8
04152C             0422*   
04152C             0423*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04152C             0424*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04152C             0425*   ; the "expand bitmap" command is:
04152C             0426*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04152C             0427*   ; and then to reverse the byte order to fix endian-ness:
04152C             0428*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04152C             0429*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04152C             0430*   ; VDU 23,27,&20,targetBufferID%;
04152C             0431*   ; VDU 23,27,&21,width%;height%;0
04152C             0432*   ; -------------------------------------------------------------------
04152C             0433*   ; inputs: bc,de image width,height ; hl = targetBufferId
04152C             0434*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04152C             0435*   vdu_rgba2_to_8:
04152C             0436*   ; load the image dimensions and buffer id parameters
04152C ED 43 88 15 0437*       ld (@width),bc
       04          
041531 ED 53 8A 15 0438*       ld (@height),de
       04          
041536 22 6D 15 04 0439*       ld (@bufferId0),hl
04153A 22 7A 15 04 0440*       ld (@bufferId2),hl
04153E 22 83 15 04 0441*       ld (@bufferId1),hl
041542             0442*   ; clean up bytes that got stomped on by the ID loads
041542 3E 48       0443*       ld a,0x48
041544 32 6F 15 04 0444*       ld (@bufferId0+2),a
041548 3E 17       0445*       ld a,23
04154A 32 85 15 04 0446*       ld (@bufferId1+2),a
04154E 3E 18       0447*       ld a,24
041550 32 7C 15 04 0448*       ld (@bufferId2+2),a
041554 AF          0449*       xor a
041555 32 8C 15 04 0450*       ld (@height+2),a
041559             0451*   ; send the vdu command strings
041559 21 64 15 04 0452*       ld hl,@beg
04155D 01 29 00 00 0453*       ld bc,@end-@beg
041561 5B DF       0454*       rst.lil $18
041563 C9          0455*       ret
041564             0456*   @beg:
041564             0457*   ; Command 14: Consolidate blocks in a buffer
041564             0458*   ; VDU 23, 0, &A0, bufferId; 14
041564 17 00 A0    0459*       db 23,0,0xA0
041567 FE FF       0460*       dw 65534 ; workingBufferId
041569 0E          0461*       db 14 ; consolidate blocks
04156A             0462*   ; the "expand bitmap" command is:
04156A             0463*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04156A 17 00 A0    0464*       db 23,0,0xA0
04156D 00 00       0465*   @bufferId0: dw 0x0000 ; targetBufferId
04156F 48          0466*       db 0x48 ; given as decimal command 72 in the docs
041570 02          0467*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041571 FE FF       0468*       dw 65534 ; sourceBufferId
041573 00 7F BF FF 0469*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041577             0470*   ; reverse the byte order to fix endian-ness:
041577             0471*   ; Command 24: Reverse the order of data of blocks within a buffer
041577             0472*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041577             0473*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041577 17 00 A0    0474*       db 23,0,0xA0
04157A 00 00       0475*   @bufferId2:    dw 0x0000 ; targetBufferId
04157C 18          0476*       db 24 ; reverse byte order
04157D 04          0477*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04157E 04 00       0478*       dw 4 ; size (4 bytes)
041580             0479*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041580             0480*   ; VDU 23,27,&20,targetBufferID%;
041580 17 1B 20    0481*       db 23,27,0x20 ; select bitmap
041583 00 00       0482*   @bufferId1: dw 0x0000 ; targetBufferId
041585             0483*   ; VDU 23,27,&21,width%;height%;0
041585 17 1B 21    0484*       db 23,27,0x21 ; create bitmap from buffer
041588 00 00       0485*   @width: dw 0x0000
04158A 00 00       0486*   @height: dw 0x0000
04158C 00          0487*       db 0x00 ; rgba8888 format
04158D             0488*   @end:
04158D             0489*   
04158D             0490*   ; scratch variables
04158D 00 00 00    0491*   bufferId0: dl 0x000000
041590 00 00 00    0492*   bufferId1: dl 0x000000
041593             0493*   
041593             0494*   ; load a vdu buffer from local memory
041593             0495*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041593             0496*   vdu_load_buffer:
041593 ED 43 BC 15 0497*       ld (@length),bc
       04          
041598 D5          0498*       push de ; save data pointer
041599             0499*   ; send the vdu command string
041599 7D          0500*       ld a,l
04159A 32 B9 15 04 0501*       ld (@bufferId),a
04159E 7C          0502*       ld a,h
04159F 32 BA 15 04 0503*       ld (@bufferId+1),a
0415A3 21 B6 15 04 0504*       ld hl,@cmd
0415A7 01 08 00 00 0505*       ld bc,@end-@cmd
0415AB 5B DF       0506*       rst.lil $18
0415AD             0507*   ; send the buffer data
0415AD E1          0508*       pop hl ; pointer to data
0415AE ED 4B BC 15 0509*       ld bc,(@length)
       04          
0415B3 5B DF       0510*       rst.lil $18 ; send it
0415B5 C9          0511*       ret
0415B6             0512*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0415B6 17 00 A0    0513*   @cmd:       db 23,0,0xA0
0415B9 00 00       0514*   @bufferId:	dw 0x0000
0415BB 00          0515*   		    db 0 ; load buffer
0415BC 00 00       0516*   @length:	dw 0x0000
0415BE 00          0517*   @end: db 0 ; padding
0415BF             0518*   
0415BF             0519*   ; Command 14: Consolidate blocks in a buffer
0415BF             0520*   vdu_consolidate_buffer:
0415BF             0521*   ; set parameters for vdu call
0415BF 7D          0522*       ld a,l
0415C0 32 D7 15 04 0523*       ld (@bufferId),a
0415C4 7C          0524*       ld a,h
0415C5 32 D8 15 04 0525*       ld (@bufferId+1),a
0415C9 21 D4 15 04 0526*       ld hl,@beg
0415CD 01 06 00 00 0527*       ld bc,@end-@beg
0415D1 5B DF       0528*       rst.lil $18
0415D3 C9          0529*       ret
0415D4             0530*   ; VDU 23, 0, &A0, bufferId; 14
0415D4 17 00 A0    0531*   @beg: db 23,0,0xA0
0415D7 00 00       0532*   @bufferId: dw 0x0000
0415D9 0E          0533*              db 14
0415DA             0534*   @end:
0415DA             0535*   
0415DA             0536*   ; load an image file to a buffer and make it a bitmap
0415DA             0537*   ; inputs: a = image format ; bc,de image width,height ; hl = bufferId ; iy = pointer to filename
0415DA             0538*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0415DA             0539*   ; 0 	RGBA8888 (4-bytes per pixel)
0415DA             0540*   ; 1 	RGBA2222 (1-bytes per pixel)
0415DA             0541*   ; 2 	Mono/Mask (1-bit per pixel)
0415DA             0542*   ; 3 	Reserved for internal use by VDP (“native” format)
0415DA             0543*   vdu_load_img:
0415DA             0544*   ; back up image type and dimension parameters
0415DA 22 8D 15 04 0545*       ld (bufferId0),hl
0415DE F5          0546*       push af
0415DF C5          0547*   	push bc
0415E0 D5          0548*   	push de
0415E1             0549*   ; load the image
0415E1 CD FC 15 04 0550*   	call vdu_load_buffer_from_file
0415E5             0551*   ; now make it a bitmap
0415E5 2A 8D 15 04 0552*       ld hl,(bufferId0)
0415E9 CD BF 15 04 0553*       call vdu_consolidate_buffer
0415ED 2A 8D 15 04 0554*       ld hl,(bufferId0)
0415F1 CD E8 14 04 0555*       call vdu_buff_select
0415F5 D1          0556*   	pop de ; image height
0415F6 C1          0557*   	pop bc ; image width
0415F7 F1          0558*   	pop af ; image type
0415F8 C3 FD 14 04 0559*   	jp vdu_bmp_create ; will return to caller from there
0415FC             0560*   
0415FC             0561*   ; inputs: hl = bufferId; iy = pointer to filename
0415FC             0562*   vdu_load_buffer_from_file:
0415FC 22 8D 15 04 0563*       ld (bufferId0),hl
041600             0564*   
041600             0565*   ; clear target buffer
041600 CD A8 17 04 0566*       call vdu_clear_buffer
041604             0567*   
041604             0568*   ; open the file in read mode
041604             0569*   ; Open a file
041604             0570*   ; HLU: Filename
041604             0571*   ;   C: Mode
041604             0572*   ; Returns:
041604             0573*   ;   A: Filehandle, or 0 if couldn't open
041604 FD E5       0574*   	push iy ; pointer to filename
041606 E1          0575*   	pop hl
041607 0E 01       0576*   	ld c,fa_read
041609             0577*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
041609 3E 0A       0001*M1 			LD	A, function
04160B 5B CF       0002*M1 			RST.LIL	08h
04160D 32 48 16 04 0578*       ld (@filehandle),a
041611             0579*   
041611             0580*   @read_file:
041611             0581*   ; Read a block of data from a file
041611             0582*   ;   C: Filehandle
041611             0583*   ; HLU: Pointer to where to write the data to
041611             0584*   ; DEU: Number of bytes to read
041611             0585*   ; Returns:
041611             0586*   ; DEU: Number of bytes read
041611 3A 48 16 04 0587*       ld a,(@filehandle)
041615 4F          0588*       ld c,a
041616 21 00 26 04 0589*       ld hl,filedata
04161A 11 00 20 00 0590*       ld de,8192 ; max we can read into onboard sram at one time
04161E             0591*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
04161E 3E 1A       0001*M1 			LD	A, function
041620 5B CF       0002*M1 			RST.LIL	08h
041622             0592*   
041622             0593*   ; test de for zero bytes read
041622 21 00 00 00 0594*       ld hl,0
041626 AF          0595*       xor a ; clear carry
041627 ED 52       0596*       sbc hl,de
041629 CA 3F 16 04 0597*       jp z,@close_file
04162D             0598*   
04162D             0599*   ; load a vdu buffer from local memory
04162D             0600*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04162D 2A 8D 15 04 0601*       ld hl,(bufferId0)
041631 D5          0602*       push de ; chunksize
041632 C1          0603*       pop bc
041633 11 00 26 04 0604*       ld de,filedata
041637 CD 93 15 04 0605*       call vdu_load_buffer
04163B             0606*   
04163B             0607*   ; read the next block
04163B C3 11 16 04 0608*       jp @read_file
04163F             0609*   
04163F             0610*   ; close the file
04163F             0611*   @close_file:
04163F 3A 48 16 04 0612*       ld a,(@filehandle)
041643             0613*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
041643 3E 0B       0001*M1 			LD	A, function
041645 5B CF       0002*M1 			RST.LIL	08h
041647 C9          0614*       ret ; vdu_load_buffer_from_file
041648             0615*   
041648 00          0616*   @filehandle: db 0 ; file handle
041649 00 00 00    0617*   @fil: dl 0 ; pointer to FIL struct
04164C             0618*   
04164C 00 00 00    0619*   @chunkpointer: dl 0 ; pointer to current chunk
04164F             0620*   
04164F             0621*   ; File information structure (FILINFO)
04164F             0622*   @filinfo:
04164F 00 00 00 00 0623*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041653 00 00       0624*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041655 00 00       0625*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041657 00          0626*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041658 00 00 00 00 0627*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041665 00 00 00 00 0628*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041765             0036        include "../include/vdu_buffered_api.inc"
041765             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
041765             0002*   
041765             0003*   ; Command 0: Write block to a buffer
041765             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
041765             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
041765             0006*   vdu_write_block_to_buffer:
041765             0007*   ; back up input parameters
041765 D5          0008*       push de ; pointer to data
041766 C5          0009*       push bc ; length of data
041767             0010*   ; set up the vdu command string
041767 22 87 17 04 0011*       ld (@bufferId),hl
04176B ED 43 8A 17 0012*       ld (@length),bc
       04          
041770 AF          0013*       xor a ; load buffer
041771 32 89 17 04 0014*       ld (@bufferId+2),a
041775 21 84 17 04 0015*       ld hl,@cmd0
041779 01 08 00 00 0016*       ld bc,@end0-@cmd0
04177D 5B DF       0017*       rst.lil $18
04177F             0018*   ; send the buffer data
04177F C1          0019*       pop bc ; length of data
041780 E1          0020*       pop hl ; pointer to data (was de)
041781 5B DF       0021*       rst.lil $18 ; send it
041783 C9          0022*       ret
041784             0023*   ; command string data
041784 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
041787 00 00       0025*   @bufferId:	dw 0x0000
041789 00          0026*               db 0 ; load buffer
04178A 00 00       0027*   @length:	dw 0x0000
04178C 00          0028*   @end0:      db 0x00 ; padding
04178D             0029*   ; end vdu_write_block_to_buffer
04178D             0030*   
04178D             0031*   ; Command 1: Call a buffer
04178D             0032*   ; VDU 23, 0, &A0, bufferId; 1
04178D             0033*   ; inputs: hl = bufferId
04178D             0034*   vdu_call_buffer:
04178D 22 A5 17 04 0035*       ld (@bufferId),hl
041791 3E 01       0036*       ld a,1 ; call buffer
041793 32 A7 17 04 0037*       ld (@bufferId+2),a
041797 21 A2 17 04 0038*       ld hl,@cmd
04179B 01 06 00 00 0039*       ld bc,@end-@cmd
04179F 5B DF       0040*       rst.lil $18
0417A1 C9          0041*       ret
0417A2 17 00 A0    0042*   @cmd:     db 23,0,0xA0
0417A5 00 00       0043*   @bufferId: dw 0x0000
0417A7 01          0044*              db 1 ; call buffer
0417A8             0045*   @end:
0417A8             0046*   ; end vdu_call_buffer
0417A8             0047*   
0417A8             0048*   ; Command 2: Clear a buffer
0417A8             0049*   ; VDU 23, 0 &A0, bufferId; 2
0417A8             0050*   ; inputs: hl = bufferId
0417A8             0051*   vdu_clear_buffer:
0417A8 22 C0 17 04 0052*       ld (@bufferId),hl
0417AC 3E 02       0053*       ld a,2 ; clear buffer
0417AE 32 C2 17 04 0054*       ld (@bufferId+2),a
0417B2 21 BD 17 04 0055*       ld hl,@cmd
0417B6 01 06 00 00 0056*       ld bc,@end-@cmd
0417BA 5B DF       0057*       rst.lil $18
0417BC C9          0058*       ret
0417BD 17 00 A0    0059*   @cmd:     db 23,0,0xA0
0417C0 00 00       0060*   @bufferId: dw 0x0000
0417C2 02          0061*              db 2 ; clear buffer
0417C3             0062*   @end:
0417C3             0063*   ; end vdu_clear_buffer
0417C3             0064*   
0417C3             0065*   ; Clear all buffers
0417C3             0066*   ; inputs: none
0417C3             0067*   vdu_clear_all_buffers:
0417C3             0068*   ; clear all buffers
0417C3 21 CE 17 04 0069*       ld hl,@beg
0417C7 01 06 00 00 0070*       ld bc,@end-@beg
0417CB 5B DF       0071*       rst.lil $18
0417CD C9          0072*       ret
0417CE 17 00 A0    0073*   @beg: db 23,0,$A0
0417D1 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
0417D3 02          0075*         db 2  ; command 2: clear a buffer
0417D4             0076*   @end:
0417D4             0077*   ; end vdu_clear_all_buffers
0417D4             0078*   
0417D4             0079*   ; Command 3: Create a writeable buffer
0417D4             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
0417D4             0081*   ; inputs: hl = bufferId, bc = length
0417D4             0082*   vdu_create_writeable_buffer:
0417D4 22 F1 17 04 0083*       ld (@bufferId),hl
0417D8 ED 43 F4 17 0084*       ld (@length),bc
       04          
0417DD 3E 03       0085*       ld a,3 ; create writeable buffer
0417DF 32 F3 17 04 0086*       ld (@bufferId+2),a
0417E3 21 EE 17 04 0087*       ld hl,@cmd
0417E7 01 08 00 00 0088*       ld bc,@end-@cmd
0417EB 5B DF       0089*       rst.lil $18
0417ED C9          0090*       ret
0417EE 17 00 A0    0091*   @cmd:     db 23,0,0xA0
0417F1 00 00       0092*   @bufferId: dw 0x0000
0417F3 03          0093*              db 3 ; create writeable buffer
0417F4 00 00       0094*   @length: dw 0x0000
0417F6 00          0095*   @end:     db 0x00 ; padding
0417F7             0096*   ; end vdu_create_writeable_buffer
0417F7             0097*   
0417F7             0098*   ; Command 4: Set output stream to a buffer
0417F7             0099*   ; VDU 23, 0 &A0, bufferId; 4
0417F7             0100*   ; inputs: hl = bufferId
0417F7             0101*   vdu_set_output_stream_buffer:
0417F7 22 0F 18 04 0102*       ld (@bufferId),hl
0417FB 3E 04       0103*       ld a,4 ; set output stream to buffer
0417FD 32 11 18 04 0104*       ld (@bufferId+2),a
041801 21 0C 18 04 0105*       ld hl,@cmd
041805 01 06 00 00 0106*       ld bc,@end-@cmd
041809 5B DF       0107*       rst.lil $18
04180B C9          0108*       ret
04180C 17 00 A0    0109*   @cmd:     db 23,0,0xA0
04180F 00 00       0110*   @bufferId: dw 0x0000
041811 04          0111*              db 4 ; set output stream to buffer
041812 00          0112*   @end:     db 0x00 ; padding
041813             0113*   ; end vdu_set_output_stream_buffer
041813             0114*   
041813             0115*   ; Command 5: Adjust buffer contents
041813             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041813             0117*   vdu_adjust_buffer:
041813 C9          0118*       ret ; TODO: implement
041814             0119*   ; end vdu_adjust_buffer
041814             0120*   
041814             0121*   ; Command 6: Conditionally call a buffer
041814             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041814             0123*   vdu_call_buffer_conditional:
041814 C9          0124*       ret ; TODO: implement
041815             0125*   ; end vdu_call_buffer_conditional
041815             0126*   
041815             0127*   ; Command 7: Jump to a buffer
041815             0128*   ; VDU 23, 0, &A0, bufferId; 7
041815             0129*   ; inputs: hl = bufferId
041815             0130*   vdu_jump_to_buffer:
041815 22 2D 18 04 0131*       ld (@bufferId),hl
041819 3E 07       0132*       ld a,7 ; jump to buffer
04181B 32 2F 18 04 0133*       ld (@bufferId+2),a
04181F 21 2A 18 04 0134*       ld hl,@cmd
041823 01 06 00 00 0135*       ld bc,@end-@cmd
041827 5B DF       0136*       rst.lil $18
041829 C9          0137*       ret
04182A 17 00 A0    0138*   @cmd:     db 23,0,0xA0
04182D 00 00       0139*   @bufferId: dw 0x0000
04182F 07          0140*              db 7 ; jump to buffer
041830 00          0141*   @end:     db 0x00 ; padding
041831             0142*   ; end vdu_jump_to_buffer
041831             0143*   
041831             0144*   ; Command 8: Conditional Jump to a buffer
041831             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041831             0146*   vdu_jump_to_buffer_conditional:
041831 C9          0147*       ret ; TODO: implement
041832             0148*   ; end vdu_jump_to_buffer_conditional
041832             0149*   
041832             0150*   ; Command 9: Jump to an offset in a buffer
041832             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041832             0152*   vdu_jump_to_buffer_offset:
041832 C9          0153*       ret ; TODO: implement
041833             0154*   ; end vdu_jump_to_buffer_offset
041833             0155*   
041833             0156*   ; Command 10: Conditional jump to an offset in a buffer
041833             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041833             0158*   vdu_jump_to_buffer_offset_conditional:
041833 C9          0159*       ret ; TODO: implement
041834             0160*   ; end vdu_jump_to_buffer_offset_conditional
041834             0161*   
041834             0162*   ; Command 11: Call buffer with an offset
041834             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041834             0164*   vdu_call_buffer_offset:
041834 C9          0165*       ret ; TODO: implement
041835             0166*   ; end vdu_call_buffer_offset
041835             0167*   
041835             0168*   ; Command 23: Set affine transforms test flag
041835             0169*   ; VDU 23, 0, &F8, 1; 1;
041835             0170*   ; inputs: none
041835             0171*   vdu_enable_transforms:
041835 21 40 18 04 0172*       ld hl,@cmd
041839 01 07 00 00 0173*       ld bc,@end-@cmd
04183D 5B DF       0174*       rst.lil $18
04183F C9          0175*       ret
041840 17 00 F8    0176*   @cmd:   db 23,0,0xF8
041843 01 00       0177*           dw 1 ; magic number
041845 01 00       0178*           dw 1 ; ditto
041847             0179*   @end:
041847             0180*   ; end vdu_enable_transforms
041847             0181*   
041847             0182*   ; Command 32: Create or manipulate a 2D affine transformation matrix
041847             0183*   ; VDU 23, 0, &A0, bufferId; 32, operation, [<format>, <arguments...>]
041847             0184*   ; inputs: a = operation, hl = bufferId, de = pointer to arguments, bc = length of arguments, ixl = format
041847             0185*   vdu_do_2d_matrix_transform:
041847 F5          0186*       push af ; save operation
041848 C5          0187*       push bc ; length of arguments
041849 D5          0188*       push de ; pointer to arguments
04184A 32 77 18 04 0189*       ld (@operation),a
04184E 7D          0190*       ld a,l
04184F 32 74 18 04 0191*       ld (@bufferId+0),a
041853 7C          0192*       ld a,h
041854 32 75 18 04 0193*       ld (@bufferId+1),a
041858 DD 7D       0194*       ld a,ixl
04185A 32 78 18 04 0195*       ld (@format),a
04185E 21 71 18 04 0196*       ld hl,@cmd
041862 01 08 00 00 0197*       ld bc,@end-@cmd
041866 5B DF       0198*       rst.lil $18
041868 E1          0199*       pop hl ; pointer to arguments (was de)
041869 C1          0200*       pop bc ; length of arguments
04186A F1          0201*       pop af ; restore operation
04186B FE 01       0202*       cp 1 ; if > 1, send the arguments
04186D D8          0203*       ret c ; no arguments
04186E 5B DF       0204*       rst.lil $18 ; send the arguments
041870 C9          0205*       ret
041871 17 00 A0    0206*   @cmd:       db 23,0,0xA0
041874 00 00       0207*   @bufferId:  dw 0x0000
041876 20          0208*               db 32 ; create transform matrix
041877 00          0209*   @operation: db 0x00
041878 00          0210*   @format:    db 0x00
041879             0211*   @end:
041879             0212*   ; end vdu_do_2d_matrix_transform
041879             0213*   
041879             0214*   ; Command 33: Create or manipulate a 3D affine transformation matrix
041879             0215*   ; VDU 23, 0, &A0, bufferId; 33, operation, [<format>, <arguments...>]
041879             0216*   ; inputs: a = operation, hl = bufferId, de = pointer to arguments, bc = length of arguments, ixl = format
041879             0217*   vdu_do_3d_matrix_transform:
041879 F5          0218*       push af ; save operation
04187A C5          0219*       push bc ; length of arguments
04187B D5          0220*       push de ; pointer to arguments
04187C 32 A9 18 04 0221*       ld (@operation),a
041880 7D          0222*       ld a,l
041881 32 A6 18 04 0223*       ld (@bufferId+0),a
041885 7C          0224*       ld a,h
041886 32 A7 18 04 0225*       ld (@bufferId+1),a
04188A DD 7D       0226*       ld a,ixl
04188C 32 AA 18 04 0227*       ld (@format),a
041890 21 A3 18 04 0228*       ld hl,@cmd
041894 01 08 00 00 0229*       ld bc,@end-@cmd
041898 5B DF       0230*       rst.lil $18
04189A E1          0231*       pop hl ; pointer to arguments (was de)
04189B C1          0232*       pop bc ; length of arguments
04189C F1          0233*       pop af ; restore operation
04189D FE 01       0234*       cp 1 ; if > 1, send the arguments
04189F D8          0235*       ret c ; no arguments
0418A0 5B DF       0236*       rst.lil $18 ; send the arguments
0418A2 C9          0237*       ret
0418A3 17 00 A0    0238*   @cmd:       db 23,0,0xA0
0418A6 00 00       0239*   @bufferId:  dw 0x0000
0418A8 21          0240*               db 33 ; manipulate transform matrix
0418A9 00          0241*   @operation: db 0x00
0418AA 00          0242*   @format:    db 0x00
0418AB             0243*   @end:
0418AB             0244*   ; end vdu_do_3d_matrix_transform
0418AB             0245*   
0418AB             0246*   ; Command 40: Create a transformed bitmap
0418AB             0247*   ; VDU 23, 0, &A0, bufferId; 40, options, transformBufferId; sourceBitmapId; [width; height;]
0418AB             0248*   ; inputs a = options, de = bufferId, bc = transformBufferId, hl = sourceBitmapId, ix = width, iy = height
0418AB             0249*   ; options:
0418AB             0250*   ; Bit value Arguments       Description
0418AB             0251*   ; 1 		                Target bitmap should be resized. When not set, target will be same dimensions as the original bitmap.
0418AB             0252*   ; 2 	    width; height; 	Target bitmap will be resized to explicitly given dimensions
0418AB             0253*   ; 4 Automatically translate target bitmap position. When set the calculated transformed minimum x,y coordinates will be placed at the top left of the target
0418AB             0254*   vdu_transform_bitmap:
0418AB F5          0255*       push af ; save options
0418AC 32 EC 18 04 0256*       ld (@options),a
0418B0 7B          0257*       ld a,e
0418B1 32 E9 18 04 0258*       ld (@bufferId+0),a
0418B5 7A          0259*       ld a,d
0418B6 32 EA 18 04 0260*       ld (@bufferId+1),a
0418BA ED 43 ED 18 0261*       ld (@transformBufferId),bc
       04          
0418BF 22 EF 18 04 0262*       ld (@sourceBitmapId),hl
0418C3 21 E6 18 04 0263*       ld hl,@cmd
0418C7 01 0B 00 00 0264*       ld bc,@end-@cmd
0418CB 5B DF       0265*       rst.lil $18
0418CD F1          0266*       pop af ; restore options
0418CE CB 57       0267*       bit 2,a ; check resize bit
0418D0 C8          0268*       ret z
0418D1 DD 22 F2 18 0269*       ld (@width),ix
       04          
0418D6 FD 22 F4 18 0270*       ld (@height),iy
       04          
0418DB 21 F2 18 04 0271*       ld hl,@width
0418DF 01 04 00 00 0272*       ld bc,4
0418E3 5B DF       0273*       rst.lil $18
0418E5 C9          0274*       ret
0418E6 17 00 A0    0275*   @cmd:       db 23,0,0xA0
0418E9 00 00       0276*   @bufferId:  dw 0x0000
0418EB 28          0277*               db 40 ; create transformed bitmap
0418EC 00          0278*   @options:   db 0x00
0418ED 00 00       0279*   @transformBufferId: dw 0x0000
0418EF 00 00       0280*   @sourceBitmapId:    dw 0x0000
0418F1 00          0281*   @end:       db 0x00 ; padding
0418F2             0282*   ; these are only included when bit 2 of options (resize) is set
0418F2 00 00       0283*   @width:     dw 0x0000
0418F4 00 00       0284*   @height:    dw 0x0000
0418F6 00          0285*               db 0x00 ; padding
0418F7             0286*   ; end vdu_transform_bitmap
0418F7             0287*   
0418F7             0288*   ; Command 64: Compress a buffer
0418F7             0289*   ; VDU 23, 0, &A0, targetBufferId; 64, sourceBufferId;
0418F7             0290*   ; inputs: hl = sourceBufferId, de = targetBufferId
0418F7             0291*   vdu_compress_buffer:
0418F7 22 17 19 04 0292*       ld (@sourceBufferId),hl
0418FB ED 53 14 19 0293*       ld (@targetBufferId),de
       04          
041900 3E 40       0294*       ld a,64 ; compress buffer
041902 32 16 19 04 0295*       ld (@sourceBufferId-1),a
041906 21 11 19 04 0296*       ld hl,@cmd
04190A 01 08 00 00 0297*       ld bc,@end-@cmd
04190E 5B DF       0298*       rst.lil $18
041910 C9          0299*       ret
041911 17 00 A0    0300*   @cmd:     db 23,0,0xA0
041914 00 00       0301*   @targetBufferId: dw 0x0000
041916 40          0302*              db 64 ; compress buffer
041917 00 00       0303*   @sourceBufferId: dw 0x0000
041919 00          0304*   @end:     db 0x00 ; padding
04191A             0305*   
04191A             0306*   
04191A             0307*   ; Command 65: Decompress a buffer
04191A             0308*   ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
04191A             0309*   ; inputs: hl = sourceBufferId, de = targetBufferId
04191A             0310*   vdu_decompress_buffer:
04191A 22 3A 19 04 0311*       ld (@sourceBufferId),hl
04191E ED 53 37 19 0312*       ld (@targetBufferId),de
       04          
041923 3E 41       0313*       ld a,65 ; decompress buffer
041925 32 39 19 04 0314*       ld (@sourceBufferId-1),a
041929 21 34 19 04 0315*       ld hl,@cmd
04192D 01 08 00 00 0316*       ld bc,@end-@cmd
041931 5B DF       0317*       rst.lil $18
041933 C9          0318*       ret
041934 17 00 A0    0319*   @cmd:     db 23,0,0xA0
041937 00 00       0320*   @targetBufferId: dw 0x0000
041939 41          0321*              db 65 ; decompress buffer
04193A 00 00       0322*   @sourceBufferId: dw 0x0000
04193C 00          0323*   @end:     db 0x00 ; padding
04193D             0037        include "../include/vdu_plot.inc"
04193D             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04193D             0002*   ; PLOT code 	(Decimal) 	Effect
04193D             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
04193D             0004*   plot_sl_both: equ 0x00
04193D             0005*   
04193D             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
04193D             0007*   plot_sl_first: equ 0x08
04193D             0008*   
04193D             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
04193D             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
04193D             0011*   
04193D             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
04193D             0013*   plot_sl_last: equ 0x20
04193D             0014*   
04193D             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
04193D             0016*   plot_sl_none: equ 0x28
04193D             0017*   
04193D             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
04193D             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
04193D             0020*   
04193D             0021*   ; &40-&47 	64-71 	Point plot
04193D             0022*   plot_pt: equ 0x40
04193D             0023*   
04193D             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
04193D             0025*   plot_lf_lr_non_bg: equ 0x48
04193D             0026*   
04193D             0027*   ; &50-&57 	80-87 	Triangle fill
04193D             0028*   plot_tf: equ 0x50
04193D             0029*   
04193D             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
04193D             0031*   plot_lf_r_bg: equ 0x58
04193D             0032*   
04193D             0033*   ; &60-&67 	96-103 	Rectangle fill
04193D             0034*   plot_rf: equ 0x60
04193D             0035*   
04193D             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
04193D             0037*   plot_lf_lr_fg: equ 0x60
04193D             0038*   
04193D             0039*   ; &70-&77 	112-119 	Parallelogram fill
04193D             0040*   plot_pf: equ 0x70
04193D             0041*   
04193D             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
04193D             0043*   plot_lf_r_non_fg: equ 0x78
04193D             0044*   
04193D             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
04193D             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
04193D             0047*   
04193D             0048*   ; &90-&97 	144-151 	Circle outline
04193D             0049*   plot_co: equ 0x90
04193D             0050*   
04193D             0051*   ; &98-&9F 	152-159 	Circle fill
04193D             0052*   plot_cf: equ 0x98
04193D             0053*   
04193D             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
04193D             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
04193D             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
04193D             0057*   
04193D             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
04193D             0059*   plot_rcm: equ 0xB8
04193D             0060*   
04193D             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
04193D             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
04193D             0063*   ; &D0-&D7 	208-215 	Not defined
04193D             0064*   ; &D8-&DF 	216-223 	Not defined
04193D             0065*   ; &E0-&E7 	224-231 	Not defined
04193D             0066*   
04193D             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
04193D             0068*   plot_bmp: equ 0xE8
04193D             0069*   
04193D             0070*   ; &F0-&F7 	240-247 	Not defined
04193D             0071*   ; &F8-&FF 	248-255 	Not defined
04193D             0072*   
04193D             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
04193D             0074*   ; Agon Console8 VDP 2.2.0
04193D             0075*   
04193D             0076*   ; Within each group of eight plot codes, the effects are as follows:
04193D             0077*   ; Plot code 	Effect
04193D             0078*   ; 0 	Move relative
04193D             0079*   mv_rel: equ 0
04193D             0080*   
04193D             0081*   ; 1 	Plot relative in current foreground colour
04193D             0082*   dr_rel_fg: equ 1
04193D             0083*   
04193D             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
04193D             0085*   ; 3 	Plot relative in current background colour
04193D             0086*   dr_rel_bg: equ 3
04193D             0087*   
04193D             0088*   ; 4 	Move absolute
04193D             0089*   mv_abs: equ 4
04193D             0090*   
04193D             0091*   ; 5 	Plot absolute in current foreground colour
04193D             0092*   dr_abs_fg: equ 5
04193D             0093*   
04193D             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
04193D             0095*   ; 7 	Plot absolute in current background colour
04193D             0096*   dr_abs_bg: equ 7
04193D             0097*   
04193D             0098*   ; Codes 0-3 use the position data provided as part of the command
04193D             0099*   ; as a relative position, adding the position given to the current
04193D             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
04193D             0101*   ; as part of the command as an absolute position, setting the current
04193D             0102*   ; graphical cursor position to the position given.
04193D             0103*   
04193D             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
04193D             0105*   ; current pixel colour. These operations cannot currently be supported
04193D             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
04193D             0107*   ; supported. Support for these codes may be added in a future version
04193D             0108*   ; of the VDP firmware.
04193D             0109*   
04193D             0110*   ; 16 colour palette constants
04193D             0111*   c_black: equ 0
04193D             0112*   c_red_dk: equ 1
04193D             0113*   c_green_dk: equ 2
04193D             0114*   c_yellow_dk: equ 3
04193D             0115*   c_blue_dk: equ 4
04193D             0116*   c_magenta_dk: equ 5
04193D             0117*   c_cyan_dk: equ 6
04193D             0118*   c_grey: equ 7
04193D             0119*   c_grey_dk: equ 8
04193D             0120*   c_red: equ 9
04193D             0121*   c_green: equ 10
04193D             0122*   c_yellow: equ 11
04193D             0123*   c_blue: equ 12
04193D             0124*   c_magenta: equ 13
04193D             0125*   c_cyan: equ 14
04193D             0126*   c_white: equ 15
04193D             0127*   
04193D             0128*   ; GCOL paint modes
04193D             0129*   ; The GCOL command (VDU 18, mode, colour) is used to set the paint mode for the PLOT
04193D             0130*   ; command. The paint mode is used to control how the PLOT command interacts with the
04193D             0131*   ; existing pixels on the screen.
04193D             0132*   gcol_mode_col: equ %000000000 ; Set on-screen pixel to target colour value
04193D             0133*   gcol_mode_or: equ %000000001 ; OR value with the on-screen pixel
04193D             0134*   gcol_mode_and: equ %000000010 ; AND value with the on-screen pixel
04193D             0135*   gcol_mode_xor: equ %000000011 ; EOR value with the on-screen pixel
04193D             0136*   gcol_mode_inv: equ %000000100 ; Invert the on-screen pixel
04193D             0137*   gcol_mode_non: equ %000000101 ; No operation
04193D             0138*   gcol_mode_and_inv: equ %000000110 ; AND the inverse of the specified colour with the on-screen pixel
04193D             0139*   gcol_mode_or_inv: equ %000000111 ; OR the inverse of the specified colour with the on-screen pixel
04193D             0140*   
04193D             0141*   ; VDU 25, mode, x; y;: PLOT command
04193D             0142*   ; inputs: a=mode, bc=x0, de=y0
04193D             0143*   vdu_plot:
04193D 32 57 19 04 0144*       ld (@mode),a
041941 ED 43 58 19 0145*       ld (@x0),bc
       04          
041946 ED 53 5A 19 0146*       ld (@y0),de
       04          
04194B 21 56 19 04 0147*   	ld hl,@cmd
04194F 01 06 00 00 0148*   	ld bc,@end-@cmd
041953 5B DF       0149*   	rst.lil $18
041955 C9          0150*   	ret
041956 19          0151*   @cmd:   db 25
041957 00          0152*   @mode:  db 0
041958 00 00       0153*   @x0: 	dw 0
04195A 00 00       0154*   @y0: 	dw 0
04195C 00          0155*   @end:   db 0 ; extra byte to soak up deu
04195D             0156*   
04195D             0157*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04195D             0158*   ; &E8-&EF 	232-239 	Bitmap plot §
04195D             0159*   ; VDU 25, mode, x; y;: PLOT command
04195D             0160*   ; inputs: bc=x0, de=y0
04195D             0161*   ; prerequisites: vdu_buff_select
04195D             0162*   vdu_plot_bmp:
04195D ED 43 74 19 0163*       ld (@x0),bc
       04          
041962 ED 53 76 19 0164*       ld (@y0),de
       04          
041967 21 72 19 04 0165*   	ld hl,@cmd
04196B 01 06 00 00 0166*   	ld bc,@end-@cmd
04196F 5B DF       0167*   	rst.lil $18
041971 C9          0168*   	ret
041972 19          0169*   @cmd:   db 25
041973 ED          0170*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041974 00 00       0171*   @x0: 	dw 0x0000
041976 00 00       0172*   @y0: 	dw 0x0000
041978 00          0173*   @end:   db 0x00 ; padding
041979             0174*   
041979             0175*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041979             0176*   ; &E8-&EF 	232-239 	Bitmap plot §
041979             0177*   ; VDU 25, mode, x; y;: PLOT command
041979             0178*   ; inputs: bc=x0, de=y0
041979             0179*   ; USING 16.8 FIXED POINT COORDINATES
041979             0180*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
041979             0181*   ;   the fractional portiion of the inputs are truncated
041979             0182*   ;   leaving only the 16-bit integer portion
041979             0183*   ; prerequisites: vdu_buff_select
041979             0184*   vdu_plot_bmp168:
041979             0185*   ; populate in the reverse of normal to keep the
041979             0186*   ; inputs from stomping on each other
041979 ED 53 97 19 0187*       ld (@y0-1),de
       04          
04197E ED 43 95 19 0188*       ld (@x0-1),bc
       04          
041983 3E ED       0189*       ld a,plot_bmp+dr_abs_fg ; 0xED
041985 32 95 19 04 0190*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
041989 21 94 19 04 0191*   	ld hl,@cmd
04198D 01 06 00 00 0192*   	ld bc,@end-@cmd
041991 5B DF       0193*   	rst.lil $18
041993 C9          0194*   	ret
041994 19          0195*   @cmd:   db 25
041995 ED          0196*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041996 00 00       0197*   @x0: 	dw 0x0000
041998 00 00       0198*   @y0: 	dw 0x0000
04199A             0199*   @end:  ; no padding required b/c we shifted de right
04199A             0200*   
04199A             0201*   ; draw a filled rectangle
04199A             0202*   vdu_plot_rf:
04199A ED 43 C1 19 0203*       ld (@x0),bc
       04          
04199F ED 53 C3 19 0204*       ld (@y0),de
       04          
0419A4 DD 22 C7 19 0205*       ld (@x1),ix
       04          
0419A9 FD 22 C9 19 0206*       ld (@y1),iy
       04          
0419AE 3E 19       0207*       ld a,25 ; we have to reload the 2nd plot command
0419B0 32 C5 19 04 0208*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0419B4 21 BF 19 04 0209*   	ld hl,@cmd0
0419B8 01 0C 00 00 0210*   	ld bc,@end-@cmd0
0419BC 5B DF       0211*   	rst.lil $18
0419BE C9          0212*       ret
0419BF 19          0213*   @cmd0:  db 25 ; plot
0419C0 04          0214*   @arg0:  db plot_sl_both+mv_abs
0419C1 00 00       0215*   @x0:    dw 0x0000
0419C3 00 00       0216*   @y0:    dw 0x0000
0419C5 19          0217*   @cmd1:  db 25 ; plot
0419C6 65          0218*   @arg1:  db plot_rf+dr_abs_fg
0419C7 00 00       0219*   @x1:    dw 0x0000
0419C9 00 00       0220*   @y1:    dw 0x0000
0419CB 00          0221*   @end:   db 0x00 ; padding
0419CC             0222*   
0419CC             0223*   ; draw a filled circle
0419CC             0224*   vdu_plot_cf:
0419CC ED 43 F3 19 0225*       ld (@x0),bc
       04          
0419D1 ED 53 F5 19 0226*       ld (@y0),de
       04          
0419D6 DD 22 F9 19 0227*       ld (@x1),ix
       04          
0419DB FD 22 FB 19 0228*       ld (@y1),iy
       04          
0419E0 3E 19       0229*       ld a,25 ; we have to reload the 2nd plot command
0419E2 32 F7 19 04 0230*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0419E6 21 F1 19 04 0231*   	ld hl,@cmd0
0419EA 01 0C 00 00 0232*   	ld bc,@end-@cmd0
0419EE 5B DF       0233*   	rst.lil $18
0419F0 C9          0234*       ret
0419F1 19          0235*   @cmd0:  db 25 ; plot
0419F2 04          0236*   @arg0:  db plot_sl_both+mv_abs
0419F3 00 00       0237*   @x0:    dw 0x0000
0419F5 00 00       0238*   @y0:    dw 0x0000
0419F7 19          0239*   @cmd1:  db 25 ; plot
0419F8 9D          0240*   @arg1:  db plot_cf+dr_abs_fg
0419F9 00 00       0241*   @x1:    dw 0x0000
0419FB 00 00       0242*   @y1:    dw 0x0000
0419FD 00          0243*   @end:   db 0x00 ; padding
0419FE             0244*   
0419FE             0245*   ; draw an unfilled rectangle
0419FE             0246*   vdu_plot_rect:
0419FE 21 09 1A 04 0247*       ld hl,@cmd
041A02 01 1E 00 00 0248*       ld bc,@end-@cmd
041A06 5B DF       0249*       rst.lil $18
041A08 C9          0250*       ret
041A09             0251*   @cmd:
041A09 19 04       0252*       db 25,mv_abs
041A0B 00 00       0253*       dw 0 ; x upper left
041A0D 00 00       0254*       dw 0 ; y upper left
041A0F 19 05       0255*       db 25,plot_sl_both+dr_abs_fg
041A11 40 01       0256*       dw 320 ; x upper right
041A13 00 00       0257*       dw 0 ; y upper right
041A15 19 05       0258*       db 25,plot_sl_both+dr_abs_fg
041A17 40 01       0259*       dw 320 ; x lower right
041A19 F0 00       0260*       dw 240 ; y lower right
041A1B 19 05       0261*       db 25,plot_sl_both+dr_abs_fg
041A1D 00 00       0262*       dw 0 ; x lower left
041A1F F0 00       0263*       dw 240 ; y lower left
041A21 19 05       0264*       db 25,plot_sl_both+dr_abs_fg
041A23 00 00       0265*       dw 0 ; x upper left
041A25 00 00       0266*       dw 0 ; y upper left
041A27             0267*   @end:
041A27             0268*   ; end vdu_plot_rect
041A27             0038        include "../include/debug.inc"
041A27             0001*   printHexA:
041A27 F5          0002*       push af
041A28 C5          0003*       push bc
041A29 CD AA 00 04 0004*       call printHex8
041A2D 3E 20       0005*       ld a,' '
041A2F 5B D7       0006*       rst.lil 10h
041A31 C1          0007*       pop bc
041A32 F1          0008*       pop af
041A33 C9          0009*       ret
041A34             0010*   
041A34             0011*   printHexHL:
041A34 F5          0012*       push af
041A35 C5          0013*       push bc
041A36 CD A4 00 04 0014*       call printHex16
041A3A 3E 20       0015*       ld a,' '
041A3C 5B D7       0016*       rst.lil 10h
041A3E C1          0017*       pop bc
041A3F F1          0018*       pop af
041A40 C9          0019*       ret
041A41             0020*   
041A41             0021*   printHexUHL:
041A41 F5          0022*       push af
041A42 C5          0023*       push bc
041A43 CD 9C 00 04 0024*       call printHex24
041A47 3E 20       0025*       ld a,' '
041A49 5B D7       0026*       rst.lil 10h
041A4B C1          0027*       pop bc
041A4C F1          0028*       pop af
041A4D C9          0029*       ret
041A4E             0030*   
041A4E             0031*   printHexAUHL:
041A4E F5          0032*       push af
041A4F C5          0033*       push bc
041A50 E5          0034*       push hl
041A51 CD AA 00 04 0035*       call printHex8
041A55 E1          0036*       pop hl
041A56 E5          0037*       push hl
041A57 CD 9C 00 04 0038*       call printHex24
041A5B 3E 20       0039*       ld a,' '
041A5D 5B D7       0040*       rst.lil 10h
041A5F E1          0041*       pop hl
041A60 C1          0042*       pop bc
041A61 F1          0043*       pop af
041A62 C9          0044*       ret
041A63             0045*   
041A63             0046*   printHexAHL:
041A63 F5          0047*       push af
041A64 C5          0048*       push bc
041A65 CD AA 00 04 0049*       call printHex8
041A69 CD A4 00 04 0050*       call printHex16
041A6D 3E 20       0051*       ld a,' '
041A6F 5B D7       0052*       rst.lil 10h
041A71 C1          0053*       pop bc
041A72 F1          0054*       pop af
041A73 C9          0055*       ret
041A74             0056*   
041A74             0057*   printHexADE:
041A74 F5          0058*       push af
041A75 C5          0059*       push bc
041A76 EB          0060*       ex de,hl
041A77 CD AA 00 04 0061*       call printHex8
041A7B CD A4 00 04 0062*       call printHex16
041A7F EB          0063*       ex de,hl
041A80 3E 20       0064*       ld a,' '
041A82 5B D7       0065*       rst.lil 10h
041A84 C1          0066*       pop bc
041A85 F1          0067*       pop af
041A86 C9          0068*       ret
041A87             0069*   
041A87             0070*   
041A87             0071*   printHexHLBC:
041A87 F5          0072*       push af
041A88 C5          0073*       push bc
041A89 CD A4 00 04 0074*       call printHex16
041A8D E1          0075*       pop hl ; bc
041A8E E5          0076*       push hl
041A8F CD A4 00 04 0077*       call printHex16
041A93 3E 20       0078*       ld a,' '
041A95 5B D7       0079*       rst.lil 10h
041A97 C1          0080*       pop bc
041A98 F1          0081*       pop af
041A99 C9          0082*       ret
041A9A             0083*   
041A9A             0084*   printHexHLDE:
041A9A F5          0085*       push af
041A9B CD A4 00 04 0086*       call printHex16
041A9F EB          0087*       ex de,hl
041AA0 CD A4 00 04 0088*       call printHex16
041AA4 3E 20       0089*       ld a,' '
041AA6 5B D7       0090*       rst.lil 10h
041AA8 EB          0091*       ex de,hl
041AA9 F1          0092*       pop af
041AAA C9          0093*       ret
041AAB             0094*   
041AAB             0095*   printHexABHL:
041AAB             0096*   ; preserve registers
041AAB C5          0097*       push bc ; b will be ok c will not
041AAC F5          0098*       push af ; will get totally destroyed
041AAD             0099*   ; print a
041AAD CD AA 00 04 0100*       call printHex8
041AB1             0101*   ; print b
041AB1 78          0102*       ld a,b
041AB2 CD AA 00 04 0103*       call printHex8
041AB6             0104*   ; print hl
041AB6 CD A4 00 04 0105*       call printHex16
041ABA             0106*   ; restore registers
041ABA F1          0107*       pop af
041ABB C1          0108*       pop bc
041ABC C9          0109*       ret
041ABD             0110*   
041ABD             0111*   printHexBHL:
041ABD             0112*   ; preserve registers
041ABD C5          0113*       push bc ; b will be ok c will not
041ABE F5          0114*       push af ; will get totally destroyed
041ABF             0115*   ; print b
041ABF 78          0116*       ld a,b
041AC0 CD AA 00 04 0117*       call printHex8
041AC4             0118*   ; print hl
041AC4 CD A4 00 04 0119*       call printHex16
041AC8             0120*   ; restore registers
041AC8 F1          0121*       pop af
041AC9 C1          0122*       pop bc
041ACA C9          0123*       ret
041ACB             0124*   
041ACB             0125*   printHexCDE:
041ACB             0126*   ; preserve registers
041ACB C5          0127*       push bc ; b will be ok c will not
041ACC F5          0128*       push af ; will get totally destroyed
041ACD             0129*   ; print c
041ACD 79          0130*       ld a,c
041ACE CD AA 00 04 0131*       call printHex8
041AD2             0132*   ; print de
041AD2 EB          0133*       ex de,hl
041AD3 CD A4 00 04 0134*       call printHex16
041AD7 EB          0135*       ex de,hl
041AD8             0136*   ; restore registers
041AD8 F1          0137*       pop af
041AD9 C1          0138*       pop bc
041ADA C9          0139*       ret
041ADB             0140*   
041ADB             0141*   printHexUIX:
041ADB             0142*   ; store everything in scratch
041ADB 22 47 04 04 0143*       ld (uhl),hl
041ADF ED 43 4A 04 0144*       ld (ubc),bc
       04          
041AE4 ED 53 4D 04 0145*       ld (ude),de
       04          
041AE9 DD 22 50 04 0146*       ld (uix),ix
       04          
041AEE FD 22 53 04 0147*       ld (uiy),iy
       04          
041AF3 F5          0148*       push af ; fml
041AF4             0149*   
041AF4 21 DE 03 04 0150*       ld hl,str_ixu
041AF8 CD 63 00 04 0151*       call printString
041AFC 2A 50 04 04 0152*       ld hl,(uix)
041B00 CD 9C 00 04 0153*       call printHex24
041B04 CD 78 00 04 0154*       call printNewLine
041B08             0155*   
041B08             0156*   ; restore everything
041B08 2A 47 04 04 0157*       ld hl, (uhl)
041B0C ED 4B 4A 04 0158*       ld bc, (ubc)
       04          
041B11 ED 5B 4D 04 0159*       ld de, (ude)
       04          
041B16 DD 2A 50 04 0160*       ld ix, (uix)
       04          
041B1B FD 2A 53 04 0161*       ld iy, (uiy)
       04          
041B20 F1          0162*       pop af
041B21             0163*   ; all done
041B21 C9          0164*       ret
041B22             0165*   
041B22             0166*   
041B22             0167*   ; print registers to screen in hexidecimal format
041B22             0168*   ; inputs: none
041B22             0169*   ; outputs: values of every register printed to screen
041B22             0170*   ;    values of each register in global scratch memory
041B22             0171*   ; destroys: nothing
041B22             0172*   stepRegistersHex:
041B22             0173*   ; store everything in scratch
041B22 22 47 04 04 0174*       ld (uhl),hl
041B26 ED 43 4A 04 0175*       ld (ubc),bc
       04          
041B2B ED 53 4D 04 0176*       ld (ude),de
       04          
041B30 DD 22 50 04 0177*       ld (uix),ix
       04          
041B35 FD 22 53 04 0178*       ld (uiy),iy
       04          
041B3A F5          0179*       push af ; fml
041B3B E1          0180*       pop hl ; thanks, zilog
041B3C 22 44 04 04 0181*       ld (uaf),hl
041B40 F5          0182*       push af ; dammit
041B41             0183*   
041B41             0184*   ; home the cursor
041B41             0185*       ; call vdu_home_cursor
041B41             0186*   
041B41             0187*   ; print each register
041B41 21 CA 03 04 0188*       ld hl,str_afu
041B45 CD 63 00 04 0189*       call printString
041B49 2A 44 04 04 0190*       ld hl,(uaf)
041B4D CD 9C 00 04 0191*       call printHex24
041B51 CD 78 00 04 0192*       call printNewLine
041B55             0193*   
041B55 21 CF 03 04 0194*       ld hl,str_hlu
041B59 CD 63 00 04 0195*       call printString
041B5D 2A 47 04 04 0196*       ld hl,(uhl)
041B61 CD 9C 00 04 0197*       call printHex24
041B65 CD 78 00 04 0198*       call printNewLine
041B69             0199*   
041B69 21 D4 03 04 0200*       ld hl,str_bcu
041B6D CD 63 00 04 0201*       call printString
041B71 2A 4A 04 04 0202*       ld hl,(ubc)
041B75 CD 9C 00 04 0203*       call printHex24
041B79 CD 78 00 04 0204*       call printNewLine
041B7D             0205*   
041B7D 21 D9 03 04 0206*       ld hl,str_deu
041B81 CD 63 00 04 0207*       call printString
041B85 2A 4D 04 04 0208*       ld hl,(ude)
041B89 CD 9C 00 04 0209*       call printHex24
041B8D CD 78 00 04 0210*       call printNewLine
041B91             0211*   
041B91 21 DE 03 04 0212*       ld hl,str_ixu
041B95 CD 63 00 04 0213*       call printString
041B99 2A 50 04 04 0214*       ld hl,(uix)
041B9D CD 9C 00 04 0215*       call printHex24
041BA1 CD 78 00 04 0216*       call printNewLine
041BA5             0217*   
041BA5 21 E3 03 04 0218*       ld hl,str_iyu
041BA9 CD 63 00 04 0219*       call printString
041BAD 2A 53 04 04 0220*       ld hl,(uiy)
041BB1 CD 9C 00 04 0221*       call printHex24
041BB5 CD 78 00 04 0222*       call printNewLine
041BB9             0223*   
041BB9             0224*       ; call vsync
041BB9             0225*   
041BB9 CD 78 00 04 0226*       call printNewLine
041BBD             0227*   
041BBD             0228*   ; check for right shift key and quit if pressed
041BBD             0229*       MOSCALL mos_getkbmap
                       M1 Args: function=mos_getkbmap 
041BBD 3E 1E       0001*M1 			LD	A, function
041BBF 5B CF       0002*M1 			RST.LIL	08h
041BC1             0230*   @stayhere:
041BC1             0231*   ; 7 RightShift
041BC1 DD CB 00 76 0232*       bit 6,(ix+0)
041BC5 20 02       0233*       jr nz,@RightShift
041BC7 18 F8       0234*       jr @stayhere
041BC9             0235*   @RightShift:
041BC9 DD CB 0E 86 0236*       res 0,(ix+14) ; debounce the key (hopefully)
041BCD 3E 80       0237*       ld a,%10000000
041BCF             0238*       ; call multiPurposeDelay
041BCF             0239*   
041BCF             0240*   ; restore everything
041BCF 2A 47 04 04 0241*       ld hl, (uhl)
041BD3 ED 4B 4A 04 0242*       ld bc, (ubc)
       04          
041BD8 ED 5B 4D 04 0243*       ld de, (ude)
       04          
041BDD DD 2A 50 04 0244*       ld ix, (uix)
       04          
041BE2 FD 2A 53 04 0245*       ld iy, (uiy)
       04          
041BE7 F1          0246*       pop af
041BE8             0247*   ; all done
041BE8 C9          0248*       ret
041BE9             0249*   
041BE9             0250*   ; print registers to screen in hexidecimal format
041BE9             0251*   ; inputs: none
041BE9             0252*   ; outputs: values of every register printed to screen
041BE9             0253*   ;    values of each register in global scratch memory
041BE9             0254*   ; destroys: nothing
041BE9             0255*   dumpRegistersHex:
041BE9             0256*   ; store everything in scratch
041BE9 22 47 04 04 0257*       ld (uhl),hl
041BED ED 43 4A 04 0258*       ld (ubc),bc
       04          
041BF2 ED 53 4D 04 0259*       ld (ude),de
       04          
041BF7 DD 22 50 04 0260*       ld (uix),ix
       04          
041BFC FD 22 53 04 0261*       ld (uiy),iy
       04          
041C01 F5          0262*       push af ; fml
041C02 E1          0263*       pop hl ; thanks, zilog
041C03 22 44 04 04 0264*       ld (uaf),hl
041C07 F5          0265*       push af ; dammit
041C08             0266*   
041C08             0267*   ; home the cursor
041C08             0268*       ; call vdu_home_cursor
041C08             0269*       ; call printNewLine
041C08             0270*   
041C08             0271*   ; print each register
041C08 21 CA 03 04 0272*       ld hl,str_afu
041C0C CD 63 00 04 0273*       call printString
041C10 2A 44 04 04 0274*       ld hl,(uaf)
041C14 CD 9C 00 04 0275*       call printHex24
041C18             0276*       ; call printNewLine
041C18             0277*   
041C18 21 CF 03 04 0278*       ld hl,str_hlu
041C1C CD 63 00 04 0279*       call printString
041C20 2A 47 04 04 0280*       ld hl,(uhl)
041C24 CD 9C 00 04 0281*       call printHex24
041C28             0282*       ; call printNewLine
041C28             0283*   
041C28 21 D4 03 04 0284*       ld hl,str_bcu
041C2C CD 63 00 04 0285*       call printString
041C30 2A 4A 04 04 0286*       ld hl,(ubc)
041C34 CD 9C 00 04 0287*       call printHex24
041C38             0288*       ; call printNewLine
041C38             0289*   
041C38 21 D9 03 04 0290*       ld hl,str_deu
041C3C CD 63 00 04 0291*       call printString
041C40 2A 4D 04 04 0292*       ld hl,(ude)
041C44 CD 9C 00 04 0293*       call printHex24
041C48             0294*       ; call printNewLine
041C48             0295*   
041C48 21 DE 03 04 0296*       ld hl,str_ixu
041C4C CD 63 00 04 0297*       call printString
041C50 2A 50 04 04 0298*       ld hl,(uix)
041C54 CD 9C 00 04 0299*       call printHex24
041C58             0300*       ; call printNewLine
041C58             0301*   
041C58 21 E3 03 04 0302*       ld hl,str_iyu
041C5C CD 63 00 04 0303*       call printString
041C60 2A 53 04 04 0304*       ld hl,(uiy)
041C64 CD 9C 00 04 0305*       call printHex24
041C68             0306*   
041C68 CD 78 00 04 0307*       call printNewLine
041C6C             0308*       ; call printNewLine
041C6C             0309*   ; restore everything
041C6C 2A 47 04 04 0310*       ld hl, (uhl)
041C70 ED 4B 4A 04 0311*       ld bc, (ubc)
       04          
041C75 ED 5B 4D 04 0312*       ld de, (ude)
       04          
041C7A DD 2A 50 04 0313*       ld ix, (uix)
       04          
041C7F FD 2A 53 04 0314*       ld iy, (uiy)
       04          
041C84 F1          0315*       pop af
041C85             0316*   ; all done
041C85 C9          0317*       ret
041C86             0318*   
041C86             0319*   dumpRegistersHexPrime:
041C86 D9          0320*       exx
041C87 08          0321*       ex af,af'
041C88 CD E9 1B 04 0322*       call dumpRegistersHex
041C8C 08          0323*       ex af,af'
041C8D D9          0324*       exx
041C8E C9          0325*       ret
041C8F             0326*   
041C8F             0327*   ; additionally dump prime registers
041C8F             0328*   ; inputs: none
041C8F             0329*   ; outputs: values of every register printed to screen
041C8F             0330*   ; destroys: nothing
041C8F             0331*   dumpRegistersHexAll:
041C8F CD E9 1B 04 0332*       call dumpRegistersHex
041C93 08          0333*       ex af,af'
041C94 D9          0334*       exx
041C95 CD E9 1B 04 0335*       call dumpRegistersHex
041C99 08          0336*       ex af,af'
041C9A D9          0337*       exx
041C9B C9          0338*       ret
041C9C             0339*   
041C9C             0340*   ; print hlu to screen in hexidecimal format
041C9C             0341*   ; inputs: none
041C9C             0342*   ; destroys: nothing
041C9C             0343*   print_hex_hl:
041C9C F5          0344*       push af
041C9D E5          0345*       push hl
041C9E 21 CF 03 04 0346*       ld hl,str_hlu
041CA2 CD 63 00 04 0347*       call printString
041CA6 E1          0348*       pop hl
041CA7 E5          0349*       push hl
041CA8 CD 9C 00 04 0350*       call printHex24
041CAC 3E 20       0351*       ld a,' '
041CAE 5B D7       0352*       rst.lil 10h
041CB0 E1          0353*       pop hl
041CB1 F1          0354*       pop af
041CB2 C9          0355*       ret
041CB3             0356*   
041CB3             0357*   ; print bcu to screen in hexidecimal format
041CB3             0358*   ; inputs: none
041CB3             0359*   ; destroys: nothing
041CB3             0360*   print_hex_bc:
041CB3 F5          0361*       push af
041CB4 E5          0362*       push hl
041CB5 C5          0363*       push bc
041CB6 21 D4 03 04 0364*       ld hl,str_bcu
041CBA CD 63 00 04 0365*       call printString
041CBE E1          0366*       pop hl
041CBF E5          0367*       push hl
041CC0 CD 9C 00 04 0368*       call printHex24
041CC4 3E 20       0369*       ld a,' '
041CC6 5B D7       0370*       rst.lil 10h
041CC8 C1          0371*       pop bc
041CC9 E1          0372*       pop hl
041CCA F1          0373*       pop af
041CCB C9          0374*       ret
041CCC             0375*   
041CCC             0376*   ; print deu to screen in hexidecimal format
041CCC             0377*   ; inputs: none
041CCC             0378*   ; destroys: nothing
041CCC             0379*   print_hex_de:
041CCC F5          0380*       push af
041CCD E5          0381*       push hl
041CCE D5          0382*       push de
041CCF 21 D9 03 04 0383*       ld hl,str_deu
041CD3 CD 63 00 04 0384*       call printString
041CD7 E1          0385*       pop hl
041CD8 E5          0386*       push hl
041CD9 CD 9C 00 04 0387*       call printHex24
041CDD 3E 20       0388*       ld a,' '
041CDF 5B D7       0389*       rst.lil 10h
041CE1 D1          0390*       pop de
041CE2 E1          0391*       pop hl
041CE3 F1          0392*       pop af
041CE4 C9          0393*       ret
041CE5             0394*   
041CE5             0395*   
041CE5             0396*   printCarry:
041CE5             0397*   ;save all the things
041CE5 F5          0398*       push af
041CE6 E5          0399*       push hl
041CE7 C5          0400*       push bc
041CE8 D5          0401*       push de
041CE9             0402*   ; check carry
041CE9 F5          0403*       push af
041CEA F1          0404*       pop af
041CEB 38 06       0405*       jr c,@carry
041CED 3E 30       0406*       ld a,'0'
041CEF 5B D7       0407*       rst.lil 10h
041CF1 18 04       0408*       jr @space
041CF3             0409*   @carry:
041CF3 3E 31       0410*       ld a,'1'
041CF5 5B D7       0411*       rst.lil 10h
041CF7             0412*   @space:
041CF7 3E 20       0413*       ld a,' '
041CF9 5B D7       0414*       rst.lil 10h
041CFB             0415*   ;restore all the things
041CFB D1          0416*       pop de
041CFC C1          0417*       pop bc
041CFD E1          0418*       pop hl
041CFE F1          0419*       pop af
041CFF C9          0420*       ret
041D00             0421*   ; end printCarry
041D00             0422*   
041D00             0423*   ; inputs: whatever is in the flags register
041D00             0424*   ; outputs: binary representation of flags
041D00             0425*   ;          with a header so we know which is what
041D00             0426*   ; destroys: nothing
041D00             0427*   ; preserves: everything
041D00             0428*   dumpFlags:
041D00             0429*   ; first we curse zilog for not giving direct access to flags
041D00 F5          0430*       push af ; this is so we can send it back unharmed
041D01 F5          0431*       push af ; this is so we can pop it to hl
041D02             0432*   ; store everything in scratch
041D02 22 47 04 04 0433*       ld (uhl),hl
041D06 ED 43 4A 04 0434*       ld (ubc),bc
       04          
041D0B ED 53 4D 04 0435*       ld (ude),de
       04          
041D10 DD 22 50 04 0436*       ld (uix),ix
       04          
041D15 FD 22 53 04 0437*       ld (uiy),iy
       04          
041D1A             0438*   ; next we print the header
041D1A 21 46 1D 04 0439*       ld hl,@header
041D1E CD 63 00 04 0440*       call printString
041D22 E1          0441*       pop hl ; flags are now in l
041D23 7D          0442*       ld a,l ; flags are now in a
041D24 CD 06 03 04 0443*       call printBin8
041D28 CD 78 00 04 0444*       call printNewLine
041D2C             0445*   ; restore everything
041D2C 2A 47 04 04 0446*       ld hl, (uhl)
041D30 ED 4B 4A 04 0447*       ld bc, (ubc)
       04          
041D35 ED 5B 4D 04 0448*       ld de, (ude)
       04          
041D3A DD 2A 50 04 0449*       ld ix, (uix)
       04          
041D3F FD 2A 53 04 0450*       ld iy, (uiy)
       04          
041D44 F1          0451*       pop af ; send her home the way she came
041D45 C9          0452*       ret
041D46             0453*   ; Bit 7 (S): Sign flag
041D46             0454*   ; Bit 6 (Z): Zero flag
041D46             0455*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041D46             0456*   ; Bit 4 (H): Half Carry flag
041D46             0457*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041D46             0458*   ; Bit 2 (PV): Parity/Overflow flag
041D46             0459*   ; Bit 1 (N): Subtract flag
041D46             0460*   ; Bit 0 (C): Carry flag
041D46 53 5A 78 48 0461*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041D51             0462*   
041D51             0463*   
041D51             0464*   ; print bytes from an address to the screen in hexidecimal format
041D51             0465*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041D51             0466*   ; outputs: values of each byte printed to screen separated by spaces
041D51             0467*   ; destroys: nothing
041D51             0468*   dumpMemoryHex:
041D51             0469*   ; save registers to the stack
041D51 C5          0470*       push bc
041D52 E5          0471*       push hl
041D53 F5          0472*       push af
041D54             0473*   
041D54             0474*   ; print the address and separator
041D54 CD 9C 00 04 0475*       call printHex24
041D58 3E 3A       0476*       ld a,':'
041D5A 5B D7       0477*       rst.lil 10h
041D5C 3E 20       0478*       ld a,' '
041D5E 5B D7       0479*       rst.lil 10h
041D60             0480*   
041D60             0481*   ; set b to be our loop counter
041D60 F1          0482*       pop af
041D61 47          0483*       ld b,a
041D62 E1          0484*       pop hl
041D63 E5          0485*       push hl
041D64 F5          0486*       push af
041D65             0487*   @loop:
041D65             0488*   ; print the byte
041D65 7E          0489*       ld a,(hl)
041D66 CD AA 00 04 0490*       call printHex8
041D6A             0491*   ; print a space
041D6A 3E 20       0492*       ld a,' '
041D6C 5B D7       0493*       rst.lil 10h
041D6E 23          0494*       inc hl
041D6F 10 F4       0495*       djnz @loop
041D71 CD 78 00 04 0496*       call printNewLine
041D75             0497*   
041D75             0498*   ; restore everything
041D75 F1          0499*       pop af
041D76 E1          0500*       pop hl
041D77 C1          0501*       pop bc
041D78             0502*   
041D78             0503*   ; all done
041D78 C9          0504*       ret
041D79             0505*   
041D79             0506*   
041D79             0507*   ; print bytes from an address to the screen in binary format
041D79             0508*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041D79             0509*   ; outputs: values of each byte printed to screen separated by spaces
041D79             0510*   ; destroys: nothing
041D79             0511*   dumpMemoryBin:
041D79             0512*   ; save all registers to the stack
041D79 F5          0513*       push af
041D7A C5          0514*       push bc
041D7B D5          0515*       push de
041D7C E5          0516*       push hl
041D7D DD E5       0517*       push ix
041D7F FD E5       0518*       push iy
041D81             0519*   
041D81             0520*   ; set b to be our loop counter
041D81 47          0521*       ld b,a
041D82             0522*   @loop:
041D82             0523*   ; print the byte
041D82 7E          0524*       ld a,(hl)
041D83 E5          0525*       push hl
041D84 C5          0526*       push bc
041D85 CD 06 03 04 0527*       call printBin8
041D89 C1          0528*       pop bc
041D8A             0529*   ; print a space
041D8A 3E 20       0530*       ld a,' '
041D8C 5B D7       0531*       rst.lil 10h
041D8E E1          0532*       pop hl
041D8F 23          0533*       inc hl
041D90 10 F0       0534*       djnz @loop
041D92 CD 78 00 04 0535*       call printNewLine
041D96             0536*   
041D96             0537*   ; restore everything
041D96 FD E1       0538*       pop iy
041D98 DD E1       0539*       pop ix
041D9A E1          0540*       pop hl
041D9B D1          0541*       pop de
041D9C C1          0542*       pop bc
041D9D F1          0543*       pop af
041D9E             0544*   ; all done
041D9E C9          0545*       ret
041D9F             0546*   
041D9F             0547*   ; print bytes from an address to the screen in binary format
041D9F             0548*   ; with the bits of each byte in reverse order (lsb first)
041D9F             0549*   ; inputs: hl = address of first byte to print, a = number of bytes to print
041D9F             0550*   ; outputs: values of each byte printed to screen separated by spaces
041D9F             0551*   ; destroys: nothing
041D9F             0552*   dumpMemoryBinRev:
041D9F             0553*   ; save all registers to the stack
041D9F F5          0554*       push af
041DA0 C5          0555*       push bc
041DA1 D5          0556*       push de
041DA2 E5          0557*       push hl
041DA3 DD E5       0558*       push ix
041DA5 FD E5       0559*       push iy
041DA7             0560*   
041DA7             0561*   ; set b to be our loop counter
041DA7 47          0562*       ld b,a
041DA8             0563*   @loop:
041DA8             0564*   ; print the byte
041DA8 7E          0565*       ld a,(hl)
041DA9 E5          0566*       push hl
041DAA C5          0567*       push bc
041DAB CD A5 03 04 0568*       call printBin8Rev
041DAF C1          0569*       pop bc
041DB0             0570*   ; print a space
041DB0 3E 20       0571*       ld a,' '
041DB2 5B D7       0572*       rst.lil 10h
041DB4 E1          0573*       pop hl
041DB5 23          0574*       inc hl
041DB6 10 F0       0575*       djnz @loop
041DB8 CD 78 00 04 0576*       call printNewLine
041DBC             0577*   
041DBC             0578*   ; restore everything
041DBC FD E1       0579*       pop iy
041DBE DD E1       0580*       pop ix
041DC0 E1          0581*       pop hl
041DC1 D1          0582*       pop de
041DC2 C1          0583*       pop bc
041DC3 F1          0584*       pop af
041DC4             0585*   ; all done
041DC4 C9          0586*       ret
041DC5             0039    
041DC5             0040    ; APPLICATION INCLUDES
041DC5             0041        include "../softfloat/f16_mul.inc"
041DC5             0001*   ; multiply two signed fixed16 numbers and get a fixed16 result
041DC5             0002*   ; operation: 0hl * 0de -> 0hl
041DC5             0003*   ; destroys: af,af', bc, de
041DC5             0004*   f16_mul:
041DC5             0005*   ; compute sign of product
041DC5 7C          0006*       ld a,h ; sign hl
041DC6 E6 80       0007*       and %10000000
041DC8 AA          0008*       xor d ; xor sign hl with sign de
041DC9 E6 80       0009*       and %10000000
041DCB 4F          0010*       ld c,a  ; signZ
041DCC             0011*   
041DCC             0012*   ; clear sign bits to make specials tests easier
041DCC CB BC       0013*       res 7,h
041DCE CB BA       0014*       res 7,d
041DD0             0015*   
041DD0             0016*   ; check operands for NaN
041DD0 3E 7E       0017*       ld a,0x7E ; NaN upper byte is all we need
041DD2 BC          0018*       cp h
041DD3 CA 7D 1E 04 0019*       jp z,@ret_nan
041DD7 BA          0020*       cp d
041DD8 CA 7D 1E 04 0021*       jp z,@ret_nan
041DDC             0022*   
041DDC             0023*   ; check hl for zero
041DDC             0024*       SIGN_HL
                       M1 Args: none
041DDC 19          0001*M1     add hl,de
041DDD B7          0002*M1     or a ; clear flags
041DDE 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041DE1 CA 60 1E 04 0025*       jp z,@arg_is_zero
041DE5             0026*   
041DE5             0027*   ; check hl for inf
041DE5 7C          0028*       ld a,h ; expA
041DE6 E6 7C       0029*       and %01111100 ; stored exp of hl
041DE8 FE 7C       0030*       cp %01111100 ; check for inf
041DEA CA 6D 1E 04 0031*       jp z,@arg_is_inf
041DEE             0032*   
041DEE             0033*   ; check de for zero
041DEE EB          0034*       ex de,hl ; flip operands
041DEF             0035*       SIGN_HL
                       M1 Args: none
041DEF 19          0001*M1     add hl,de
041DF0 B7          0002*M1     or a ; clear flags
041DF1 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041DF4 CA 60 1E 04 0036*       jp z,@arg_is_zero
041DF8             0037*   
041DF8             0038*   ; check de for inf
041DF8 7C          0039*       ld a,h ; expB
041DF9 E6 7C       0040*       and %01111100 ; stored exp of de
041DFB FE 7C       0041*       cp %01111100 ; check for inf
041DFD CA 6D 1E 04 0042*       jp z,@arg_is_inf
041E01             0043*   
041E01             0044*   ; get exponent of de
041E01 B7          0045*       or a ; clear carry
041E02 1F          0046*       rra ; shift exp
041E03 1F          0047*       rra ; down twice
041E04 47          0048*       ld b,a ; assume normal
041E05 A7          0049*       and a ; test for subnormal
041E06 CC DE 21 04 0050*       call z,softfloat_normSubnormalF16Sig
041E0A             0051*   
041E0A             0052*   ; get mantissa of de
041E0A 7C          0053*       ld a,h
041E0B E6 03       0054*       and %00000011 ; mask out sign and exponent
041E0D 67          0055*       ld h,a
041E0E EB          0056*       ex de,hl ; flip operands back
041E0F             0057*   
041E0F             0058*   ; get exponent of hl
041E0F 7C          0059*       ld a,h ; expA
041E10 E6 7C       0060*       and %01111100 ; stored exp of hl
041E12 1F          0061*       rra ; shift exp
041E13 1F          0062*       rra ; down twice
041E14 A7          0063*       and a ; test for subnormal
041E15 20 05       0064*       jr nz,@F ; skip if normal
041E17 78          0065*       ld a,b ; a = expB
041E18 CD DE 21 04 0066*       call softfloat_normSubnormalF16Sig
041E1C             0067*   @@:
041E1C             0068*   ; compute exponent of product
041E1C 80          0069*       add a,b ; expA + expB
041E1D D6 0F       0070*       sub 0x0F ; expA + expB - 0xF
041E1F 47          0071*       ld b,a ; expZ
041E20             0072*   
041E20             0073*   ; get mantissa of hl
041E20 7C          0074*       ld a,h
041E21 E6 03       0075*       and %00000011 ; mask out sign and exponent
041E23 67          0076*       ld h,a
041E24             0077*   
041E24             0078*   ; cleared to proceed with the multiplication
041E24 C5          0079*       push bc ; stack sign and exponent of product
041E25             0080*   ; sigA = (sigA | 0x0400)<<4;
041E25 CB D4       0081*       set 2,h ; set implicit 1
041E27 29          0082*       add hl,hl
041E28 29          0083*       add hl,hl
041E29 29          0084*       add hl,hl
041E2A 29          0085*       add hl,hl
041E2B             0086*   ; sigB = (sigB | 0x0400)<<5;
041E2B EB          0087*       ex de,hl
041E2C CB D4       0088*       set 2,h ; set implicit 1
041E2E 29          0089*       add hl,hl
041E2F 29          0090*       add hl,hl
041E30 29          0091*       add hl,hl
041E31 29          0092*       add hl,hl
041E32 29          0093*       add hl,hl
041E33 EB          0094*       ex de,hl
041E34             0095*   ; sig32Z = (uint_fast32_t) sigA * sigB;
041E34 CD 82 1E 04 0096*       call mul_16_32
041E38 EB          0097*       ex de,hl
041E39 EB          0098*       ex de,hl
041E3A             0099*   ; sigZ = sig32Z>>16; (we get this for free since HL contains the relevant bits)
041E3A             0100*   ; if ( sig32Z & 0xFFFF ) sigZ |= 1; set sticky bit
041E3A 7B          0101*       ld a,e
041E3B A7          0102*       and a
041E3C C2 4A 1E 04 0103*       jp nz,@need_sticky
041E40 7A          0104*       ld a,d
041E41 A7          0105*       and a
041E42 C2 4A 1E 04 0106*       jp nz,@need_sticky
041E46 C3 4C 1E 04 0107*       jp @do_sign_exp
041E4A             0108*   @need_sticky:
041E4A CB C5       0109*       set 0,l ; set sticky bit
041E4C             0110*   @do_sign_exp:
041E4C C1          0111*       pop bc ; exp and sign of product
041E4D             0112*   ; check for subnormal
041E4D 7C          0113*       ld a,h
041E4E E6 C0       0114*       and %11000000 ; sigZ - 0x4000
041E50 C2 5C 1E 04 0115*       jp nz,@end_normalise ; sigZ >= 0x4000
041E54             0116*   @normalise_loop:
041E54 05          0117*       dec b ; --expZ
041E55 29          0118*       add hl,hl ; sigZ <<= 1
041E56 CB 74       0119*       bit 6,h ; test for carry into assumed 1 place
041E58 CA 54 1E 04 0120*       jp z,@normalise_loop
041E5C             0121*   @end_normalise: ; we land here if product was normal
041E5C             0122*   ; return softfloat_roundPackToF16( signZ, expZ, sigZ );
041E5C C3 E7 21 04 0123*       jp softfloat_roundPackToF16
041E60             0124*   @arg_is_zero:
041E60 7A          0125*       ld a,d ; check other arg for inf
041E61 E6 7C       0126*       and %01111100
041E63 FE 7C       0127*       cp %01111100
041E65 CA 7D 1E 04 0128*       jp z,@ret_nan ; return NaN if exponent is inf
041E69 79          0129*       ld a,c ; otherwise, sign the zero
041E6A B4          0130*       or h ; (re)set sign bit
041E6B 67          0131*       ld h,a
041E6C C9          0132*       ret
041E6D             0133*   @arg_is_inf:
041E6D EB          0134*       ex de,hl          ; flip operands to get other arg in hl
041E6E             0135*       SIGN_HL           ; test other arg for zero
                       M1 Args: none
041E6E 19          0001*M1     add hl,de
041E6F B7          0002*M1     or a ; clear flags
041E70 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041E73 28 08       0136*       jr z,@ret_nan     ; zero * inf = NaN
041E75 21 00 7C 00 0137*       ld hl,0x7C00      ; Inf result
041E79 79          0138*       ld a,c            ; get product sign
041E7A B4          0139*       or h              ; reapply sign
041E7B 67          0140*       ld h,a
041E7C C9          0141*       ret
041E7D             0142*   @ret_nan:
041E7D 21 00 7E 00 0143*       ld hl,canonicalNaNF16
041E81 C9          0144*       ret
041E82             0145*   ; }
041E82             0146*   
041E82             0147*   
041E82             0148*   ;Inputs: hl,de = operands
041E82             0149*   ;Outputs: hlde = 32-bit product
041E82             0150*   ;Destroys: af,bc
041E82             0151*   ;53 cycles
041E82             0152*   ;32 bytes
041E82             0153*   mul_16_32:
041E82 43          0154*       ld b,e
041E83 4D          0155*       ld c,l
041E84 6B          0156*       ld l,e
041E85 59          0157*       ld e,c
041E86 ED 4C       0158*       mlt bc
041E88 78          0159*       ld a,b
041E89 44          0160*       ld b,h
041E8A ED 6C       0161*       mlt hl
041E8C             0162*       ; Add high part of low product, cannot overflow 16 bits
041E8C 85          0163*       add a,l
041E8D 6F          0164*       ld l,a
041E8E 8C          0165*       adc a,h
041E8F 95          0166*       sub a,l
041E90 67          0167*       ld h,a
041E91 79          0168*       ld a,c
041E92 4A          0169*       ld c,d
041E93 ED 5C       0170*       mlt de
041E95 52 19       0171*       add.s hl,de ; .s to force 16-bit addition
041E97 5F          0172*       ld e,a
041E98 55          0173*       ld d,l
041E99 6C          0174*       ld l,h
041E9A 26 00       0175*       ld h,0
041E9C CB 14       0176*       rl h
041E9E ED 4C       0177*       mlt bc
041EA0 09          0178*       add hl,bc ; Cannot overflow 16 bits
041EA1 C9          0179*       ret
041EA2             0042        include "../softfloat/f16_div.inc"
041EA2             0001*   ; r0 = softfloat_approxRecip_1k0s[index]-((softfloat_approxRecip_1k1s[index]*(sigB & 0x3F))>>10);
041EA2             0002*   
041EA2             0003*   ; inputs: hl = dividend, de = divisor
041EA2             0004*   ; outputs: hl = float16 result
041EA2             0005*   f16_div:
041EA2             0006*   ; compute sign of the quotient
041EA2 7C          0007*       ld a,h ; sign opA
041EA3 E6 80       0008*       and %10000000
041EA5 AA          0009*       xor d ; xor sign opA with sign opB
041EA6 E6 80       0010*       and %10000000
041EA8 32 3C 20 04 0011*       ld (@signZ),a
041EAC             0012*   
041EAC             0013*   ; unpack opB
041EAC EB          0014*       ex de,hl
041EAD CD 5A 21 04 0015*       call softfloat16_unpack
041EB1 22 36 20 04 0016*       ld (@sigB),hl ; store sigB
041EB5 78          0017*       ld a,b ; exponent
041EB6 32 32 20 04 0018*       ld (@expB),a ; store exponent
041EBA             0019*   
041EBA             0020*   ; unpack opA
041EBA EB          0021*       ex de,hl
041EBB CD 5A 21 04 0022*       call softfloat16_unpack
041EBF 78          0023*       ld a,b ; exponent
041EC0 32 31 20 04 0024*       ld (@expA),a
041EC4 22 33 20 04 0025*       ld (@sigA),hl ; store sigA
041EC8             0026*   
041EC8             0027*   ; === HANDLE SPECIAL CASES ===
041EC8             0028*   ; if ( expA == 0x1F ) {
041EC8 FE 1F       0029*       cp 0x1F ; check expA for inf
041ECA 20 24       0030*       jr nz,@check_expB_inf
041ECC             0031*   ;     if ( sigA ) goto propagateNaN;
041ECC             0032*           SIGN_HL
                       M1 Args: none
041ECC 19          0001*M1     add hl,de
041ECD B7          0002*M1     or a ; clear flags
041ECE 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041ED1 C2 02 20 04 0033*           jp nz,@return_nan
041ED5             0034*   ;     if ( expB == 0x1F ) {
041ED5 3A 32 20 04 0035*           ld a,(@expB)
041ED9 FE 1F       0036*           cp 0x1F ; check expB for inf
041EDB C2 07 20 04 0037*           jp nz,@return_inf
041EDF             0038*   ;         if ( sigB ) goto propagateNaN;
041EDF 2A 36 20 04 0039*               ld hl,(@sigB)
041EE3             0040*               SIGN_HL
                       M1 Args: none
041EE3 19          0001*M1     add hl,de
041EE4 B7          0002*M1     or a ; clear flags
041EE5 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041EE8 C2 02 20 04 0041*               jp nz,@return_nan ; non-signalling NaN
041EEC             0042*   ;         goto invalid;
041EEC C3 02 20 04 0043*               jp @return_invalid ; signalling NaN
041EF0             0044*   ;     }
041EF0             0045*   ;     goto infinity; // handled above
041EF0             0046*   ; }
041EF0             0047*   @check_expB_inf:
041EF0             0048*   ; if ( expB == 0x1F ) {
041EF0 3A 32 20 04 0049*       ld a,(@expB)
041EF4 FE 1F       0050*       cp 0x1F ; check expB for inf
041EF6 20 11       0051*       jr nz,@check_expB_zero
041EF8             0052*   ;     if ( sigB ) goto propagateNaN;
041EF8 2A 36 20 04 0053*           ld hl,(@sigB)
041EFC             0054*           SIGN_HL
                       M1 Args: none
041EFC 19          0001*M1     add hl,de
041EFD B7          0002*M1     or a ; clear flags
041EFE 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041F01 C2 02 20 04 0055*           jp nz,@return_nan ; non-signalling NaN
041F05             0056*   ;     goto zero;
041F05 C3 11 20 04 0057*           jp @return_zero
041F09             0058*   ; }
041F09             0059*   ; /*------------------------------------------------------------------------
041F09             0060*   ; *------------------------------------------------------------------------*/
041F09             0061*   @check_expB_zero:
041F09             0062*   ; if ( ! expB ) {
041F09 B7          0063*       or a ; check expB for zero
041F0A 20 25       0064*       jr nz,@check_expA_zero
041F0C             0065*   ; if ( ! sigB ) {
041F0C 2A 36 20 04 0066*       ld hl,(@sigB)
041F10             0067*       SIGN_HL
                       M1 Args: none
041F10 19          0001*M1     add hl,de
041F11 B7          0002*M1     or a ; clear flags
041F12 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041F15 20 1A       0068*       jr nz,@check_expA_zero
041F17             0069*   ; if ( ! (expA | sigA) ) goto invalid;
041F17 3A 31 20 04 0070*       ld a,(@expA)
041F1B B7          0071*       or a ; check expA for zero
041F1C 20 0F       0072*       jr nz,@b_zero_a_nonzero
041F1E 2A 33 20 04 0073*       ld hl,(@sigA)
041F22             0074*       SIGN_HL
                       M1 Args: none
041F22 19          0001*M1     add hl,de
041F23 B7          0002*M1     or a ; clear flags
041F24 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041F27 20 04       0075*       jr nz,@b_zero_a_nonzero
041F29             0076*   ; 0/0 case
041F29 C3 02 20 04 0077*       jp @return_invalid
041F2D             0078*   @b_zero_a_nonzero:
041F2D             0079*   ; goto infinity;
041F2D C3 07 20 04 0080*       jp @return_inf
041F31             0081*   ; }
041F31             0082*   @check_expA_zero:
041F31             0083*   ; if ( ! expA ) {
041F31 3A 31 20 04 0084*       ld a,(@expA)
041F35 B7          0085*       or a ; check expA for zero
041F36 20 0D       0086*       jr nz,@end_specials
041F38             0087*   ;     if ( ! sigA ) goto zero;
041F38 2A 33 20 04 0088*           ld hl,(@sigA)
041F3C             0089*           SIGN_HL
                       M1 Args: none
041F3C 19          0001*M1     add hl,de
041F3D B7          0002*M1     or a ; clear flags
041F3E 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
041F41 CA 11 20 04 0090*           jp z,@return_zero
041F45             0091*   ; }
041F45             0092*   @end_specials:
041F45             0093*   
041F45             0094*   ; expZ = expA - expB + 0xE
041F45 3A 31 20 04 0095*       ld a,(@expA)
041F49 47          0096*       ld b,a
041F4A 3A 32 20 04 0097*       ld a,(@expB)
041F4E 90          0098*       sub b
041F4F ED 44       0099*       neg
041F51 C6 0E       0100*       add 0x0E
041F53             0101*   ; if sigA < sigB: expZ = expZ - 1, numShifts = 5
041F53             0102*   ; else: numShifts = 4
041F53             0103*   ; sigA = u16(sigA << numShifts)
041F53 ED 4B 36 20 0104*       ld bc,(@sigB)
       04          
041F58 B7          0105*       or a ; clear carry
041F59 52 ED 42    0106*       sbc.s hl,bc ; sigA - sigB (.s to force 16-bit subtraction)
041F5C 2A 33 20 04 0107*       ld hl,(@sigA)
041F60 30 02       0108*       jr nc,@sigA_gte_sigB ; sigA < sigB
041F62             0109*   ; expZ = expZ - 1
041F62 3D          0110*       dec a
041F63             0111*   ; sigA = u16(sigA << 5)
041F63 29          0112*       add hl,hl
041F64             0113*   @sigA_gte_sigB:
041F64 32 3D 20 04 0114*       ld (@expZ),a
041F68             0115*   ; else: sigA = u16(sigA << 4)
041F68 29          0116*       add hl,hl
041F69 29          0117*       add hl,hl
041F6A 29          0118*       add hl,hl
041F6B 29          0119*       add hl,hl
041F6C 22 33 20 04 0120*       ld (@sigA),hl ; store sigA shifted up
041F70             0121*   
041F70             0122*   ; index = sigB>>6 & 0xF;
041F70 69          0123*       ld l,c
041F71 60          0124*       ld h,b
041F72 29          0125*       add hl,hl
041F73 29          0126*       add hl,hl
041F74 7C          0127*       ld a,h
041F75 E6 0F       0128*       and 0x0F ; index
041F77             0129*   
041F77 87          0130*       add a,a ; 2 bytes per LUT entry
041F78 5F          0131*       ld e,a
041F79 16 00       0132*       ld d,0
041F7B 1B          0133*       dec de
041F7C 52 13       0134*       inc.s de ; zero deu
041F7E DD E5       0135*       push ix ; preserve
041F80 DD 21 51 20 0136*       ld ix,softfloat_approxRecip_1k0s
       04          
041F85 DD 19       0137*       add ix,de
041F87             0138*   
041F87             0139*   ; r0 = approx1k0s - (((approx1k1s * (sigB & 0x3F)) >> 10))
041F87 DD 27 20    0140*       ld hl,(ix+32) ; approx1k1s
041F8A 79          0141*       ld a,c ; sigB low byte
041F8B E6 3F       0142*       and 0x3F ; sigB & 0x3F
041F8D CD 44 20 04 0143*       call mul16x8 ; (sigB & 0x3F) -> ade
041F91             0144*   ; >>10
041F91 B7          0145*       or a ; clear carry
041F92 1F          0146*       rra
041F93 CB 1A       0147*       rr d
041F95 B7          0148*       or a ; clear carry
041F96 1F          0149*       rra
041F97 CB 1A       0150*       rr d
041F99 5A          0151*       ld e,d
041F9A 57          0152*       ld d,a
041F9B 1B          0153*       dec de
041F9C 52 13       0154*       inc.s de ; zero deu
041F9E DD 27 00    0155*       ld hl,(ix) ; approx1k0s
041FA1 DD E1       0156*       pop ix ; send back how it came in
041FA3 B7          0157*       or a ; clear carry
041FA4 52 ED 52    0158*       sbc.s hl,de ; hl = r0 = approx1k0s - ((approx1k1s * (sigB & 0x3F)) >> 10)
041FA7 22 39 20 04 0159*       ld (@r0),hl ; store r0
041FAB             0160*   
041FAB             0161*   ; sigZ = u32((sigA * r0) >> 16)
041FAB ED 5B 33 20 0162*       ld de,(@sigA)
       04          
041FB0 CD 82 1E 04 0163*       call mul_16_32 ; hl = sigZ
041FB4 22 3E 20 04 0164*       ld (@sigZ),hl
041FB8 CD 19 20 04 0165*       call @compute_sigZ_error
041FBC             0166*   
041FBC             0167*   ; sigZ += (rem * (uint_fast32_t) r0)>>26;
041FBC             0168*   ; both multiplicands are 16 bits so we can use 16x16->32 bit multiply
041FBC 2A 39 20 04 0169*       ld hl,(@r0)
041FC0 CD 82 1E 04 0170*       call mul_16_32 ; hlde = rem * r0
041FC4 7C          0171*       ld a,h ; top byte of product
041FC5 CB 3F       0172*       srl a
041FC7 CB 3F       0173*       srl a
041FC9 2A 3E 20 04 0174*       ld hl,(@sigZ)
041FCD 85          0175*       add a,l
041FCE 6F          0176*       ld l,a
041FCF 8C          0177*       adc a,h
041FD0 95          0178*       sub l
041FD1 67          0179*       ld h,a
041FD2             0180*   ; ++sigZ;
041FD2 23          0181*       inc hl
041FD3             0182*   
041FD3             0183*   ; if ( ! (sigZ & 7) ) {
041FD3 7D          0184*       ld a,l
041FD4 E6 07       0185*       and 0x07
041FD6 20 21       0186*       jr nz,@return
041FD8             0187*   ;     sigZ &= ~1;
041FD8 CB 85       0188*           res 0,l
041FDA 22 3E 20 04 0189*           ld (@sigZ),hl
041FDE             0190*   ;     rem = (sigA<<10) - sigZ * sigB;
041FDE CD 19 20 04 0191*           call @compute_sigZ_error
041FE2             0192*   ;     if ( rem & 0x8000 ) {
041FE2 2A 3E 20 04 0193*           ld hl,(@sigZ)
041FE6 7A          0194*           ld a,d
041FE7 E6 80       0195*           and 0x80
041FE9 28 04       0196*           jr z,@F
041FEB             0197*   ;         sigZ -= 2;
041FEB 2B          0198*               dec hl
041FEC 2B          0199*               dec hl
041FED 18 0A       0200*               jr @return
041FEF             0201*   ;     } else {
041FEF             0202*   @@:
041FEF             0203*   ;         if ( rem ) sigZ |= 1;
041FEF 7A          0204*               ld a,d
041FF0 B7          0205*               or a
041FF1 20 04       0206*               jr nz,@F
041FF3 7B          0207*               ld a,e
041FF4 B7          0208*               or a
041FF5 28 02       0209*               jr z,@return
041FF7             0210*   @@:
041FF7 CB C5       0211*               set 0,l
041FF9             0212*   ;     }
041FF9             0213*   ; }
041FF9             0214*   
041FF9             0215*   @return:
041FF9             0216*   ; hl must be set to sigZ at this point
041FF9 ED 4B 3C 20 0217*       ld bc,(@signZ) ; b=expZ, c=signZ
       04          
041FFE C3 E7 21 04 0218*       jp softfloat_roundPackToF16 ; assumes hl holds sig
042002             0219*   @return_invalid: ; fow now, we don't distinguish between signalling and non-signalling NaN
042002             0220*   @return_nan:
042002 21 00 7E 00 0221*       ld hl,canonicalNaNF16
042006 C9          0222*       ret
042007             0223*   @return_inf:
042007 2E 00       0224*       ld l,0
042009 3A 3C 20 04 0225*       ld a,(@signZ)
04200D F6 7C       0226*       or 0x7C
04200F 67          0227*       ld h,a
042010 C9          0228*       ret
042011             0229*   @return_zero:
042011 2E 00       0230*       ld l,0
042013 3A 3C 20 04 0231*       ld a,(@signZ)
042017 67          0232*       ld h,a
042018 C9          0233*       ret
042019             0234*   ; compute the error of sigZ
042019             0235*   ; inputs: hl = sigZ, (@sigB), (@sigA), (@r0)
042019             0236*   ; returns: hlde = rem (only de should matter)
042019             0237*   @compute_sigZ_error:
042019             0238*   ; rem = u32((sigA << 10) - sigZ * sigB)
042019 ED 5B 36 20 0239*       ld de,(@sigB)
       04          
04201E CD 82 1E 04 0240*       call mul_16_32 ; hlde = sigZ * sigB
042022 E5          0241*       push hl ; stack upper word of product
042023 2A 33 20 04 0242*       ld hl,(@sigA)
042027 29          0243*       add hl,hl
042028 29          0244*       add hl,hl
042029             0245*       ; ld (@scratch),hl ; don't need since difference will not occupy more than two bytes
042029 C1          0246*       pop bc ; restore upper word of product (was hl)
04202A AF          0247*       xor a ; a is our phantom zero register
04202B             0248*   ; now we're set to do the subtraction:
04202B             0249*   ;   uhl0
04202B             0250*   ; - bcde
04202B             0251*   ;  ------
04202B             0252*   ;   bcde
04202B 93          0253*       sub e
04202C 5F          0254*       ld e,a
04202D 7D          0255*       ld a,l
04202E 9A          0256*       sbc a,d
04202F 57          0257*       ld d,a
042030             0258*   ; ; difference is contained in two bytes so we only need de
042030             0259*   ;     ld a,h
042030             0260*   ;     sbc a,c
042030             0261*   ;     ld c,a
042030             0262*   ;     ld a,(@scratch+2) ; hlu
042030             0263*   ;     sub b
042030             0264*   ;     ld b,a ; we assume no carry out
042030 C9          0265*       ret
042031             0266*   ; end @compute_sigZ_error
042031             0267*   
042031             0268*   ; scratch variables
042031 00          0269*   @expA: db 0
042032 00          0270*   @expB: db 0
042033 00 00 00    0271*   @sigA: dl 0
042036 00 00 00    0272*   @sigB: dl 0
042039 00 00 00    0273*   @r0:  dl 0
04203C 00          0274*   @signZ: db 0
04203D 00          0275*   @expZ: db 0
04203E 00 00 00    0276*   @sigZ: dl 0
042041 00 00 00    0277*   @scratch: dl 0
042044             0278*   ; end f16_div
042044             0279*   
042044             0280*   ; Inputs: hl is the 16 bit multiplicand, a is the 8 bit multiplier
042044             0281*   ; Outputs: ade = 24-bit result
042044             0282*   ; Destroys: f, hl
042044             0283*   mul16x8:
042044 55          0284*       ld d,l
042045 5F          0285*       ld e,a
042046 ED 5C       0286*       mlt de ; l * a
042048 6F          0287*       ld l,a
042049 ED 6C       0288*       mlt hl ; h * a
04204B             0289*   ; hl<<8 + de -> ade
04204B 7A          0290*       ld a,d
04204C 85          0291*       add a,l
04204D 57          0292*       ld d,a
04204E 8C          0293*       adc a,h
04204F 92          0294*       sub a,d
042050 C9          0295*       ret
042051             0296*   ; end mul16x8
042051             0297*   
042051             0298*   ; ; Inputs: hl is the 16 bit multiplicand, a is the 8 bit multiplier
042051             0299*   ; ; Outputs: uhl = 24-bit result
042051             0300*   ; ; Destroys: f, de
042051             0301*   ; mul16x8:
042051             0302*   ;     ld d,l
042051             0303*   ;     ld e,a
042051             0304*   ;     mlt de ; l * a
042051             0305*   ;     ld l,a
042051             0306*   ;     mlt hl ; h * a
042051             0307*   ; ; hl<<8 + de -> uhl
042051             0308*   ;     add hl,hl ; 1
042051             0309*   ;     add hl,hl ; 2
042051             0310*   ;     add hl,hl ; 3
042051             0311*   ;     add hl,hl ; 4
042051             0312*   ;     add hl,hl ; 5
042051             0313*   ;     add hl,hl ; 6
042051             0314*   ;     add hl,hl ; 7
042051             0315*   ;     add hl,hl ; 8
042051             0316*   ;     add hl,de
042051             0317*   ;     ret
042051             0318*   ; ; end mul16x8
042051             0319*   
042051             0320*   softfloat_approxRecip_1k0s:
042051 C4 FF BE F0 0321*       dw 0xFFC4, 0xF0BE, 0xE363, 0xD76F, 0xCCAD, 0xC2F0, 0xBA16, 0xB201
       63 E3 6F D7 
       AD CC F0 C2 
       16 BA 01 B2 
042061 97 AA C6 A3 0322*       dw 0xAA97, 0xA3C6, 0x9D7A, 0x97A6, 0x923C, 0x8D32, 0x887E, 0x8417
       7A 9D A6 97 
       3C 92 32 8D 
       7E 88 17 84 
042071             0323*   
042071             0324*   softfloat_approxRecip_1k1s:
042071 F1 F0 2C D6 0325*       dw 0xF0F1, 0xD62C, 0xBFA1, 0xAC77, 0x9C0A, 0x8DDB, 0x8185, 0x76BA
       A1 BF 77 AC 
       0A 9C DB 8D 
       85 81 BA 76 
042081 3B 6D D4 64 0326*       dw 0x6D3B, 0x64D4, 0x5D5C, 0x56B1, 0x50B6, 0x4B55, 0x4679, 0x4211
       5C 5D B1 56 
       B6 50 55 4B 
       79 46 11 42 
042091             0327*   
042091             0328*   
042091             0329*   div_16_32_xeda:
042091 CD 9D 20 04 0330*       call div_16_xeda
042095 D5          0331*       push de
042096 CD 9D 20 04 0332*       call div_16_xeda
04209A E1          0333*       pop hl
04209B EB          0334*       ex de,hl
04209C C9          0335*       ret
04209D             0336*   
04209D             0337*   
04209D             0338*   div_16_xeda:
04209D             0339*   ;;Inputs: DE is the numerator, BC is the divisor
04209D             0340*   ;;Outputs: DE is the result, HL is the remainder
04209D             0341*   ;;         A is a copy of E
04209D             0342*   ;;         BC is not changed
04209D             0343*   ;140 bytes
04209D             0344*   ;145cc
04209D AF          0345*       xor a
04209E 52 ED 62    0346*       sbc.s hl,hl
0420A1 7A          0347*       ld a,d
0420A2 17          0348*       rla
0420A3 52 ED 6A    0349*       adc.s hl,hl
0420A6 52 ED 42    0350*       sbc.s hl,bc
0420A9 30 02       0351*       jr nc,$+4
0420AB 52 09       0352*       add.s hl,bc
0420AD 17          0353*       rla
0420AE 52 ED 6A    0354*       adc.s hl,hl
0420B1 52 ED 42    0355*       sbc.s hl,bc
0420B4 30 02       0356*       jr nc,$+4
0420B6 52 09       0357*       add.s hl,bc
0420B8 17          0358*       rla
0420B9 52 ED 6A    0359*       adc.s hl,hl
0420BC 52 ED 42    0360*       sbc.s hl,bc
0420BF 30 02       0361*       jr nc,$+4
0420C1 52 09       0362*       add.s hl,bc
0420C3 17          0363*       rla
0420C4 52 ED 6A    0364*       adc.s hl,hl
0420C7 52 ED 42    0365*       sbc.s hl,bc
0420CA 30 02       0366*       jr nc,$+4
0420CC 52 09       0367*       add.s hl,bc
0420CE 17          0368*       rla
0420CF 52 ED 6A    0369*       adc.s hl,hl
0420D2 52 ED 42    0370*       sbc.s hl,bc
0420D5 30 02       0371*       jr nc,$+4
0420D7 52 09       0372*       add.s hl,bc
0420D9 17          0373*       rla
0420DA 52 ED 6A    0374*       adc.s hl,hl
0420DD 52 ED 42    0375*       sbc.s hl,bc
0420E0 30 02       0376*       jr nc,$+4
0420E2 52 09       0377*       add.s hl,bc
0420E4 17          0378*       rla
0420E5 52 ED 6A    0379*       adc.s hl,hl
0420E8 52 ED 42    0380*       sbc.s hl,bc
0420EB 30 02       0381*       jr nc,$+4
0420ED 52 09       0382*       add.s hl,bc
0420EF 17          0383*       rla
0420F0 52 ED 6A    0384*       adc.s hl,hl
0420F3 52 ED 42    0385*       sbc.s hl,bc
0420F6 30 02       0386*       jr nc,$+4
0420F8 52 09       0387*       add.s hl,bc
0420FA 17          0388*       rla
0420FB 2F          0389*       cpl
0420FC 57          0390*       ld d,a
0420FD             0391*   
0420FD 7B          0392*       ld a,e
0420FE 17          0393*       rla
0420FF 52 ED 6A    0394*       adc.s hl,hl
042102 52 ED 42    0395*       sbc.s hl,bc
042105 30 02       0396*       jr nc,$+4
042107 52 09       0397*       add.s hl,bc
042109 17          0398*       rla
04210A 52 ED 6A    0399*       adc.s hl,hl
04210D 52 ED 42    0400*       sbc.s hl,bc
042110 30 02       0401*       jr nc,$+4
042112 52 09       0402*       add.s hl,bc
042114 17          0403*       rla
042115 52 ED 6A    0404*       adc.s hl,hl
042118 52 ED 42    0405*       sbc.s hl,bc
04211B 30 02       0406*       jr nc,$+4
04211D 52 09       0407*       add.s hl,bc
04211F 17          0408*       rla
042120 52 ED 6A    0409*       adc.s hl,hl
042123 52 ED 42    0410*       sbc.s hl,bc
042126 30 02       0411*       jr nc,$+4
042128 52 09       0412*       add.s hl,bc
04212A 17          0413*       rla
04212B 52 ED 6A    0414*       adc.s hl,hl
04212E 52 ED 42    0415*       sbc.s hl,bc
042131 30 02       0416*       jr nc,$+4
042133 52 09       0417*       add.s hl,bc
042135 17          0418*       rla
042136 52 ED 6A    0419*       adc.s hl,hl
042139 52 ED 42    0420*       sbc.s hl,bc
04213C 30 02       0421*       jr nc,$+4
04213E 52 09       0422*       add.s hl,bc
042140 17          0423*       rla
042141 52 ED 6A    0424*       adc.s hl,hl
042144 52 ED 42    0425*       sbc.s hl,bc
042147 30 02       0426*       jr nc,$+4
042149 52 09       0427*       add.s hl,bc
04214B 17          0428*       rla
04214C 52 ED 6A    0429*       adc.s hl,hl
04214F 52 ED 42    0430*       sbc.s hl,bc
042152 30 02       0431*       jr nc,$+4
042154 52 09       0432*       add.s hl,bc
042156 17          0433*       rla
042157 2F          0434*       cpl
042158 5F          0435*       ld e,a
042159 C9          0436*       ret
04215A             0437*   
04215A             0438*   ;;End of div16
04215A             0043        include "../softfloat/internals.inc"
04215A             0001*   ; #define signF16UI( a ) ((bool) ((uint16_t) (a)>>15))
04215A             0002*       MACRO signF16UI
04215A             0003*           ld a,h
04215A             0004*           and %10000000
04215A             0005*           ld c,a
04215A             0006*       ENDMACRO
04215A             0007*   
04215A             0008*   ; #define expF16UI( a ) ((int_fast8_t) ((a)>>10) & 0x1F)
04215A             0009*       MACRO expF16UI
04215A             0010*           ld a,h
04215A             0011*           rrca
04215A             0012*           rrca
04215A             0013*           and %00011111
04215A             0014*           ld b,a
04215A             0015*       ENDMACRO
04215A             0016*   
04215A             0017*   ; #define fracF16UI( a ) ((a) & 0x03FF)
04215A             0018*       MACRO fracF16UI
04215A             0019*           ld a,h
04215A             0020*           and %00000011
04215A             0021*           ld h,a
04215A             0022*       ENDMACRO
04215A             0023*   
04215A             0024*   ; inputs: hl is the float16 to unpack
04215A             0025*   ; outputs: c is the sign (0=pos,1=neg), b is the biased exponent, hl is the normalised mantissa
04215A             0026*   ;          sign and zero flags are correctly (re)set, carry set if hl is +/-zero
04215A             0027*   ; destroys: a
04215A             0028*   softfloat16_unpack:
04215A             0029*   ; set sign
04215A 7C          0030*       ld a,h
04215B E6 80       0031*       and %10000000
04215D 4F          0032*       ld c,a ; sign
04215E             0033*   ; get hl's stored exponent and shift down twice
04215E 7C          0034*       ld a,h
04215F 0F          0035*       rrca
042160 0F          0036*       rrca
042161 E6 1F       0037*       and %00011111
042163 47          0038*       ld b,a ; biased exponent
042164 B7          0039*       or a ; check for zero
042165 20 10       0040*       jr nz,@check_special ; non-zero exponent means normal number
042167             0041*   ; check for zero or -zero
042167 CB BC       0042*       res 7,h ; clear sign bit
042169             0043*       SIGN_HL
                       M1 Args: none
042169 19          0001*M1     add hl,de
04216A B7          0002*M1     or a ; clear flags
04216B 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
04216E 28 1E       0044*       jr z,@is_zero ; result is zero so nothing more to do
042170             0045*   @is_sub:
042170 CD DE 21 04 0046*       call softfloat_normSubnormalF16Sig ; number is subnormal
042174 79          0047*       ld a,c ; get sign
042175 B7          0048*       or a ; (re)set sign flag and clear carry indicating non-zero result
042176 C9          0049*       ret
042177             0050*   @check_special:
042177             0051*   ; Check for special values - infinity and NaN
042177 FE 1F       0052*       cp 0x1F ; Is exponent 0x1F?
042179 20 06       0053*       jr nz,@is_nor ; non-zero exponent means normal number
04217B             0054*   ; mask out everything but the top tw bits of hl's mantissa
04217B 7C          0055*       ld a,h
04217C E6 03       0056*       and %00000011
04217E 67          0057*       ld h,a
04217F B7          0058*       or a ; reset carry indicating non-zero result
042180 C9          0059*       ret
042181             0060*   @is_nor:
042181             0061*   ; put the explicit 1 into the mantissa and (re)set sign flag
042181 CB D4       0062*       set 2,h
042183             0063*       SIGN_HL
                       M1 Args: none
042183 19          0001*M1     add hl,de
042184 B7          0002*M1     or a ; clear flags
042185 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
042188             0064*   ; mask out everything but the top three bits of hl's mantissa
042188 7C          0065*       ld a,h
042189 E6 07       0066*       and %00000111
04218B 67          0067*       ld h,a
04218C B7          0068*       or a ; reset carry indicating non-zero result
04218D C9          0069*       ret
04218E             0070*   @is_zero:
04218E 79          0071*       ld a,c ; get sign
04218F B7          0072*       or a ; (re)set sign flag
042190 37          0073*       scf ; set carry indicating zero result
042191 C9          0074*       ret
042192             0075*   ; end softfloat16_unpack
042192             0076*   
042192             0077*   
042192             0078*   ; #define packToF16UI( sign, exp, sig ) (((uint16_t) (sign)<<15) + ((uint16_t) (exp)<<10) + (sig))
042192             0079*   ; inputs: c = sign (0=pos, 0x80=neg), b = exp, hl = sig (implied 1 place in bit 10)
042192             0080*   packToF16UI:
042192             0081*       ; call dumpRegistersHex ; DEBUG
042192             0082*   ; exponent
042192 78          0083*       ld a,b
042193 87          0084*       add a,a
042194 87          0085*       add a,a
042195 84          0086*       add a,h
042196             0087*   ; sign
042196 81          0088*       add a,c
042197 67          0089*       ld h,a
042198             0090*       ; call dumpRegistersHex ; DEBUG
042198 C9          0091*       ret
042199             0092*   ; end packToF16UI
042199             0093*   
042199             0094*   ; #define isNaNF16UI( a ) (((~(a) & 0x7C00) == 0) && ((a) & 0x03FF))
042199             0044        include "../softfloat/globals.inc"
042199             0001*   canonicalNaNF16: EQU 0x7E00
042199             0002*   
042199             0003*   ; 16-bit floating point globals
042199             0004*       ; A group
042199             0005*       uiA:         EQU 0
042199             0006*       sigA:        EQU uiA + 3
042199             0007*       signA:       EQU sigA + 3
042199             0008*       expA:        EQU signA + 1
042199             0009*   
042199             0010*       ; B group
042199             0011*       uiB:         EQU expA + 2
042199             0012*       sigB:        EQU uiB + 3
042199             0013*       signB:       EQU sigB + 3
042199             0014*       expB:        EQU signB + 1
042199             0015*   
042199             0016*       ; X group
042199             0017*       sigX:        EQU expB + 2
042199             0018*       signX:       EQU sigX + 3
042199             0019*       expX:        EQU signX + 1
042199             0020*   
042199             0021*       ; Y group
042199             0022*       sigY:        EQU expX + 2
042199             0023*       signY:       EQU sigY + 3
042199             0024*       expY:        EQU signY + 1
042199             0025*   
042199             0026*       ; Z group
042199             0027*       uiZ:         EQU expY + 2
042199             0028*       sigZ:        EQU uiZ + 3
042199             0029*       signZ:       EQU sigZ + 3
042199             0030*       expZ:        EQU signZ + 1
042199             0031*   
042199             0032*       ; Shared / Misc
042199             0033*       expDiff:     EQU expZ + 2
042199             0034*       shiftDist:   EQU expDiff + 1
042199             0035*       sigDiff:     EQU shiftDist + 1
042199             0036*       r0:          EQU sigDiff + 3
042199             0037*   
042199             0038*   ; 32-bit floating point globals
042199             0039*       sig32A:      EQU r0 + 3
042199             0040*       sig32B:      EQU sig32A + 5
042199             0041*       sig32Z:      EQU sig32B + 5
042199             0042*       sig48Z:      EQU sig32Z + 5
042199             0043*   
042199             0044*   
042199             0045*   ; Global variable table
042199             0046*       s_globals:
042199             0047*   
042199 00 00 00    0048*       _uiA:          dl 0
04219C 00 00 00    0049*       _sigA:         dl 0
04219F 00          0050*       _signA:        db 0
0421A0 00          0051*       _expA:         db 0
0421A1 00          0052*                      db 0   ; padding
0421A2             0053*   
0421A2 00 00 00    0054*       _uiB:          dl 0
0421A5 00 00 00    0055*       _sigB:         dl 0
0421A8 00          0056*       _signB:        db 0
0421A9 00          0057*       _expB:         db 0
0421AA 00          0058*                      db 0   ; padding
0421AB             0059*   
0421AB             0060*       ; X group
0421AB 00 00 00    0061*       _sigX:         dl 0
0421AE 00          0062*       _signX:        db 0
0421AF 00          0063*       _expX:         db 0
0421B0 00          0064*                      db 0   ; padding
0421B1             0065*   
0421B1             0066*       ; Y group
0421B1 00 00 00    0067*       _sigY:         dl 0
0421B4 00          0068*       _signY:        db 0
0421B5 00          0069*       _expY:         db 0
0421B6 00          0070*                      db 0   ; padding
0421B7             0071*   
0421B7 00 00 00    0072*       _uiZ:          dl 0
0421BA 00 00 00    0073*       _sigZ:         dl 0
0421BD 00          0074*       _signZ:        db 0
0421BE 00          0075*       _expZ:         db 0
0421BF 00          0076*                      db 0   ; padding
0421C0             0077*   
0421C0 00          0078*       _expDiff:      db 0
0421C1 00          0079*       _shiftDist:    db 0
0421C2 00 00 00    0080*       _sigDiff:      dl 0
0421C5 00 00 00    0081*       _r0:           dl 0
0421C8             0082*   
0421C8 00 00 00 00 0083*       _sig32A:       blkb 5,0
       00          
0421CD 00 00 00 00 0084*       _sig32B:       blkb 5,0
       00          
0421D2 00 00 00 00 0085*       _sig32Z:       blkb 5,0
       00          
0421D7 00 00 00 00 0086*       _sig48Z:       blkb 7,0
       00 00 00    
0421DE             0045        include "../softfloat/s_normSubnormalF16Sig.inc"
0421DE             0001*   ; INLINE uint_fast8_t softfloat_countLeadingZeros16( uint16_t a )
0421DE             0002*   ;     { return a ? __builtin_clz( a ) - 16 : 16; }
0421DE             0003*   ; #define softfloat_countLeadingZeros16 softfloat_countLeadingZeros16
0421DE             0004*   
0421DE             0005*   ; struct exp8_sig16 softfloat_normSubnormalF16Sig( uint_fast16_t sig )
0421DE             0006*   ; {
0421DE             0007*   ;     int_fast8_t shiftDist;
0421DE             0008*   ;     struct exp8_sig16 z;
0421DE             0009*   
0421DE             0010*   ;     shiftDist = softfloat_countLeadingZeros16( sig ) - 5;
0421DE             0011*   ;     z.exp = 1 - shiftDist;
0421DE             0012*   ;     z.sig = sig<<shiftDist;
0421DE             0013*   ;     return z;
0421DE             0014*   
0421DE             0015*   ; }
0421DE             0016*   softfloat_normSubnormalF16Sig:
0421DE 06 01       0017*       ld b,1 ; set starting exponent
0421E0             0018*   @norm_loop:
0421E0 29          0019*       add hl,hl ; shift left
0421E1 05          0020*       dec b ; decrement exponent
0421E2 CB 54       0021*       bit 2,h ; test for carry into assumed 1 place
0421E4 28 FA       0022*       jr z,@norm_loop
0421E6 C9          0023*       ret
0421E7             0024*   ; end softfloat_normSubnormalF16Sig
0421E7             0046        include "../softfloat/s_roundPackToF16.inc"
0421E7             0001*   
0421E7             0002*   ; /*============================================================================
0421E7             0003*   
0421E7             0004*   ; This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
0421E7             0005*   ; Package, Release 3e, by John R. Hauser.
0421E7             0006*   
0421E7             0007*   ; Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
0421E7             0008*   ; California.  All rights reserved.
0421E7             0009*   
0421E7             0010*   ; Redistribution and use in source and binary forms, with or without
0421E7             0011*   ; modification, are permitted provided that the following conditions are met:
0421E7             0012*   
0421E7             0013*   ;  1. Redistributions of source code must retain the above copyright notice,
0421E7             0014*   ;     this list of conditions, and the following disclaimer.
0421E7             0015*   
0421E7             0016*   ;  2. Redistributions in binary form must reproduce the above copyright notice,
0421E7             0017*   ;     this list of conditions, and the following disclaimer in the documentation
0421E7             0018*   ;     and/or other materials provided with the distribution.
0421E7             0019*   
0421E7             0020*   ;  3. Neither the name of the University nor the names of its contributors may
0421E7             0021*   ;     be used to endorse or promote products derived from this software without
0421E7             0022*   ;     specific prior written permission.
0421E7             0023*   
0421E7             0024*   ; THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
0421E7             0025*   ; EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
0421E7             0026*   ; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
0421E7             0027*   ; DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
0421E7             0028*   ; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
0421E7             0029*   ; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
0421E7             0030*   ; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
0421E7             0031*   ; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0421E7             0032*   ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
0421E7             0033*   ; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0421E7             0034*   
0421E7             0035*   ; =============================================================================*/
0421E7             0036*   
0421E7             0037*   ; ===============================================================================
0421E7             0038*   ; eZ80 Assembly Implementation
0421E7             0039*   ; Original C code has been simplified so that only the default rounding options
0421E7             0040*   ; are used, and so branching tests are more ez80 friendly.
0421E7             0041*   ; ===============================================================================
0421E7             0042*   ; inputs: c = sign (0=pos, 0x80=neg), b = biased exp,
0421E7             0043*   ;         hl = sig (implied 1 place in bit 14, rounding bits in bits 0-3)
0421E7             0044*   ; outputs: hl = packed float16, c = sign (0=pos, 0x80=neg), b = biased exp
0421E7             0045*   ; destroys: af, de
0421E7             0046*   softfloat_roundPackToF16:
0421E7             0047*   ; uint_fast8_t roundIncrement = 0x8;
0421E7             0048*   ; uint_fast8_t roundBits = sig & 0xF;
0421E7             0049*   
0421E7             0050*   ; ; DEBUG
0421E7             0051*   ;     ld a,c
0421E7             0052*   ;     PRINT_A_HEX "sign"
0421E7             0053*   ;     ld a,b
0421E7             0054*   ;     PRINT_A_HEX "exp"
0421E7             0055*   ;     PRINT_HL_HEX_BIN "sigZ prior to rounding"
0421E7             0056*   ; ; END DEBUG
0421E7             0057*   
0421E7             0058*   ; if (exp < 0) {
0421E7 78          0059*       ld a,b ; get exponent
0421E8 FE 00       0060*       cp 0
0421EA F2 07 22 04 0061*       jp p,@check_overflow
0421EE             0062*   ;     // -----------------------------
0421EE             0063*   ;     // Subnormal / Underflow path
0421EE             0064*   ;     // -----------------------------
0421EE             0065*   ;     bool isTiny = (
0421EE             0066*   ;         softfloat_detectTininess == softfloat_tininess_beforeRounding ||
0421EE             0067*   ;         exp < -1 ||
0421EE             0068*   ;         sig + roundIncrement < 0x8000
0421EE             0069*   ;     );
0421EE             0070*   ;     sig = softfloat_shiftRightJam32(sig, -exp);
0421EE ED 44       0071*           neg ; negate exponent
0421F0 EB          0072*           ex de,hl ; move hl to lower bytes of the 32 bit argument
0421F1 21 00 00 00 0073*           ld hl,0 ; upper bytes of 32 bit argument to zero
0421F5 CD 65 22 04 0074*           call softfloat_shiftRightJam32
0421F9 EB          0075*           ex de,hl ; shifted/jammed sig back to hl
0421FA             0076*   ;     exp = 0;
0421FA 06 00       0077*           ld b,0
0421FC             0078*   ;     roundBits = sig & 0xF;
0421FC 3E 0F       0079*           ld a,0x0F
0421FE A5          0080*           and l
0421FF 57          0081*           ld d,a ; store roundBits
042200             0082*   ;     if (isTiny && roundBits) {
042200 28 16       0083*           jr z,@do_rounding ; skip if roundBits is zero
042202 A0          0084*           and a,b ; check exponent for 0 (tiny)
042203 28 13       0085*           jr z,@do_rounding ; skip if exponent is zero
042205             0086*   ;         softfloat_raiseFlags(softfloat_flag_underflow);
042205             0087*   ;     }
042205 18 11       0088*           jr @do_rounding
042207             0089*   ; }
042207             0090*   @check_overflow:
042207             0091*       ; } else if ( (0x1D < exp) || (0x8000 <= sig + roundIncrement) ) {
042207             0092*       ;     softfloat_raiseFlags(
042207             0093*       ;         softfloat_flag_overflow | softfloat_flag_inexact );
042207             0094*       ;     uiZ = packToF16UI( sign, 0x1F, 0 ) - ! roundIncrement;
042207 FE 1E       0095*           cp 0x1E
042209 30 50       0096*           jr nc,@return_inf ; return inf if exp < 0x1D
04220B 20 0B       0097*           jr nz,@do_rounding ; skip if exp != 0x1E (meaning we can round up without going to inf)
04220D EB          0098*           ex de,hl ; preserve sig in de for upcoming test
04220E 21 F7 7F 00 0099*           ld hl,0x8000 - 0x0008 - 1 ; 0x8000 - roundIncrement = 0x7FF7
042212 B7          0100*           or a ; clear carry
042213 ED 52       0101*           sbc hl, de           ; HL = 0x7FF7 - DE
042215 EB          0102*           ex de, hl
042216 38 43       0103*           jr c, @return_inf    ; if sig > 0x7FF7, overflow
042218             0104*   ; }
042218             0105*   @do_rounding:
042218             0106*   ; roundBits = sig & 0xF
042218 3E 0F       0107*       ld a,0x0F
04221A A5          0108*       and l
04221B 57          0109*       ld d,a ; store roundBits
04221C             0110*   ; sig = (sig + roundIncrement) >> 4;
04221C             0111*   ; add round increment
04221C 7D          0112*       ld a,l
04221D C6 08       0113*       add 0x08
04221F 6F          0114*       ld l,a
042220 7C          0115*       ld a,h
042221 CE 00       0116*       adc a,0
042223 67          0117*       ld h,a
042224             0118*   ; shift right by 4 bits
042224             0119*   ; once
042224 B7          0120*       or a ; clear carry
042225 CB 1C       0121*       rr h
042227 CB 1D       0122*       rr l
042229             0123*   ; twice
042229 B7          0124*       or a
04222A CB 1C       0125*       rr h
04222C CB 1D       0126*       rr l
04222E B7          0127*       or a
04222F             0128*   ; thrice
04222F B7          0129*       or a
042230 CB 1C       0130*       rr h
042232 CB 1D       0131*       rr l
042234             0132*   ; four times
042234 B7          0133*       or a
042235 CB 1C       0134*       rr h
042237 CB 1D       0135*       rr l
042239             0136*   ; if (roundBits) {
042239             0137*   ;     softfloat_exceptionFlags |= softfloat_flag_inexact;
042239             0138*   ; }
042239             0139*       ; d == roundBits
042239 7A          0140*       ld a,d
04223A FE 08       0141*       cp 0x08
04223C C2 4C 22 04 0142*       jp nz,@check_sig_zero      ; Not exactly halfway -> skip
042240             0143*       ; Exactly halfway => round to even.
042240 CB 45       0144*       bit 0,l                    ; Test LSB of HL
042242 CA 4C 22 04 0145*       jp z,@check_sig_zero       ; If LSB = 0 (already even), skip
042246 CB 85       0146*       res 0,l                    ; Else clear LSB => rounding to even
042248 C3 92 21 04 0147*       jp packToF16UI
04224C             0148*   ; if (!sig) {
04224C             0149*   @check_sig_zero:
04224C             0150*       SIGN_HL
                       M1 Args: none
04224C 19          0001*M1     add hl,de
04224D B7          0002*M1     or a ; clear flags
04224E 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
042251 C2 92 21 04 0151*       jp nz,packToF16UI ; skip if sig is not zero
042255             0152*   ;     exp = 0;
042255 06 00       0153*           ld b,0
042257             0154*   ; }
042257             0155*   ; return packToF16UI(sign, exp, sig);
042257 C3 92 21 04 0156*       jp packToF16UI
04225B             0157*   @return_inf:
04225B             0158*   ; // -----------------------------
04225B             0159*   ; // Overflow after rounding
04225B             0160*   ; // -----------------------------
04225B             0161*   ; softfloat_raiseFlags(softfloat_flag_overflow | softfloat_flag_inexact);
04225B             0162*   ; return packToF16UI(sign, 0x1F, 0) - !roundIncrement;
04225B 21 00 7C 00 0163*       ld hl,0x7C00
04225F 79          0164*       ld a,c ; get sign
042260 B4          0165*       or h
042261 67          0166*       ld h,a
042262 06 1F       0167*       ld b,0x1F ; exponent
042264 C9          0168*       ret
042265             0169*   ; end softfloat_roundPackToF16
042265             0047        include "../softfloat/s_shiftRightJam32.inc"
042265             0001*   ; /*----------------------------------------------------------------------------
042265             0002*   ; | Shifts 'a' right by the number of bits given in 'dist', which must not
042265             0003*   ; | be zero.  If any nonzero bits are shifted off, they are "jammed" into the
042265             0004*   ; | least-significant bit of the shifted value by setting the least-significant
042265             0005*   ; | bit to 1.  This shifted-and-jammed value is returned.
042265             0006*   ; |   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
042265             0007*   ; | greater than 32, the result will be either 0 or 1, depending on whether 'a'
042265             0008*   ; | is zero or nonzero.
042265             0009*   ; *----------------------------------------------------------------------------*/
042265             0010*   ;
042265             0011*   ; uint32_t softfloat_shiftRightJam32( uint32_t a, uint_fast16_t dist )
042265             0012*   ; {
042265             0013*   
042265             0014*   ;     return
042265             0015*   ;         (dist < 31) ? a>>dist | ((uint32_t) (a<<(-dist & 31)) != 0) : (a != 0);
042265             0016*   
042265             0017*   ; }
042265             0018*   ;
042265             0019*   ; Inputs: HLDE = 32-bit unsigned integer to shift (most to least significant byte)
042265             0020*   ;          A = number of bits to shift right (0–255, only 0–31 meaningful)
042265             0021*   ;
042265             0022*   ; Outputs: HLDE = shifted result, with LSB jammed (bit 0 set) if any 1s were shifted out
042265             0023*   ;          A = jam bit (0 or 1)
042265             0024*   
042265             0025*   softfloat_shiftRightJam32:
042265             0026*       ; call dumpRegistersHex
042265             0027*   
042265 C5          0028*       push bc ; preserve b
042266 47          0029*       ld b,a ; loop counter
042267 AF          0030*       xor a ; zero jam bits and clear carry
042268             0031*   @shift_loop:
042268 CB 1C       0032*       rr h
04226A CB 1D       0033*       rr l
04226C CB 1A       0034*       rr d
04226E CB 1B       0035*       rr e
042270 CE 00       0036*       adc a,0 ; jam bit
042272 B7          0037*       or a ; clear carry
042273 10 F3       0038*       djnz @shift_loop
042275 B7          0039*       or a ; check whether to set jam bit
042276 28 02       0040*       jr z, @done ; no jam bit set
042278 CB C3       0041*       set 0,e ; set jam bit to LSB
04227A             0042*   @done:
04227A C1          0043*       pop bc ; restore b
04227B C9          0044*       ret
04227C             0045*   ; end softfloat_shiftRightJam32
04227C             0048    
04227C             0049    main:
04227C CD EE 13 04 0050        call vdu_cls
042280 CD 5C 00 04 0051        call printInline
042284 0D 0A 66 31 0052        asciz "\r\nf16_div test\r\n"
       36 5F 64 69 
       76 20 74 65 
       73 74 0D 0A 
       00          
042295 21 08 00 00 0053        ld hl,8
042299 22 47 23 04 0054        ld (bytes_per_record),hl
04229D 21 00 53 07 0055        ld hl,480000
0422A1 22 44 23 04 0056        ld (bytes_read_max),hl
0422A5 CD 4A 23 04 0057        call test_init ; open files for reading and writing
0422A9 C8          0058        ret z ; error opening files
0422AA             0059    @read_loop:
0422AA CD B5 23 04 0060        call test_read_data
0422AE 28 57       0061        jr z,@read_end
0422B0 FD 21 00 26 0062        ld iy,filedata
       04          
0422B5             0063    @calc_loop:
0422B5             0064    ; perform division
0422B5 FD 6E 00    0065        ld l,(iy+0) ; op1 low byte
0422B8 FD 66 01    0066        ld h,(iy+1) ; op1 high byte
0422BB FD 5E 02    0067        ld e,(iy+2) ; op2 low byte
0422BE FD 56 03    0068        ld d,(iy+3) ; op2 high byte
0422C1 CD A2 1E 04 0069        call f16_div
0422C5             0070    ; write results to file buffer
0422C5 FD 75 06    0071        ld (iy+6),l ; assembly quotient low byte
0422C8 FD 74 07    0072        ld (iy+7),h ; assembly quotient high byte
0422CB             0073    ; check for error
0422CB FD 5E 04    0074        ld e,(iy+4) ; python quotient low byte
0422CE FD 56 05    0075        ld d,(iy+5) ; python quotient high byte
0422D1 B7          0076        or a ; clear carry
0422D2 52 ED 52    0077        sbc.s hl,de
0422D5 28 09       0078        jr z,@next_record
0422D7             0079    ; bump error count
0422D7 2A 35 23 04 0080        ld hl,(errors)
0422DB 23          0081        inc hl
0422DC 22 35 23 04 0082        ld (errors),hl
0422E0             0083    @next_record:
0422E0             0084    ; write results to file buffer
0422E0 ED 5B 47 23 0085        ld de,(bytes_per_record)
       04          
0422E5 FD 19       0086        add iy,de; bump data pointer
0422E7 2A 38 23 04 0087        ld hl,(records)
0422EB 23          0088        inc hl
0422EC 22 38 23 04 0089        ld (records),hl
0422F0 2A 3B 23 04 0090        ld hl,(counter)
0422F4 2B          0091        dec hl
0422F5 22 3B 23 04 0092        ld (counter),hl
0422F9             0093        SIGN_HLU
                       M1 Args: none
0422F9 19          0001M1      add hl,de ; 1 cycle
0422FA B7          0002M1      or a ; clear flags ; 1 cycle
0422FB ED 52       0003M1      sbc hl,de ; 2 cycles
0422FD             0004M1      ; 4 cycles total
0422FD 20 B6       0094        jr nz,@calc_loop
0422FF             0095    ; write to file
0422FF CD 1F 24 04 0096        call test_write_data
042303             0097    ; read next batch from file
042303 C3 AA 22 04 0098        jp @read_loop
042307             0099    @read_end:
042307 C3 5A 24 04 0100        jp test_complete
04230B             0101    
04230B 2E 2E 2F 74 0102    test_filename: asciz "../tests/f16_div.bin"
       65 73 74 73 
       2F 66 31 36 
       5F 64 69 76 
       2E 62 69 6E 
       00          
042320 2E 2E 2F 74 0103    test_filename_out: asciz "../tests/f16_div.bin"
       65 73 74 73 
       2F 66 31 36 
       5F 64 69 76 
       2E 62 69 6E 
       00          
042335             0104    
042335             0105        include "../include/files.inc"
042335             0001*   ; filedata: equ 0xB7E000 ; address of onboard 8k sram
042335 00 00 00    0002*   errors: dl 0
042338 00 00 00    0003*   records: dl 0
04233B 00 00 00    0004*   counter: dl 0
04233E 00 00 00    0005*   time: dl 0
042341 00 00 00    0006*   bytes_read: dl 0
042344 00 00 00    0007*   bytes_read_max: dl 0
042347 00 00 00    0008*   bytes_per_record: dl 0
04234A             0009*   
04234A             0010*   test_init:
04234A             0011*   ; set up counters
04234A 21 00 00 00 0012*       ld hl,0 ; error counter
04234E 22 35 23 04 0013*       ld (errors),hl ; error counter
042352 22 38 23 04 0014*       ld (records),hl ; record counter
042356 22 3E 23 04 0015*       ld (time),hl ; time counter
04235A             0016*   ; open file for reading
04235A CD BF 24 04 0017*       call open_infile_read
04235E B7          0018*       or a
04235F 20 27       0019*       jr nz,@open_outfile
042361 CD 5C 00 04 0020*       call printInline
042365 45 72 72 6F 0021*       asciz "Error opening file for reading\r\n"
       72 20 6F 70 
       65 6E 69 6E 
       67 20 66 69 
       6C 65 20 66 
       6F 72 20 72 
       65 61 64 69 
       6E 67 0D 0A 
       00          
042386 18 2B       0022*       jr @error
042388             0023*   @open_outfile:
042388             0024*   ; open file for writing
042388 CD DD 24 04 0025*       call open_outfile_write
04238C B7          0026*       or a
04238D C0          0027*       ret nz
04238E CD 5C 00 04 0028*       call printInline
042392 45 72 72 6F 0029*       asciz "Error opening file for writing\r\n"
       72 20 6F 70 
       65 6E 69 6E 
       67 20 66 69 
       6C 65 20 66 
       6F 72 20 77 
       72 69 74 69 
       6E 67 0D 0A 
       00          
0423B3             0030*   @error:
0423B3 AF          0031*       xor a ; return zero indicating error
0423B4 C9          0032*       ret
0423B5             0033*   
0423B5             0034*   test_read_data:
0423B5             0035*   ; read data from file
0423B5 3A 07 25 04 0036*       ld a,(test_file_in_handle)
0423B9 4F          0037*       ld c,a
0423BA 21 00 26 04 0038*       ld hl,filedata
0423BE ED 5B 44 23 0039*       ld de,(bytes_read_max) ; max bytes to read
       04          
0423C3             0040*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
0423C3 3E 1A       0001*M1 			LD	A, function
0423C5 5B CF       0002*M1 			RST.LIL	08h
0423C7 ED 53 41 23 0041*       ld (bytes_read),de
       04          
0423CC EB          0042*       ex de,hl
0423CD             0043*       SIGN_HLU
                       M1 Args: none
0423CD 19          0001*M1     add hl,de ; 1 cycle
0423CE B7          0002*M1     or a ; clear flags ; 1 cycle
0423CF ED 52       0003*M1     sbc hl,de ; 2 cycles
0423D1             0004*M1     ; 4 cycles total
0423D1 C8          0044*       ret z
0423D2             0045*   ; compute number of records in batch
0423D2 E5          0046*       push hl
0423D3 ED 5B 47 23 0047*       ld de,(bytes_per_record) ; bytes per record
       04          
0423D8 CD 92 04 04 0048*       call udiv24
0423DC ED 53 3B 23 0049*       ld (counter),de ; record counter
       04          
0423E1 EB          0050*       ex de,hl
0423E2 CD C8 00 04 0051*       call printDec
0423E6 CD 5C 00 04 0052*       call printInline
0423EA 20 72 65 63 0053*       asciz " records in batch"
       6F 72 64 73 
       20 69 6E 20 
       62 61 74 63 
       68 00       
0423FC E1          0054*       pop hl
0423FD             0055*   ; output bytes read
0423FD CD C8 00 04 0056*       call printDec
042401 CD 5C 00 04 0057*       call printInline
042405 20 62 79 74 0058*       asciz " bytes read"
       65 73 20 72 
       65 61 64 00 
042411             0059*   ; start stopwatch
042411 CD F3 13 04 0060*       call vdu_flip
042415 CD 24 13 04 0061*       call stopwatch_set
042419             0062*   ; reset data pointer
042419 DD 21 00 26 0063*       ld ix,filedata
       04          
04241E C9          0064*       ret
04241F             0065*   
04241F             0066*   test_write_data:
04241F             0067*   ; get elapsed time
04241F CD 30 13 04 0068*       call stopwatch_get
042423 ED 5B 3E 23 0069*       ld de,(time)
       04          
042428 19          0070*       add hl,de
042429 22 3E 23 04 0071*       ld (time),hl
04242D             0072*   ; write data to file
04242D 3A 09 25 04 0073*       ld a,(test_file_out_write_handle)
042431 4F          0074*       ld c,a
042432 21 00 26 04 0075*       ld hl,filedata
042436 ED 5B 41 23 0076*       ld de,(bytes_read) ; bytes to write
       04          
04243B             0077*       MOSCALL mos_fwrite
                       M1 Args: function=mos_fwrite 
04243B 3E 1B       0001*M1 			LD	A, function
04243D 5B CF       0002*M1 			RST.LIL	08h
04243F EB          0078*       ex de,hl
042440 CD C8 00 04 0079*       call printDec
042444 CD 5C 00 04 0080*       call printInline
042448 20 62 79 74 0081*       asciz " bytes written\r\n"
       65 73 20 77 
       72 69 74 74 
       65 6E 0D 0A 
       00          
042459 C9          0082*       ret
04245A             0083*   
04245A             0084*   test_complete:
04245A             0085*   ; close files
04245A CD EC 24 04 0086*       call close_infile
04245E CD FE 24 04 0087*       call close_outfile_write
042462             0088*   ; report elapsed time
042462 2A 3E 23 04 0089*       ld hl,(time)
042466 29          0090*       add hl,hl
042467 29          0091*       add hl,hl
042468 29          0092*       add hl,hl
042469 29          0093*       add hl,hl
04246A 29          0094*       add hl,hl
04246B 29          0095*       add hl,hl
04246C 29          0096*       add hl,hl
04246D 29          0097*       add hl,hl
04246E 11 00 78 00 0098*       ld de,120*256 ; ticks per second in 16.8 fixed point
042472 CD 88 06 04 0099*       call udiv168
042476 CD A7 02 04 0100*       call print_s168_de
04247A CD 5C 00 04 0101*       call printInline
04247E 20 73 65 63 0102*       asciz " seconds elapsed\r\n"
       6F 6E 64 73 
       20 65 6C 61 
       70 73 65 64 
       0D 0A 00    
042491             0103*   ; display error count
042491 2A 35 23 04 0104*       ld hl,(errors)
042495 CD C8 00 04 0105*       call printDec
042499 CD 5C 00 04 0106*       call printInline
04249D 20 65 72 72 0107*       asciz " errors\r\n"
       6F 72 73 0D 
       0A 00       
0424A7             0108*   ; display record count
0424A7 2A 38 23 04 0109*       ld hl,(records)
0424AB CD C8 00 04 0110*       call printDec
0424AF CD 5C 00 04 0111*       call printInline
0424B3 20 72 65 63 0112*       asciz " records\r\n"
       6F 72 64 73 
       0D 0A 00    
0424BE C9          0113*       ret
0424BF             0114*   
0424BF             0115*   
0424BF             0116*   open_infile_read:
0424BF             0117*   ; open file for reading
0424BF 21 0B 23 04 0118*       ld hl,test_filename
0424C3 0E 01       0119*       ld c,fa_read
0424C5             0120*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
0424C5 3E 0A       0001*M1 			LD	A, function
0424C7 5B CF       0002*M1 			RST.LIL	08h
0424C9 32 07 25 04 0121*       ld (test_file_in_handle),a
0424CD C9          0122*       ret
0424CE             0123*   
0424CE             0124*   open_outfile_read:
0424CE             0125*   ; open file for reading
0424CE 21 20 23 04 0126*       ld hl,test_filename_out
0424D2 0E 01       0127*       ld c,fa_read
0424D4             0128*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
0424D4 3E 0A       0001*M1 			LD	A, function
0424D6 5B CF       0002*M1 			RST.LIL	08h
0424D8 32 08 25 04 0129*       ld (test_file_out_read_handle),a
0424DC C9          0130*       ret
0424DD             0131*   
0424DD             0132*   open_outfile_write:
0424DD             0133*   ; open file for writing
0424DD 21 20 23 04 0134*       ld hl,test_filename_out
0424E1 0E 02       0135*       ld c,fa_write | fa_open_existing
0424E3             0136*       ; ld c,fa_write | fa_create_always
0424E3             0137*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
0424E3 3E 0A       0001*M1 			LD	A, function
0424E5 5B CF       0002*M1 			RST.LIL	08h
0424E7 32 09 25 04 0138*       ld (test_file_out_write_handle),a
0424EB C9          0139*       ret
0424EC             0140*   
0424EC             0141*   close_infile:
0424EC 3A 07 25 04 0142*       ld a,(test_file_in_handle)
0424F0             0143*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
0424F0 3E 0B       0001*M1 			LD	A, function
0424F2 5B CF       0002*M1 			RST.LIL	08h
0424F4 C9          0144*       ret
0424F5             0145*   
0424F5             0146*   close_outfile_read:
0424F5 3A 08 25 04 0147*       ld a,(test_file_out_read_handle)
0424F9             0148*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
0424F9 3E 0B       0001*M1 			LD	A, function
0424FB 5B CF       0002*M1 			RST.LIL	08h
0424FD C9          0149*       ret
0424FE             0150*   
0424FE             0151*   close_outfile_write:
0424FE 3A 09 25 04 0152*       ld a,(test_file_out_write_handle)
042502             0153*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
042502 3E 0B       0001*M1 			LD	A, function
042504 5B CF       0002*M1 			RST.LIL	08h
042506 C9          0154*       ret
042507             0155*   
042507 00          0156*   test_file_in_handle: db 0
042508 00          0157*   test_file_out_read_handle: db 0
042509 00          0158*   test_file_out_write_handle: db 0
04250A             0159*   
04250A             0160*   test_fil: equ $
04250A             0161*   test_filinfo: equ test_fil + fil_struct_size
04250A             0162*   
04250A             0163*   test_fil_out: equ test_filinfo + filinfo_struct_size
04250A             0164*   test_filinfo_out: equ test_fil_out + fil_struct_size
04250A             0165*   
04250A             0166*       align 256
042600             0167*   
042600             0168*   filedata: equ $
