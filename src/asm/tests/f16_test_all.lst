PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004             0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C             0015    
04004C CD A9 42 04 0016        call main
040050             0017    exit:
040050 FD E1       0018        pop iy
040052 DD E1       0019        pop ix
040054 D1          0020        pop de
040055 C1          0021        pop bc
040056 F1          0022        pop af
040057 21 00 00 00 0023        ld hl,0
04005B             0024    
04005B C9          0025        ret
04005C             0026    
04005C             0027        include "../agon/mos_api.inc"
04005C             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04005C             0002*   ; Title:	AGON MOS - API for user projects
04005C             0003*   ; Author:	Dean Belfield
04005C             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
04005C             0005*   ;			Added MOS error codes for return in HL
04005C             0006*   ; Created:	03/08/2022
04005C             0007*   ; Last Updated:	10/08/2023
04005C             0008*   ;
04005C             0009*   ; Modinfo:
04005C             0010*   ; 05/08/2022:	Added mos_feof
04005C             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
04005C             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04005C             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04005C             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
04005C             0015*   ; 13/10/2022:	Added mos_oscli
04005C             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04005C             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
04005C             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04005C             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04005C             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04005C             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
04005C             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04005C             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04005C             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04005C             0025*   ; 19/05/2023:	Added sysvar_scrMode
04005C             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
04005C             0027*   ; 03/08/2023:	Added mos_setkbvector
04005C             0028*   ; 10/08/2023:	Added mos_getkbmap
04005C             0029*   
04005C             0030*   ; VDP control (VDU 23, 0, n)
04005C             0031*   ;
04005C             0032*   vdp_gp:				EQU 80h
04005C             0033*   vdp_keycode:		EQU 81h
04005C             0034*   vdp_cursor:			EQU	82h
04005C             0035*   vdp_scrchar:		EQU	83h
04005C             0036*   vdp_scrpixel:		EQU	84h
04005C             0037*   vdp_audio:			EQU	85h
04005C             0038*   vdp_mode:			EQU	86h
04005C             0039*   vdp_rtc:			EQU	87h
04005C             0040*   vdp_keystate:		EQU	88h
04005C             0041*   vdp_logicalcoords:	EQU	C0h
04005C             0042*   vdp_terminalmode:	EQU	FFh
04005C             0043*   
04005C             0044*   ; MOS high level functions
04005C             0045*   ;
04005C             0046*   mos_getkey:			EQU	00h
04005C             0047*   mos_load:			EQU	01h
04005C             0048*   mos_save:			EQU	02h
04005C             0049*   mos_cd:				EQU	03h
04005C             0050*   mos_dir:			EQU	04h
04005C             0051*   mos_del:			EQU	05h
04005C             0052*   mos_ren:			EQU	06h
04005C             0053*   mos_mkdir:			EQU	07h
04005C             0054*   mos_sysvars:		EQU	08h
04005C             0055*   mos_editline:		EQU	09h
04005C             0056*   mos_fopen:			EQU	0Ah
04005C             0057*   mos_fclose:			EQU	0Bh
04005C             0058*   mos_fgetc:			EQU	0Ch
04005C             0059*   mos_fputc:			EQU	0Dh
04005C             0060*   mos_feof:			EQU	0Eh
04005C             0061*   mos_getError:		EQU	0Fh
04005C             0062*   mos_oscli:			EQU	10h
04005C             0063*   mos_copy:			EQU	11h
04005C             0064*   mos_getrtc:			EQU	12h
04005C             0065*   mos_setrtc:			EQU	13h
04005C             0066*   mos_setintvector:	EQU	14h
04005C             0067*   mos_uopen:			EQU	15h
04005C             0068*   mos_uclose:			EQU	16h
04005C             0069*   mos_ugetc:			EQU	17h
04005C             0070*   mos_uputc:			EQU	18h
04005C             0071*   mos_getfil:			EQU	19h
04005C             0072*   mos_fread:			EQU	1Ah
04005C             0073*   mos_fwrite:			EQU	1Bh
04005C             0074*   mos_flseek:			EQU	1Ch
04005C             0075*   mos_setkbvector:	EQU	1Dh
04005C             0076*   mos_getkbmap:		EQU	1Eh
04005C             0077*   
04005C             0078*   ; MOS program exit codes
04005C             0079*   ;
04005C             0080*   EXIT_OK:				EQU  0;	"OK",
04005C             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04005C             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04005C             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04005C             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04005C             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04005C             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04005C             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04005C             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04005C             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04005C             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04005C             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04005C             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04005C             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04005C             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04005C             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04005C             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04005C             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04005C             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04005C             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04005C             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04005C             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04005C             0102*   ; FatFS file access functions
04005C             0103*   ;
04005C             0104*   ffs_fopen:			EQU	80h
04005C             0105*   ffs_fclose:			EQU	81h
04005C             0106*   ffs_fread:			EQU	82h
04005C             0107*   ffs_fwrite:			EQU	83h
04005C             0108*   ffs_flseek:			EQU	84h
04005C             0109*   ffs_ftruncate:		EQU	85h
04005C             0110*   ffs_fsync:			EQU	86h
04005C             0111*   ffs_fforward:		EQU	87h
04005C             0112*   ffs_fexpand:		EQU	88h
04005C             0113*   ffs_fgets:			EQU	89h
04005C             0114*   ffs_fputc:			EQU	8Ah
04005C             0115*   ffs_fputs:			EQU	8Bh
04005C             0116*   ffs_fprintf:		EQU	8Ch
04005C             0117*   ffs_ftell:			EQU	8Dh
04005C             0118*   ffs_feof:			EQU	8Eh
04005C             0119*   ffs_fsize:			EQU	8Fh
04005C             0120*   ffs_ferror:			EQU	90h
04005C             0121*   
04005C             0122*   ; FatFS directory access functions
04005C             0123*   ;
04005C             0124*   ffs_dopen:			EQU	91h
04005C             0125*   ffs_dclose:			EQU	92h
04005C             0126*   ffs_dread:			EQU	93h
04005C             0127*   ffs_dfindfirst:		EQU	94h
04005C             0128*   ffs_dfindnext:		EQU	95h
04005C             0129*   
04005C             0130*   ; FatFS file and directory management functions
04005C             0131*   ;
04005C             0132*   ffs_stat:			EQU	96h
04005C             0133*   ffs_unlink:			EQU	97h
04005C             0134*   ffs_rename:			EQU	98h
04005C             0135*   ffs_chmod:			EQU	99h
04005C             0136*   ffs_utime:			EQU	9Ah
04005C             0137*   ffs_mkdir:			EQU	9Bh
04005C             0138*   ffs_chdir:			EQU	9Ch
04005C             0139*   ffs_chdrive:		EQU	9Dh
04005C             0140*   ffs_getcwd:			EQU	9Eh
04005C             0141*   
04005C             0142*   ; FatFS volume management and system configuration functions
04005C             0143*   ;
04005C             0144*   ffs_mount:			EQU	9Fh
04005C             0145*   ffs_mkfs:			EQU	A0h
04005C             0146*   ffs_fdisk:			EQU	A1h
04005C             0147*   ffs_getfree:		EQU	A2h
04005C             0148*   ffs_getlabel:		EQU	A3h
04005C             0149*   ffs_setlabel:		EQU	A4h
04005C             0150*   ffs_setcp:			EQU	A5h
04005C             0151*   
04005C             0152*   ; File access modes
04005C             0153*   ;
04005C             0154*   fa_read:			EQU	01h
04005C             0155*   fa_write:			EQU	02h
04005C             0156*   fa_open_existing:	EQU	00h
04005C             0157*   fa_create_new:		EQU	04h
04005C             0158*   fa_create_always:	EQU	08h
04005C             0159*   fa_open_always:		EQU	10h
04005C             0160*   fa_open_append:		EQU	30h
04005C             0161*   
04005C             0162*   ; System variable indexes for api_sysvars
04005C             0163*   ; Index into _sysvars in globals.inc
04005C             0164*   ;
04005C             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04005C             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04005C             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04005C             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04005C             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04005C             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04005C             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04005C             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04005C             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04005C             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04005C             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04005C             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04005C             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04005C             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04005C             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04005C             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04005C             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04005C             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04005C             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04005C             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04005C             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04005C             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04005C             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04005C             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04005C             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
04005C             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04005C             0191*   
04005C             0192*   ; Flags for the VPD protocol
04005C             0193*   ;
04005C             0194*   vdp_pflag_cursor:		EQU	00000001b
04005C             0195*   vdp_pflag_scrchar:		EQU	00000010b
04005C             0196*   vdp_pflag_point:		EQU	00000100b
04005C             0197*   vdp_pflag_audio:		EQU	00001000b
04005C             0198*   vdp_pflag_mode:			EQU	00010000b
04005C             0199*   vdp_pflag_rtc:			EQU	00100000b
04005C             0200*   
04005C             0201*   ;
04005C             0202*   ; FatFS structures
04005C             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04005C             0204*   ;
04005C             0205*   ; Object ID and allocation information (FFOBJID)
04005C             0206*   ;
04005C             0207*   ; Indexes into FFOBJID structure
04005C             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04005C             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04005C             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
04005C             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04005C             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04005C             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04005C             0214*   ;
04005C             0215*   ; File object structure (FIL)
04005C             0216*   ;
04005C             0217*   ; Indexes into FIL structure
04005C             0218*   fil_obj:		EQU 0	; 15: Object identifier
04005C             0219*   fil_flag:		EQU	15 	;  1: File status flags
04005C             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
04005C             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04005C             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04005C             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04005C             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04005C             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04005C             0226*   fil_struct_size: EQU fil_dir_ptr+3 ; size of the FIL structure
04005C             0227*   ;
04005C             0228*   ; Directory object structure (DIR)
04005C             0229*   ; Indexes into DIR structure
04005C             0230*   dir_obj:		EQU  0	; 15: Object identifier
04005C             0231*   dir_dptr:		EQU	15	;  4: Current read/write offset
04005C             0232*   dir_clust:		EQU	19	;  4: Current cluster
04005C             0233*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04005C             0234*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04005C             0235*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04005C             0236*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04005C             0237*   dir_struct_size:	EQU	46	;  4: Size of the struct
04005C             0238*   ;
04005C             0239*   ; File information structure (FILINFO)
04005C             0240*   ;
04005C             0241*   ; Indexes into FILINFO structure
04005C             0242*   filinfo_fsize:		EQU 0	;   4: File size
04005C             0243*   filinfo_fdate:		EQU	4	;   2: Modified date
04005C             0244*   filinfo_ftime:		EQU	6	;   2: Modified time
04005C             0245*   filinfo_fattrib:	EQU	8	;   1: File attribute
04005C             0246*   filinfo_altname:	EQU	9	;  13: Alternative file name
04005C             0247*   filinfo_fname:		EQU	22	; 256: Primary file name
04005C             0248*   filinfo_struct_size: EQU filinfo_fname+256 ; size of the FILINFO structure
04005C             0249*   
04005C             0250*   ; /* File attribute bits for directory entry (FILINFO.fattrib) */
04005C             0251*   AM_RDO: equ 0 ; Bit 0 - Read Only
04005C             0252*   AM_HID: equ 1 ; Bit 1 - Hidden
04005C             0253*   AM_SYS: equ 2 ; Bit 2 - System
04005C             0254*   AM_DIR: equ 4 ; Bit 4 - Directory
04005C             0255*   AM_ARC: equ 5 ; Bit 5 - Archive
04005C             0256*   
04005C             0257*   ;
04005C             0258*   ; Macro for calling the API
04005C             0259*   ; Parameters:
04005C             0260*   ; - function: One of the function numbers listed above
04005C             0261*   ;
04005C             0262*   	MACRO	MOSCALL	function
04005C             0263*   			LD	A, function
04005C             0264*   			RST.LIL	08h
04005C             0265*   	ENDMACRO
04005C             0266*   
04005C             0267*   ;
04005C             0268*   ; Same as above but keeps IY safe on FFS calls
04005C             0269*   ; (can be use for regular MOS calls as well)
04005C             0270*   ;
04005C             0271*   	MACRO	FFSCALL	function
04005C             0272*   			PUSH IY
04005C             0273*   			LD	A, function
04005C             0274*   			RST.LIL	08h
04005C             0275*   			POP IY
04005C             0276*   	ENDMACRO
04005C             0028        include "../agon/macros.inc"
04005C             0001*   
04005C             0002*   ; test the sign of UHL
04005C             0003*   ; inputs: UHL obviously
04005C             0004*   ; outputs: sign flag set if UHL is negative, zero flag set if UHL is zero
04005C             0005*       MACRO SIGN_UHL
04005C             0006*       add hl,de ; 1 cycle
04005C             0007*       or a ; clear flags ; 1 cycle
04005C             0008*       sbc hl,de ; 2 cycles
04005C             0009*       ; 4 cycles total
04005C             0010*       ENDMACRO
04005C             0011*   
04005C             0012*   ; test the sign of HL
04005C             0013*   ; inputs: HL obviously
04005C             0014*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero, ***hlu is zeroed***
04005C             0015*       MACRO SIGN_HL
04005C             0016*       add hl,de
04005C             0017*       or a ; clear flags
04005C             0018*       sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
04005C             0019*       ENDMACRO
04005C             0020*   
04005C             0021*   ; test the 16-bit value of HL for zero
04005C             0022*   ; inputs: HL
04005C             0023*   ; outputs: zero flag set if HL is zero
04005C             0024*   ; destroys: A
04005C             0025*       MACRO ZERO_HL
04005C             0026*       ld a,h
04005C             0027*       or l
04005C             0028*       ENDMACRO
04005C             0029*   
04005C             0030*   ; put the value in A into HLU
04005C             0031*   ; affects: HLU
04005C             0032*   ; destroys: nothing
04005C             0033*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
04005C             0034*       MACRO A_TO_HLU
04005C             0035*       xor a ; 1 cycle
04005C             0036*       ld ($+8+1),hl ; 7 cycles
04005C             0037*       ld ($+4+3),a ; 5 cycles
04005C             0038*       ld hl,0x000000 ; 4 cycles
04005C             0039*       ; 17 cycles total
04005C             0040*       ENDMACRO
04005C             0041*   
04005C             0042*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
04005C             0043*   ; one cycle less but burns flags
04005C             0044*       MACRO A_TO_HLU_ALT
04005C             0045*       push hl ; 4 cycles
04005C             0046*       ld hl,2 ; 4 cycles
04005C             0047*       add hl,sp ; 1 cycle
04005C             0048*       ld (hl),a ; 2 cycles
04005C             0049*       pop hl ; 4 cycles
04005C             0050*       ; 15 cycles total
04005C             0051*       ENDMACRO
04005C             0052*   
04005C             0053*       MACRO HLU_MUL_256
04005C             0054*       add hl,hl ; * 2
04005C             0055*       add hl,hl ; * 4
04005C             0056*       add hl,hl ; * 8
04005C             0057*       add hl,hl ; * 16
04005C             0058*       add hl,hl ; * 32
04005C             0059*       add hl,hl ; * 64
04005C             0060*       add hl,hl ; * 128
04005C             0061*       add hl,hl ; * 256
04005C             0062*       ENDMACRO
04005C             0063*   
04005C             0064*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
04005C             0065*       MACRO SRL_UHL
04005C             0066*       dec sp ; 1 cycle
04005C             0067*       push hl ; 4 cycles
04005C             0068*       inc sp ; 1 cycle
04005C             0069*       pop hl ; 4 cycles
04005C             0070*       inc hl ; 1 cycle
04005C             0071*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04005C             0072*       ; 13 cycles total
04005C             0073*       ENDMACRO
04005C             0074*   
04005C             0075*       MACRO printChar char
04005C             0076*       LD A, char
04005C             0077*       RST.LIL 10h
04005C             0078*       ENDMACRO
04005C             0079*   
04005C             0080*   ; Simulated call to subroutine at HL
04005C             0081*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
04005C             0082*   ; outputs: whatever the subroutine does, including HL and BC
04005C             0083*   ; destroys: only what the subroutine does, but always BC
04005C             0084*       MACRO CALL_HL
04005C             0085*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0086*       push bc ; which constitutes the return address
04005C             0087*       jp (hl) ; Jump to the address in HL
04005C             0088*       ENDMACRO
04005C             0089*   
04005C             0090*   ; Simulated call to subroutine at IX
04005C             0091*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
04005C             0092*   ; outputs: whatever the subroutine does, including IX and BC
04005C             0093*   ; destroys: only what the subroutine does, but always BC
04005C             0094*       MACRO CALL_IX
04005C             0095*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0096*       push bc ; which constitutes the return address
04005C             0097*       jp (ix) ; Jump to the address in IX
04005C             0098*       ENDMACRO
04005C             0099*   
04005C             0100*   ; Simulated call to soubroutinte at IY
04005C             0101*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
04005C             0102*   ; outputs: whatever the subroutine does, including IY and BC
04005C             0103*   ; destroys: only what the subroutine does, but always BC
04005C             0104*       MACRO CALL_IY
04005C             0105*       ld bc,$+6 ; Address of first instruction after the jump
04005C             0106*       push bc ; which constitutes the return address
04005C             0107*       jp (iy) ; Jump to the address in IY
04005C             0108*       ENDMACRO
04005C             0109*   
04005C             0110*   ; put the value in HLU into A
04005C             0111*   ; destroys: af
04005C             0112*       MACRO HLU_TO_A
04005C             0113*       dec sp ; 1 cycle
04005C             0114*       push hl ; 4 cycles
04005C             0115*       inc sp ; 1 cycle
04005C             0116*       pop af ; 4 cycles
04005C             0117*       ; 10 cycles total
04005C             0118*       ENDMACRO
04005C             0119*   
04005C             0120*       MACRO PUSH_ALL
04005C             0121*       ex af,af'
04005C             0122*       exx
04005C             0123*       push af
04005C             0124*       push hl
04005C             0125*       push bc
04005C             0126*       push de
04005C             0127*   
04005C             0128*       ex af,af'
04005C             0129*       exx
04005C             0130*       push af
04005C             0131*       push hl
04005C             0132*       push bc
04005C             0133*       push de
04005C             0134*       push ix
04005C             0135*       push iy
04005C             0136*       ENDMACRO
04005C             0137*   
04005C             0138*       MACRO POP_ALL
04005C             0139*       pop iy
04005C             0140*       pop ix
04005C             0141*       pop de
04005C             0142*       pop bc
04005C             0143*       pop hl
04005C             0144*       pop af
04005C             0145*       ex af,af'
04005C             0146*       exx
04005C             0147*   
04005C             0148*       pop de
04005C             0149*       pop bc
04005C             0150*       pop hl
04005C             0151*       pop af
04005C             0152*       ex af,af'
04005C             0153*       exx
04005C             0154*       ENDMACRO
04005C             0155*   
04005C             0156*       ; load hl with the 16-bit value at addr
04005C             0157*       MACRO LD_HL_mn addr
04005C             0158*       ld hl,(addr)
04005C             0159*       dec hl
04005C             0160*       inc.s hl ; zeros hlu
04005C             0161*       ENDMACRO
04005C             0162*   
04005C             0163*       ; load bc with the 16-bit value at addr
04005C             0164*       MACRO LD_BC_mn addr
04005C             0165*       ld bc,(addr)
04005C             0166*       dec bc
04005C             0167*       inc.s bc ; zeros bcu
04005C             0168*       ENDMACRO
04005C             0169*   
04005C             0170*       ; load de with the 16-bit value at addr
04005C             0171*       MACRO LD_DE_mn addr
04005C             0172*       ld de,(addr)
04005C             0173*       dec de
04005C             0174*       inc.s de ; zeros deu
04005C             0175*       ENDMACRO
04005C             0176*   
04005C             0177*       ; load ix with the 16-bit value at addr
04005C             0178*       MACRO LD_IX_mn addr
04005C             0179*       ld ix,(addr)
04005C             0180*       dec ix
04005C             0181*       inc.s ix ; zeros ixu
04005C             0182*       ENDMACRO
04005C             0183*   
04005C             0184*       ; load iy with the 16-bit value at addr
04005C             0185*       MACRO LD_IY_mn addr
04005C             0186*       ld iy,(addr)
04005C             0187*       dec iy
04005C             0188*       inc.s iy ; zeros iyu
04005C             0189*       ENDMACRO
04005C             0190*   
04005C             0191*       MACRO PRINT_UNPACK_F16 msg
04005C             0192*           ld a,'S'
04005C             0193*           rst.lil 0x10
04005C             0194*           signF16UI
04005C             0195*           call printHexA
04005C             0196*           ld a,'E'
04005C             0197*           rst.lil 0x10
04005C             0198*           expF16UI
04005C             0199*           call printHexA
04005C             0200*           push hl
04005C             0201*           call printInline
04005C             0202*           asciz "Sig"
04005C             0203*           pop hl
04005C             0204*           push hl
04005C             0205*           fracF16UI
04005C             0206*           call printHexHL
04005C             0207*           call printInline
04005C             0208*           asciz msg,"\r\n"
04005C             0209*           pop hl
04005C             0210*       ENDMACRO
04005C             0211*   
04005C             0212*       MACRO PRINT_HL_HEX_BIN msg
04005C             0213*           push de
04005C             0214*           push af
04005C             0215*           push hl
04005C             0216*           call printHLHexBin
04005C             0217*           pop hl
04005C             0218*           push hl
04005C             0219*           call printInline
04005C             0220*           asciz msg,"\r\n"
04005C             0221*           pop hl
04005C             0222*           pop af
04005C             0223*           pop de
04005C             0224*       ENDMACRO
04005C             0225*   
04005C             0226*       MACRO PRINT_A_HEX msg
04005C             0227*           push de
04005C             0228*           push hl
04005C             0229*           push af
04005C             0230*           ld a,'0'
04005C             0231*           rst.lil 0x10
04005C             0232*           ld a,'x'
04005C             0233*           rst.lil 0x10
04005C             0234*           pop af
04005C             0235*           push af
04005C             0236*           call printHexA
04005C             0237*           call printInline
04005C             0238*           asciz "  ",msg,"\r\n"
04005C             0239*           pop af
04005C             0240*           pop hl
04005C             0241*           pop de
04005C             0242*       ENDMACRO
04005C             0243*   
04005C             0244*       MACRO PRINT_HL_HEX msg
04005C             0245*           push de
04005C             0246*           push af
04005C             0247*           push hl
04005C             0248*           ld a,'0'
04005C             0249*           rst.lil 0x10
04005C             0250*           ld a,'x'
04005C             0251*           rst.lil 0x10
04005C             0252*           call printHexHL
04005C             0253*           call printInline
04005C             0254*           asciz msg,"\r\n"
04005C             0255*           pop hl
04005C             0256*           pop af
04005C             0257*           pop de
04005C             0258*       ENDMACRO
04005C             0259*   
04005C             0260*       MACRO PRINT_UHL_HEX msg
04005C             0261*           push de
04005C             0262*           push af
04005C             0263*           push hl
04005C             0264*           ld a,'0'
04005C             0265*           rst.lil 0x10
04005C             0266*           ld a,'x'
04005C             0267*           rst.lil 0x10
04005C             0268*           call printHexUHL
04005C             0269*           call printInline
04005C             0270*           asciz msg,"\r\n"
04005C             0271*           pop hl
04005C             0272*           pop af
04005C             0273*           pop de
04005C             0274*       ENDMACRO
04005C             0275*   
04005C             0276*       MACRO PRINT_AUHL_HEX msg
04005C             0277*           push af
04005C             0278*           push hl
04005C             0279*           push de
04005C             0280*           push af
04005C             0281*           ld a,'0'
04005C             0282*           rst.lil 0x10
04005C             0283*           ld a,'x'
04005C             0284*           rst.lil 0x10
04005C             0285*           pop af
04005C             0286*           call printHexAUHL
04005C             0287*           call printInline
04005C             0288*           asciz msg,"\r\n"
04005C             0289*           pop de
04005C             0290*           pop hl
04005C             0291*           pop af
04005C             0292*       ENDMACRO
04005C             0293*   
04005C             0294*       MACRO PRINT_BC_HEX msg
04005C             0295*           push de
04005C             0296*           push af
04005C             0297*           push hl
04005C             0298*           push bc
04005C             0299*           pop hl
04005C             0300*           ld a,'0'
04005C             0301*           rst.lil 0x10
04005C             0302*           ld a,'x'
04005C             0303*           rst.lil 0x10
04005C             0304*           call printHexHL
04005C             0305*           call printInline
04005C             0306*           asciz msg,"\r\n"
04005C             0307*           pop hl
04005C             0308*           pop af
04005C             0309*           pop de
04005C             0310*       ENDMACRO
04005C             0311*   
04005C             0312*       MACRO PRINT_DE_HEX msg
04005C             0313*           push de
04005C             0314*           push af
04005C             0315*           push hl
04005C             0316*           ex de,hl
04005C             0317*           ld a,'0'
04005C             0318*           rst.lil 0x10
04005C             0319*           ld a,'x'
04005C             0320*           rst.lil 0x10
04005C             0321*           call printHexHL
04005C             0322*           call printInline
04005C             0323*           asciz msg,"\r\n"
04005C             0324*           pop hl
04005C             0325*           pop af
04005C             0326*           pop de
04005C             0327*       ENDMACRO
04005C             0328*   
04005C             0329*       MACRO PRINT_HLDE_HEX msg
04005C             0330*           push de
04005C             0331*           push af
04005C             0332*           push hl
04005C             0333*           ld a,'0'
04005C             0334*           rst.lil 0x10
04005C             0335*           ld a,'x'
04005C             0336*           rst.lil 0x10
04005C             0337*           call printHexHLDE
04005C             0338*           call printInline
04005C             0339*           asciz msg,"\r\n"
04005C             0340*           pop hl
04005C             0341*           pop af
04005C             0342*           pop de
04005C             0343*       ENDMACRO
04005C             0344*   
04005C             0345*       MACRO PRINT_DEHL_HEX msg
04005C             0346*           push de
04005C             0347*           push af
04005C             0348*           push hl
04005C             0349*           ld a,'0'
04005C             0350*           rst.lil 0x10
04005C             0351*           ld a,'x'
04005C             0352*           rst.lil 0x10
04005C             0353*           call printHexDEHL
04005C             0354*           call printInline
04005C             0355*           asciz msg,"\r\n"
04005C             0356*           pop hl
04005C             0357*           pop af
04005C             0358*           pop de
04005C             0359*       ENDMACRO
04005C             0360*   
04005C             0361*       MACRO PRINT_AHL_HEX msg
04005C             0362*           push de
04005C             0363*           push af
04005C             0364*           push hl
04005C             0365*           push af
04005C             0366*           ld a,'0'
04005C             0367*           rst.lil 0x10
04005C             0368*           ld a,'x'
04005C             0369*           rst.lil 0x10
04005C             0370*           pop af
04005C             0371*           call printHexAHL
04005C             0372*           call printInline
04005C             0373*           asciz msg,"\r\n"
04005C             0374*           pop hl
04005C             0375*           pop af
04005C             0376*           pop de
04005C             0377*       ENDMACRO
04005C             0378*   
04005C             0379*       MACRO PRINT_ADE_HEX msg
04005C             0380*           push de
04005C             0381*           push af
04005C             0382*           push hl
04005C             0383*           push af
04005C             0384*           ld a,'0'
04005C             0385*           rst.lil 0x10
04005C             0386*           ld a,'x'
04005C             0387*           rst.lil 0x10
04005C             0388*           pop af
04005C             0389*           call printHexADE
04005C             0390*           call printInline
04005C             0391*           asciz msg,"\r\n"
04005C             0392*           pop hl
04005C             0393*           pop af
04005C             0394*           pop de
04005C             0395*       ENDMACRO
04005C             0396*   
04005C             0397*       MACRO DUMP_REGISTERS_HEX msg
04005C             0398*           push de
04005C             0399*           push af
04005C             0400*           push hl
04005C             0401*           call printInline
04005C             0402*           asciz "\r\n",msg,"\r\n"
04005C             0403*           pop hl
04005C             0404*           pop af
04005C             0405*           pop de
04005C             0406*           call dumpRegistersHex
04005C             0407*           ; call dumpFlags
04005C             0408*       ENDMACRO
04005C             0029        include "../agon/debug.inc"
04005C             0001*   printHexA:
04005C F5          0002*       push af
04005D C5          0003*       push bc
04005E CD 33 21 04 0004*       call printHex8
040062 3E 20       0005*       ld a,' '
040064 5B D7       0006*       rst.lil 10h
040066 C1          0007*       pop bc
040067 F1          0008*       pop af
040068 C9          0009*       ret
040069             0010*   
040069             0011*   printHexHL:
040069 F5          0012*       push af
04006A C5          0013*       push bc
04006B CD 2D 21 04 0014*       call printHex16
04006F 3E 20       0015*       ld a,' '
040071 5B D7       0016*       rst.lil 10h
040073 C1          0017*       pop bc
040074 F1          0018*       pop af
040075 C9          0019*       ret
040076             0020*   
040076             0021*   printHexUHL:
040076 F5          0022*       push af
040077 C5          0023*       push bc
040078 CD 25 21 04 0024*       call printHex24
04007C 3E 20       0025*       ld a,' '
04007E 5B D7       0026*       rst.lil 10h
040080 C1          0027*       pop bc
040081 F1          0028*       pop af
040082 C9          0029*       ret
040083             0030*   
040083             0031*   printHexAUHL:
040083 F5          0032*       push af
040084 C5          0033*       push bc
040085 E5          0034*       push hl
040086 CD 33 21 04 0035*       call printHex8
04008A E1          0036*       pop hl
04008B E5          0037*       push hl
04008C CD 25 21 04 0038*       call printHex24
040090 3E 20       0039*       ld a,' '
040092 5B D7       0040*       rst.lil 10h
040094 E1          0041*       pop hl
040095 C1          0042*       pop bc
040096 F1          0043*       pop af
040097 C9          0044*       ret
040098             0045*   
040098             0046*   printHexAHL:
040098 F5          0047*       push af
040099 C5          0048*       push bc
04009A CD 33 21 04 0049*       call printHex8
04009E CD 2D 21 04 0050*       call printHex16
0400A2 3E 20       0051*       ld a,' '
0400A4 5B D7       0052*       rst.lil 10h
0400A6 C1          0053*       pop bc
0400A7 F1          0054*       pop af
0400A8 C9          0055*       ret
0400A9             0056*   
0400A9             0057*   printHexADE:
0400A9 F5          0058*       push af
0400AA C5          0059*       push bc
0400AB EB          0060*       ex de,hl
0400AC CD 33 21 04 0061*       call printHex8
0400B0 CD 2D 21 04 0062*       call printHex16
0400B4 EB          0063*       ex de,hl
0400B5 3E 20       0064*       ld a,' '
0400B7 5B D7       0065*       rst.lil 10h
0400B9 C1          0066*       pop bc
0400BA F1          0067*       pop af
0400BB C9          0068*       ret
0400BC             0069*   
0400BC             0070*   
0400BC             0071*   printHexHLBC:
0400BC F5          0072*       push af
0400BD C5          0073*       push bc
0400BE CD 2D 21 04 0074*       call printHex16
0400C2 E1          0075*       pop hl ; bc
0400C3 E5          0076*       push hl
0400C4 CD 2D 21 04 0077*       call printHex16
0400C8 3E 20       0078*       ld a,' '
0400CA 5B D7       0079*       rst.lil 10h
0400CC C1          0080*       pop bc
0400CD F1          0081*       pop af
0400CE C9          0082*       ret
0400CF             0083*   
0400CF             0084*   printHexHLDE:
0400CF F5          0085*       push af
0400D0 CD 2D 21 04 0086*       call printHex16
0400D4 EB          0087*       ex de,hl
0400D5 CD 2D 21 04 0088*       call printHex16
0400D9 EB          0089*       ex de,hl
0400DA 3E 20       0090*       ld a,' '
0400DC 5B D7       0091*       rst.lil 10h
0400DE F1          0092*       pop af
0400DF C9          0093*       ret
0400E0             0094*   
0400E0             0095*   printHexDEHL:
0400E0 F5          0096*       push af
0400E1 EB          0097*       ex de,hl
0400E2 CD 2D 21 04 0098*       call printHex16
0400E6 EB          0099*       ex de,hl
0400E7 CD 2D 21 04 0100*       call printHex16
0400EB 3E 20       0101*       ld a,' '
0400ED 5B D7       0102*       rst.lil 10h
0400EF F1          0103*       pop af
0400F0 C9          0104*       ret
0400F1             0105*   
0400F1             0106*   printHexABHL:
0400F1             0107*   ; preserve registers
0400F1 C5          0108*       push bc ; b will be ok c will not
0400F2 F5          0109*       push af ; will get totally destroyed
0400F3             0110*   ; print a
0400F3 CD 33 21 04 0111*       call printHex8
0400F7             0112*   ; print b
0400F7 78          0113*       ld a,b
0400F8 CD 33 21 04 0114*       call printHex8
0400FC             0115*   ; print hl
0400FC CD 2D 21 04 0116*       call printHex16
040100             0117*   ; restore registers
040100 F1          0118*       pop af
040101 C1          0119*       pop bc
040102 C9          0120*       ret
040103             0121*   
040103             0122*   printHexBHL:
040103             0123*   ; preserve registers
040103 C5          0124*       push bc ; b will be ok c will not
040104 F5          0125*       push af ; will get totally destroyed
040105             0126*   ; print b
040105 78          0127*       ld a,b
040106 CD 33 21 04 0128*       call printHex8
04010A             0129*   ; print hl
04010A CD 2D 21 04 0130*       call printHex16
04010E             0131*   ; restore registers
04010E F1          0132*       pop af
04010F C1          0133*       pop bc
040110 C9          0134*       ret
040111             0135*   
040111             0136*   printHexCDE:
040111             0137*   ; preserve registers
040111 C5          0138*       push bc ; b will be ok c will not
040112 F5          0139*       push af ; will get totally destroyed
040113             0140*   ; print c
040113 79          0141*       ld a,c
040114 CD 33 21 04 0142*       call printHex8
040118             0143*   ; print de
040118 EB          0144*       ex de,hl
040119 CD 2D 21 04 0145*       call printHex16
04011D EB          0146*       ex de,hl
04011E             0147*   ; restore registers
04011E F1          0148*       pop af
04011F C1          0149*       pop bc
040120 C9          0150*       ret
040121             0151*   
040121             0152*   printHexUIX:
040121             0153*   ; store everything in scratch
040121 22 D0 24 04 0154*       ld (uhl),hl
040125 ED 43 D3 24 0155*       ld (ubc),bc
       04          
04012A ED 53 D6 24 0156*       ld (ude),de
       04          
04012F DD 22 D9 24 0157*       ld (uix),ix
       04          
040134 FD 22 DC 24 0158*       ld (uiy),iy
       04          
040139 F5          0159*       push af ; fml
04013A             0160*   
04013A 21 67 24 04 0161*       ld hl,str_ixu
04013E CD EC 20 04 0162*       call printString
040142 2A D9 24 04 0163*       ld hl,(uix)
040146 CD 25 21 04 0164*       call printHex24
04014A CD 01 21 04 0165*       call printNewLine
04014E             0166*   
04014E             0167*   ; restore everything
04014E 2A D0 24 04 0168*       ld hl, (uhl)
040152 ED 4B D3 24 0169*       ld bc, (ubc)
       04          
040157 ED 5B D6 24 0170*       ld de, (ude)
       04          
04015C DD 2A D9 24 0171*       ld ix, (uix)
       04          
040161 FD 2A DC 24 0172*       ld iy, (uiy)
       04          
040166 F1          0173*       pop af
040167             0174*   ; all done
040167 C9          0175*       ret
040168             0176*   
040168             0177*   
040168             0178*   ; print registers to screen in hexidecimal format
040168             0179*   ; inputs: none
040168             0180*   ; outputs: values of every register printed to screen
040168             0181*   ;    values of each register in global scratch memory
040168             0182*   ; destroys: nothing
040168             0183*   stepRegistersHex:
040168             0184*   ; store everything in scratch
040168 22 D0 24 04 0185*       ld (uhl),hl
04016C ED 43 D3 24 0186*       ld (ubc),bc
       04          
040171 ED 53 D6 24 0187*       ld (ude),de
       04          
040176 DD 22 D9 24 0188*       ld (uix),ix
       04          
04017B FD 22 DC 24 0189*       ld (uiy),iy
       04          
040180 F5          0190*       push af ; fml
040181 E1          0191*       pop hl ; thanks, zilog
040182 22 CD 24 04 0192*       ld (uaf),hl
040186 F5          0193*       push af ; dammit
040187             0194*   
040187             0195*   ; home the cursor
040187             0196*       ; call vdu_home_cursor
040187             0197*   
040187             0198*   ; print each register
040187 21 53 24 04 0199*       ld hl,str_afu
04018B CD EC 20 04 0200*       call printString
04018F 2A CD 24 04 0201*       ld hl,(uaf)
040193 CD 25 21 04 0202*       call printHex24
040197 CD 01 21 04 0203*       call printNewLine
04019B             0204*   
04019B 21 58 24 04 0205*       ld hl,str_hlu
04019F CD EC 20 04 0206*       call printString
0401A3 2A D0 24 04 0207*       ld hl,(uhl)
0401A7 CD 25 21 04 0208*       call printHex24
0401AB CD 01 21 04 0209*       call printNewLine
0401AF             0210*   
0401AF 21 5D 24 04 0211*       ld hl,str_bcu
0401B3 CD EC 20 04 0212*       call printString
0401B7 2A D3 24 04 0213*       ld hl,(ubc)
0401BB CD 25 21 04 0214*       call printHex24
0401BF CD 01 21 04 0215*       call printNewLine
0401C3             0216*   
0401C3 21 62 24 04 0217*       ld hl,str_deu
0401C7 CD EC 20 04 0218*       call printString
0401CB 2A D6 24 04 0219*       ld hl,(ude)
0401CF CD 25 21 04 0220*       call printHex24
0401D3 CD 01 21 04 0221*       call printNewLine
0401D7             0222*   
0401D7 21 67 24 04 0223*       ld hl,str_ixu
0401DB CD EC 20 04 0224*       call printString
0401DF 2A D9 24 04 0225*       ld hl,(uix)
0401E3 CD 25 21 04 0226*       call printHex24
0401E7 CD 01 21 04 0227*       call printNewLine
0401EB             0228*   
0401EB 21 6C 24 04 0229*       ld hl,str_iyu
0401EF CD EC 20 04 0230*       call printString
0401F3 2A DC 24 04 0231*       ld hl,(uiy)
0401F7 CD 25 21 04 0232*       call printHex24
0401FB CD 01 21 04 0233*       call printNewLine
0401FF             0234*   
0401FF             0235*       ; call vsync
0401FF             0236*   
0401FF CD 01 21 04 0237*       call printNewLine
040203             0238*   
040203             0239*   ; check for right shift key and quit if pressed
040203             0240*       MOSCALL mos_getkbmap
                       M1 Args: function=mos_getkbmap 
040203 3E 1E       0001*M1 			LD	A, function
040205 5B CF       0002*M1 			RST.LIL	08h
040207             0241*   @stayhere:
040207             0242*   ; 7 RightShift
040207 DD CB 00 76 0243*       bit 6,(ix+0)
04020B 20 02       0244*       jr nz,@RightShift
04020D 18 F8       0245*       jr @stayhere
04020F             0246*   @RightShift:
04020F DD CB 0E 86 0247*       res 0,(ix+14) ; debounce the key (hopefully)
040213 3E 80       0248*       ld a,%10000000
040215             0249*       ; call multiPurposeDelay
040215             0250*   
040215             0251*   ; restore everything
040215 2A D0 24 04 0252*       ld hl, (uhl)
040219 ED 4B D3 24 0253*       ld bc, (ubc)
       04          
04021E ED 5B D6 24 0254*       ld de, (ude)
       04          
040223 DD 2A D9 24 0255*       ld ix, (uix)
       04          
040228 FD 2A DC 24 0256*       ld iy, (uiy)
       04          
04022D F1          0257*       pop af
04022E             0258*   ; all done
04022E C9          0259*       ret
04022F             0260*   
04022F             0261*   ; print registers to screen in hexidecimal format
04022F             0262*   ; inputs: none
04022F             0263*   ; outputs: values of every register printed to screen
04022F             0264*   ;    values of each register in global scratch memory
04022F             0265*   ; destroys: nothing
04022F             0266*   dumpRegistersHex:
04022F             0267*   ; store everything in scratch
04022F 22 D0 24 04 0268*       ld (uhl),hl
040233 ED 43 D3 24 0269*       ld (ubc),bc
       04          
040238 ED 53 D6 24 0270*       ld (ude),de
       04          
04023D DD 22 D9 24 0271*       ld (uix),ix
       04          
040242 FD 22 DC 24 0272*       ld (uiy),iy
       04          
040247 F5          0273*       push af ; fml
040248 E1          0274*       pop hl ; thanks, zilog
040249 22 CD 24 04 0275*       ld (uaf),hl
04024D F5          0276*       push af ; dammit
04024E             0277*   
04024E             0278*   ; home the cursor
04024E             0279*       ; call vdu_home_cursor
04024E             0280*       ; call printNewLine
04024E             0281*   
04024E             0282*   ; print each register
04024E 21 53 24 04 0283*       ld hl,str_afu
040252 CD EC 20 04 0284*       call printString
040256 2A CD 24 04 0285*       ld hl,(uaf)
04025A CD 25 21 04 0286*       call printHex24
04025E             0287*       ; call printNewLine
04025E             0288*   
04025E 21 58 24 04 0289*       ld hl,str_hlu
040262 CD EC 20 04 0290*       call printString
040266 2A D0 24 04 0291*       ld hl,(uhl)
04026A CD 25 21 04 0292*       call printHex24
04026E             0293*       ; call printNewLine
04026E             0294*   
04026E 21 5D 24 04 0295*       ld hl,str_bcu
040272 CD EC 20 04 0296*       call printString
040276 2A D3 24 04 0297*       ld hl,(ubc)
04027A CD 25 21 04 0298*       call printHex24
04027E             0299*       ; call printNewLine
04027E             0300*   
04027E 21 62 24 04 0301*       ld hl,str_deu
040282 CD EC 20 04 0302*       call printString
040286 2A D6 24 04 0303*       ld hl,(ude)
04028A CD 25 21 04 0304*       call printHex24
04028E             0305*       ; call printNewLine
04028E             0306*   
04028E 21 67 24 04 0307*       ld hl,str_ixu
040292 CD EC 20 04 0308*       call printString
040296 2A D9 24 04 0309*       ld hl,(uix)
04029A CD 25 21 04 0310*       call printHex24
04029E             0311*       ; call printNewLine
04029E             0312*   
04029E 21 6C 24 04 0313*       ld hl,str_iyu
0402A2 CD EC 20 04 0314*       call printString
0402A6 2A DC 24 04 0315*       ld hl,(uiy)
0402AA CD 25 21 04 0316*       call printHex24
0402AE             0317*   
0402AE CD 01 21 04 0318*       call printNewLine
0402B2             0319*       ; call printNewLine
0402B2             0320*   ; restore everything
0402B2 2A D0 24 04 0321*       ld hl, (uhl)
0402B6 ED 4B D3 24 0322*       ld bc, (ubc)
       04          
0402BB ED 5B D6 24 0323*       ld de, (ude)
       04          
0402C0 DD 2A D9 24 0324*       ld ix, (uix)
       04          
0402C5 FD 2A DC 24 0325*       ld iy, (uiy)
       04          
0402CA F1          0326*       pop af
0402CB             0327*   ; all done
0402CB C9          0328*       ret
0402CC             0329*   
0402CC             0330*   dumpRegistersHexPrime:
0402CC D9          0331*       exx
0402CD 08          0332*       ex af,af'
0402CE CD 2F 02 04 0333*       call dumpRegistersHex
0402D2 08          0334*       ex af,af'
0402D3 D9          0335*       exx
0402D4 C9          0336*       ret
0402D5             0337*   
0402D5             0338*   ; additionally dump prime registers
0402D5             0339*   ; inputs: none
0402D5             0340*   ; outputs: values of every register printed to screen
0402D5             0341*   ; destroys: nothing
0402D5             0342*   dumpRegistersHexAll:
0402D5 CD 2F 02 04 0343*       call dumpRegistersHex
0402D9 08          0344*       ex af,af'
0402DA D9          0345*       exx
0402DB CD 2F 02 04 0346*       call dumpRegistersHex
0402DF 08          0347*       ex af,af'
0402E0 D9          0348*       exx
0402E1 C9          0349*       ret
0402E2             0350*   
0402E2             0351*   ; print hlu to screen in hexidecimal format
0402E2             0352*   ; inputs: none
0402E2             0353*   ; destroys: nothing
0402E2             0354*   print_hex_hl:
0402E2 F5          0355*       push af
0402E3 E5          0356*       push hl
0402E4 21 58 24 04 0357*       ld hl,str_hlu
0402E8 CD EC 20 04 0358*       call printString
0402EC E1          0359*       pop hl
0402ED E5          0360*       push hl
0402EE CD 25 21 04 0361*       call printHex24
0402F2 3E 20       0362*       ld a,' '
0402F4 5B D7       0363*       rst.lil 10h
0402F6 E1          0364*       pop hl
0402F7 F1          0365*       pop af
0402F8 C9          0366*       ret
0402F9             0367*   
0402F9             0368*   ; print bcu to screen in hexidecimal format
0402F9             0369*   ; inputs: none
0402F9             0370*   ; destroys: nothing
0402F9             0371*   print_hex_bc:
0402F9 F5          0372*       push af
0402FA E5          0373*       push hl
0402FB C5          0374*       push bc
0402FC 21 5D 24 04 0375*       ld hl,str_bcu
040300 CD EC 20 04 0376*       call printString
040304 E1          0377*       pop hl
040305 E5          0378*       push hl
040306 CD 25 21 04 0379*       call printHex24
04030A 3E 20       0380*       ld a,' '
04030C 5B D7       0381*       rst.lil 10h
04030E C1          0382*       pop bc
04030F E1          0383*       pop hl
040310 F1          0384*       pop af
040311 C9          0385*       ret
040312             0386*   
040312             0387*   ; print deu to screen in hexidecimal format
040312             0388*   ; inputs: none
040312             0389*   ; destroys: nothing
040312             0390*   print_hex_de:
040312 F5          0391*       push af
040313 E5          0392*       push hl
040314 D5          0393*       push de
040315 21 62 24 04 0394*       ld hl,str_deu
040319 CD EC 20 04 0395*       call printString
04031D E1          0396*       pop hl
04031E E5          0397*       push hl
04031F CD 25 21 04 0398*       call printHex24
040323 3E 20       0399*       ld a,' '
040325 5B D7       0400*       rst.lil 10h
040327 D1          0401*       pop de
040328 E1          0402*       pop hl
040329 F1          0403*       pop af
04032A C9          0404*       ret
04032B             0405*   
04032B             0406*   
04032B             0407*   printCarry:
04032B             0408*   ;save all the things
04032B F5          0409*       push af
04032C E5          0410*       push hl
04032D C5          0411*       push bc
04032E D5          0412*       push de
04032F             0413*   ; check carry
04032F F5          0414*       push af
040330 F1          0415*       pop af
040331 38 06       0416*       jr c,@carry
040333 3E 30       0417*       ld a,'0'
040335 5B D7       0418*       rst.lil 10h
040337 18 04       0419*       jr @space
040339             0420*   @carry:
040339 3E 31       0421*       ld a,'1'
04033B 5B D7       0422*       rst.lil 10h
04033D             0423*   @space:
04033D 3E 20       0424*       ld a,' '
04033F 5B D7       0425*       rst.lil 10h
040341             0426*   ;restore all the things
040341 D1          0427*       pop de
040342 C1          0428*       pop bc
040343 E1          0429*       pop hl
040344 F1          0430*       pop af
040345 C9          0431*       ret
040346             0432*   ; end printCarry
040346             0433*   
040346             0434*   ; inputs: whatever is in the flags register
040346             0435*   ; outputs: binary representation of flags
040346             0436*   ;          with a header so we know which is what
040346             0437*   ; destroys: nothing
040346             0438*   ; preserves: everything
040346             0439*   dumpFlags:
040346             0440*   ; first we curse zilog for not giving direct access to flags
040346 F5          0441*       push af ; this is so we can send it back unharmed
040347 F5          0442*       push af ; this is so we can pop it to hl
040348             0443*   ; store everything in scratch
040348 22 D0 24 04 0444*       ld (uhl),hl
04034C ED 43 D3 24 0445*       ld (ubc),bc
       04          
040351 ED 53 D6 24 0446*       ld (ude),de
       04          
040356 DD 22 D9 24 0447*       ld (uix),ix
       04          
04035B FD 22 DC 24 0448*       ld (uiy),iy
       04          
040360             0449*   ; next we print the header
040360 21 8C 03 04 0450*       ld hl,@header
040364 CD EC 20 04 0451*       call printString
040368 E1          0452*       pop hl ; flags are now in l
040369 7D          0453*       ld a,l ; flags are now in a
04036A CD 8F 23 04 0454*       call printBin8
04036E CD 01 21 04 0455*       call printNewLine
040372             0456*   ; restore everything
040372 2A D0 24 04 0457*       ld hl, (uhl)
040376 ED 4B D3 24 0458*       ld bc, (ubc)
       04          
04037B ED 5B D6 24 0459*       ld de, (ude)
       04          
040380 DD 2A D9 24 0460*       ld ix, (uix)
       04          
040385 FD 2A DC 24 0461*       ld iy, (uiy)
       04          
04038A F1          0462*       pop af ; send her home the way she came
04038B C9          0463*       ret
04038C             0464*   ; Bit 7 (S): Sign flag
04038C             0465*   ; Bit 6 (Z): Zero flag
04038C             0466*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
04038C             0467*   ; Bit 4 (H): Half Carry flag
04038C             0468*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
04038C             0469*   ; Bit 2 (PV): Parity/Overflow flag
04038C             0470*   ; Bit 1 (N): Subtract flag
04038C             0471*   ; Bit 0 (C): Carry flag
04038C 53 5A 78 48 0472*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040397             0473*   
040397             0474*   
040397             0475*   ; print bytes from an address to the screen in hexidecimal format
040397             0476*   ; inputs: hl = address of first byte to print, a = number of bytes to print
040397             0477*   ; outputs: values of each byte printed to screen separated by spaces
040397             0478*   ; destroys: nothing
040397             0479*   dumpMemoryHex:
040397             0480*   ; save registers to the stack
040397 C5          0481*       push bc
040398 E5          0482*       push hl
040399 F5          0483*       push af
04039A             0484*   
04039A             0485*   ; print the address and separator
04039A CD 25 21 04 0486*       call printHex24
04039E 3E 3A       0487*       ld a,':'
0403A0 5B D7       0488*       rst.lil 10h
0403A2 3E 20       0489*       ld a,' '
0403A4 5B D7       0490*       rst.lil 10h
0403A6             0491*   
0403A6             0492*   ; set b to be our loop counter
0403A6 F1          0493*       pop af
0403A7 47          0494*       ld b,a
0403A8 E1          0495*       pop hl
0403A9 E5          0496*       push hl
0403AA F5          0497*       push af
0403AB             0498*   @loop:
0403AB             0499*   ; print the byte
0403AB 7E          0500*       ld a,(hl)
0403AC CD 33 21 04 0501*       call printHex8
0403B0             0502*   ; print a space
0403B0 3E 20       0503*       ld a,' '
0403B2 5B D7       0504*       rst.lil 10h
0403B4 23          0505*       inc hl
0403B5 10 F4       0506*       djnz @loop
0403B7 CD 01 21 04 0507*       call printNewLine
0403BB             0508*   
0403BB             0509*   ; restore everything
0403BB F1          0510*       pop af
0403BC E1          0511*       pop hl
0403BD C1          0512*       pop bc
0403BE             0513*   
0403BE             0514*   ; all done
0403BE C9          0515*       ret
0403BF             0516*   
0403BF             0517*   
0403BF             0518*   ; print bytes from an address to the screen in binary format
0403BF             0519*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0403BF             0520*   ; outputs: values of each byte printed to screen separated by spaces
0403BF             0521*   ; destroys: nothing
0403BF             0522*   dumpMemoryBin:
0403BF             0523*   ; save all registers to the stack
0403BF F5          0524*       push af
0403C0 C5          0525*       push bc
0403C1 D5          0526*       push de
0403C2 E5          0527*       push hl
0403C3 DD E5       0528*       push ix
0403C5 FD E5       0529*       push iy
0403C7             0530*   
0403C7             0531*   ; set b to be our loop counter
0403C7 47          0532*       ld b,a
0403C8             0533*   @loop:
0403C8             0534*   ; print the byte
0403C8 7E          0535*       ld a,(hl)
0403C9 E5          0536*       push hl
0403CA C5          0537*       push bc
0403CB CD 8F 23 04 0538*       call printBin8
0403CF C1          0539*       pop bc
0403D0             0540*   ; print a space
0403D0 3E 20       0541*       ld a,' '
0403D2 5B D7       0542*       rst.lil 10h
0403D4 E1          0543*       pop hl
0403D5 23          0544*       inc hl
0403D6 10 F0       0545*       djnz @loop
0403D8 CD 01 21 04 0546*       call printNewLine
0403DC             0547*   
0403DC             0548*   ; restore everything
0403DC FD E1       0549*       pop iy
0403DE DD E1       0550*       pop ix
0403E0 E1          0551*       pop hl
0403E1 D1          0552*       pop de
0403E2 C1          0553*       pop bc
0403E3 F1          0554*       pop af
0403E4             0555*   ; all done
0403E4 C9          0556*       ret
0403E5             0557*   
0403E5             0558*   ; print bytes from an address to the screen in binary format
0403E5             0559*   ; with the bits of each byte in reverse order (lsb first)
0403E5             0560*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0403E5             0561*   ; outputs: values of each byte printed to screen separated by spaces
0403E5             0562*   ; destroys: nothing
0403E5             0563*   dumpMemoryBinRev:
0403E5             0564*   ; save all registers to the stack
0403E5 F5          0565*       push af
0403E6 C5          0566*       push bc
0403E7 D5          0567*       push de
0403E8 E5          0568*       push hl
0403E9 DD E5       0569*       push ix
0403EB FD E5       0570*       push iy
0403ED             0571*   
0403ED             0572*   ; set b to be our loop counter
0403ED 47          0573*       ld b,a
0403EE             0574*   @loop:
0403EE             0575*   ; print the byte
0403EE 7E          0576*       ld a,(hl)
0403EF E5          0577*       push hl
0403F0 C5          0578*       push bc
0403F1 CD 2E 24 04 0579*       call printBin8Rev
0403F5 C1          0580*       pop bc
0403F6             0581*   ; print a space
0403F6 3E 20       0582*       ld a,' '
0403F8 5B D7       0583*       rst.lil 10h
0403FA E1          0584*       pop hl
0403FB 23          0585*       inc hl
0403FC 10 F0       0586*       djnz @loop
0403FE CD 01 21 04 0587*       call printNewLine
040402             0588*   
040402             0589*   ; restore everything
040402 FD E1       0590*       pop iy
040404 DD E1       0591*       pop ix
040406 E1          0592*       pop hl
040407 D1          0593*       pop de
040408 C1          0594*       pop bc
040409 F1          0595*       pop af
04040A             0596*   ; all done
04040A C9          0597*       ret
04040B             0030    
04040B             0031        include "../agon/arith24.inc"
04040B             0001*   ;------------------------------------------------------------------------
04040B             0002*   ;  arith24.asm
04040B             0003*   ;  24-bit ez80 arithmetic routines
04040B             0004*   ;  Copyright (c) Shawn Sijnstra 2024
04040B             0005*   ;  MIT license
04040B             0006*   ;
04040B             0007*   ;  This library was created as a tool to help make ez80
04040B             0008*   ;  24-bit native assembly routines for simple mathematical problems
04040B             0009*   ;  more widely available.
04040B             0010*   ;
04040B             0011*   ;------------------------------------------------------------------------
04040B             0012*   
04040B             0013*   ;------------------------------------------------------------------------
04040B             0014*   ; umul24:	HL = HL*DE (unsigned)
04040B             0015*   ; Preserves AF, BC, DE
04040B             0016*   ; Uses a fast multiply routine.
04040B             0017*   ;------------------------------------------------------------------------
04040B             0018*   umul24:
04040B D5          0019*   	push	DE
04040C C5          0020*   	push	BC
04040D F5          0021*   	push	AF
04040E E5          0022*   	push	HL
04040F C1          0023*   	pop		BC
040410 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
040412 21 00 00 00 0025*       ld	 	hl, 0 ; Result
040416             0026*   umul24_lp:
040416 29          0027*   	add	hl,hl
040417 EB          0028*   	ex	de,hl
040418 29          0029*   	add	hl,hl
040419 EB          0030*   	ex	de,hl
04041A 30 01       0031*   	jr	nc,umul24_nc
04041C 09          0032*   	add	hl,bc
04041D             0033*   umul24_nc:
04041D 3D          0034*   	dec	a
04041E 20 F6       0035*   	jr	nz,umul24_lp
040420 F1          0036*   	pop	af
040421 C1          0037*   	pop	bc
040422 D1          0038*   	pop	de
040423 C9          0039*   	ret
040424             0040*   
040424             0041*   
040424             0042*   ;------------------------------------------------------------------------
040424             0043*   ; udiv24
040424             0044*   ; Unsigned 24-bit division
040424             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040424             0046*   ;
040424             0047*   ; Uses AF BC DE HL
040424             0048*   ; Uses Restoring Division algorithm
040424             0049*   ;------------------------------------------------------------------------
040424             0050*   
040424             0051*   udiv24:
040424 E5          0052*   	push	hl
040425 C1          0053*   	pop		bc	;move dividend to BCU
040426 21 00 00 00 0054*   	ld		hl,0	;result
04042A A7          0055*   	and		a
04042B ED 52       0056*   	sbc		hl,de	;test for div by 0
04042D C8          0057*   	ret		z		;it's zero, carry flag is clear
04042E 19          0058*   	add		hl,de	;HL is 0 again
04042F 3E 18       0059*   	ld		a,24	;number of loops through.
040431             0060*   udiv1:
040431 C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
040432 E3          0062*   	ex		(sp),hl
040433 37          0063*   	scf
040434 ED 6A       0064*   	adc	hl,hl
040436 E3          0065*   	ex	(sp),hl
040437 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
040438             0067*   
040438 ED 6A       0068*   	adc	hl,hl
04043A A7          0069*   	and	a		;is this the bug
04043B ED 52       0070*   	sbc	hl,de
04043D 30 02       0071*   	jr	nc,udiv2
04043F 19          0072*   	add	hl,de
040440             0073*   ;	dec	c
040440 0B          0074*   	dec	bc
040441             0075*   udiv2:
040441 3D          0076*   	dec	a
040442 20 ED       0077*   	jr	nz,udiv1
040444 37          0078*   	scf		;flag used for div0 error
040445 C5          0079*   	push	bc
040446 D1          0080*   	pop		de	;remainder
040447 C9          0081*   	ret
040448             0082*   
040448             0083*   
040448             0084*   
040448             0085*   ;------------------------------------------------------------------------
040448             0086*   ; neg24
040448             0087*   ; Returns: HLU = 0-HLU
040448             0088*   ; preserves all other registers
040448             0089*   ;------------------------------------------------------------------------
040448             0090*   neg24:
040448 D5          0091*   	push	de
040449 EB          0092*   	ex		de,hl
04044A 21 00 00 00 0093*   	ld		hl,0
04044E B7          0094*   	or		a
04044F ED 52       0095*   	sbc		hl,de
040451 D1          0096*   	pop		de
040452 C9          0097*   	ret
040453             0098*   
040453             0099*   ;------------------------------------------------------------------------
040453             0100*   ; or_hlu_deu: 24 bit bitwise OR
040453             0101*   ; Returns: hlu = hlu OR deu
040453             0102*   ; preserves all other registers
040453             0103*   ;------------------------------------------------------------------------
040453             0104*   or_hlu_deu:
040453 22 DC 04 04 0105*   	ld	(bitbuf1),hl
040457 ED 53 DF 04 0106*   	ld	(bitbuf2),de
       04          
04045C D5          0107*   	push	de	;preserve DEU
04045D C5          0108*   	push	bc	;preserve BCU
04045E 06 03       0109*   	ld		b,3
040460 21 DC 04 04 0110*   	ld	hl,bitbuf1
040464 11 DC 04 04 0111*   	ld	de,bitbuf1
040468             0112*   orloop_24:
040468 1A          0113*   	ld	a,(de)
040469 B6          0114*   	or	(hl)
04046A 12          0115*   	ld	(de),a
04046B 13          0116*   	inc	de
04046C 23          0117*   	inc	hl
04046D 10 F9       0118*   	djnz	orloop_24
04046F 2A DF 04 04 0119*   	ld	hl,(bitbuf2)
040473 C1          0120*   	pop		bc	;restore BC
040474 D1          0121*   	pop		de	;restore DE
040475             0122*   
040475             0123*   ;------------------------------------------------------------------------
040475             0124*   ; and_hlu_deu: 24 bit bitwise AND
040475             0125*   ; Returns: hlu = hlu AND deu
040475             0126*   ; preserves all other registers
040475             0127*   ;------------------------------------------------------------------------
040475             0128*   and_hlu_deu:
040475 22 DC 04 04 0129*   	ld	(bitbuf1),hl
040479 ED 53 DF 04 0130*   	ld	(bitbuf2),de
       04          
04047E D5          0131*   	push	de	;preserve DEU
04047F C5          0132*   	push	bc	;preserve BCU
040480 06 03       0133*   	ld		b,3
040482 21 DC 04 04 0134*   	ld	hl,bitbuf1
040486 11 DC 04 04 0135*   	ld	de,bitbuf1
04048A             0136*   andloop_24:
04048A 1A          0137*   	ld	a,(de)
04048B A6          0138*   	and	(hl)
04048C 12          0139*   	ld	(de),a
04048D 13          0140*   	inc	de
04048E 23          0141*   	inc	hl
04048F 10 F9       0142*   	djnz	andloop_24
040491 2A DF 04 04 0143*   	ld	hl,(bitbuf2)
040495 C1          0144*   	pop		bc	;restore BC
040496 D1          0145*   	pop		de	;restore DE
040497             0146*   
040497             0147*   ;------------------------------------------------------------------------
040497             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
040497             0149*   ; Returns: hlu = hlu XOR deu
040497             0150*   ; preserves all other registers
040497             0151*   ;------------------------------------------------------------------------
040497             0152*   xor_hlu_deu:
040497 22 DC 04 04 0153*   	ld	(bitbuf1),hl
04049B ED 53 DF 04 0154*   	ld	(bitbuf2),de
       04          
0404A0 D5          0155*   	push	de	;preserve DEU
0404A1 C5          0156*   	push	bc	;preserve BCU
0404A2 06 03       0157*   	ld		b,3
0404A4 21 DC 04 04 0158*   	ld	hl,bitbuf1
0404A8 11 DC 04 04 0159*   	ld	de,bitbuf1
0404AC             0160*   xorloop_24:
0404AC 1A          0161*   	ld	a,(de)
0404AD AE          0162*   	xor	(hl)
0404AE 12          0163*   	ld	(de),a
0404AF 13          0164*   	inc	de
0404B0 23          0165*   	inc	hl
0404B1 10 F9       0166*   	djnz	xorloop_24
0404B3 2A DF 04 04 0167*   	ld	hl,(bitbuf2)
0404B7 C1          0168*   	pop		bc	;restore BC
0404B8 D1          0169*   	pop		de	;restore DE
0404B9             0170*   
0404B9             0171*   ;------------------------------------------------------------------------
0404B9             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
0404B9             0173*   ; Returns: hlu = hlu << a
0404B9             0174*   ;		   a = 0
0404B9             0175*   ; NOTE: only considers a up to 16 bits.
0404B9             0176*   ; preserves all other registers
0404B9             0177*   ; modified by Brandon R. Gates to use a instead of de
0404B9             0178*   ;------------------------------------------------------------------------
0404B9             0179*   shl_hlu:
0404B9 B7          0180*   	or a
0404BA C8          0181*   	ret		z		;we're done
0404BB 29          0182*   	add		hl,hl	;shift HLU left
0404BC 3D          0183*   	dec a
0404BD 18 FA       0184*   	jr		shl_hlu
0404BF             0185*   
0404BF             0186*   ;------------------------------------------------------------------------
0404BF             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
0404BF             0188*   ; Returns: hlu = hlu >> a
0404BF             0189*   ;		   a = 0
0404BF             0190*   ; NOTE: only considers a up to 16 bits.
0404BF             0191*   ; preserves all other registers
0404BF             0192*   ; modified by Brandon R. Gates to use a instead of de
0404BF             0193*   ;------------------------------------------------------------------------
0404BF             0194*   shr_hlu:
0404BF 22 DC 04 04 0195*   	ld		(bitbuf1),hl
0404C3 21 DE 04 04 0196*   	ld		hl,bitbuf1+2
0404C7             0197*   @shr_loop:
0404C7 B7          0198*   	or a
0404C8 28 0D       0199*   	jr		z,@shr_done		;we're done
0404CA             0200*   ;carry is clear from or instruction
0404CA CB 1E       0201*   	rr		(hl)
0404CC 2B          0202*   	dec		hl
0404CD CB 1E       0203*   	rr		(hl)
0404CF 2B          0204*   	dec		hl
0404D0 CB 1E       0205*   	rr		(hl)
0404D2 23          0206*   	inc		hl
0404D3 23          0207*   	inc		hl
0404D4 3D          0208*   	dec a
0404D5 18 F0       0209*   	jr		@shr_loop
0404D7             0210*   @shr_done:
0404D7 2A DC 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
0404DB C9          0212*   	ret
0404DC             0213*   
0404DC             0214*   ;------------------------------------------------------------------------
0404DC             0215*   ; Scratch area for calculations
0404DC             0216*   ;------------------------------------------------------------------------
0404DC 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
0404DF 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
0404E2             0219*   
0404E2             0220*   ; -----------------------------------------------------------------------
0404E2             0221*   ; Functions added by Brandon R. Gates
0404E2             0222*   ; -----------------------------------------------------------------------
0404E2             0223*   
0404E2             0224*   ;------------------------------------------------------------------------
0404E2             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
0404E2             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
0404E2             0227*   ;              HLU = HLU >> LSB(A)
0404E2             0228*   ; Returns: HLU = HLU >> LSB(A)
0404E2             0229*   ; Destroys: af
0404E2             0230*   ;------------------------------------------------------------------------
0404E2             0231*   shr_hlu_log2a:
0404E2 B7          0232*   	or a    ; check for zero
0404E3 C8          0233*   	ret z   ; nothing to shift so we're done
0404E4 C5          0234*   	push 	bc ; preserve
0404E5 06 00       0235*   	ld		b,0 ; clear b
0404E7             0236*   @find_bit:
0404E7 0F          0237*   	rrca ; bit 0 to carry
0404E8 DA F1 04 04 0238*   	jp c,@found_bit
0404EC 04          0239*   	inc b ; next bit
0404ED C3 E7 04 04 0240*   	jp @find_bit
0404F1             0241*   @found_bit:
0404F1 78          0242*   	ld a,b
0404F2 CD BF 04 04 0243*   	call shr_hlu
0404F6 C1          0244*   	pop 	bc ; restore
0404F7 C9          0245*   	ret
0404F8             0246*   ; end shr_hlu_log2a
0404F8             0247*   
0404F8             0248*   ;------------------------------------------------------------------------
0404F8             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
0404F8             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
0404F8             0251*   ;                HLU = HLU << LSB(A)
0404F8             0252*   ; Returns: HLU = HLU << LSB(A)
0404F8             0253*   ; Destroys: af
0404F8             0254*   ;------------------------------------------------------------------------
0404F8             0255*   shl_hlu_log2a:
0404F8 B7          0256*   	or a    ; check for zero
0404F9 C8          0257*   	ret z   ; nothing to shift so we're done
0404FA C5          0258*   	push 	bc ; preserve
0404FB 06 00       0259*   	ld		b,0 ; clear b
0404FD             0260*   @find_bit:
0404FD 0F          0261*   	rrca ; bit 0 to carry
0404FE DA 07 05 04 0262*   	jp c,@found_bit
040502 04          0263*   	inc b ; next bit
040503 C3 FD 04 04 0264*   	jp @find_bit
040507             0265*   @found_bit:
040507 78          0266*   	ld a,b
040508 CD B9 04 04 0267*   	call shl_hlu
04050C C1          0268*   	pop 	bc ; restore
04050D C9          0269*   	ret
04050E             0270*   ; end shl_hlu_log2a
04050E             0271*   
04050E             0272*   
04050E             0273*   ; UHL / UDE --> UDE (signed), remainder UHL (unsigned)
04050E F5          0274*   push af ; dummy push to make IDE happy
04050F             0275*   sdiv24:
04050F             0276*   ; make everything positive and store sign flags
04050F CD 08 25 04 0277*       call hlu_abs
040513 F5          0278*       push af
040514 EB          0279*       ex de,hl
040515 CD 08 25 04 0280*       call hlu_abs
040519 EB          0281*       ex de,hl
04051A F5          0282*       push af
04051B             0283*   ; do the division
04051B CD 24 04 04 0284*       call udiv24 ; de = quotient, hl = remainder
04051F             0285*   ; adjust sign of result
04051F F1          0286*       pop af ; sign de
040520 FA 2D 05 04 0287*       jp m,@de_neg
040524 F1          0288*       pop af ; sign hl
040525 F0          0289*       ret p ; both positive, nothing to do
040526             0290*   @hl_neg:
040526 EB          0291*       ex de,hl ; quotient to hl for sign adjustment
040527 CD 18 25 04 0292*       call neg_hlu ; de pos, hl neg, result is negative
04052B EB          0293*       ex de,hl ; negated quotient to de
04052C C9          0294*       ret
04052D             0295*   @de_neg:
04052D F1          0296*       pop af
04052E F8          0297*       ret m ; both negative, nothing to do
04052F EB          0298*       ex de,hl ; quotient to hl for sign adjustment
040530 CD 18 25 04 0299*       call neg_hlu ; result is negative
040534 EB          0300*       ex de,hl ; negated quotient to de
040535 C9          0301*       ret
040536             0032        include "../agon/fixed168.inc"
040536             0001*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040536             0002*   ; uses EZ80 MLT instruction for speed
040536             0003*   ; operation: UHL * A --> UHL
040536             0004*   ; destroys: AF, HL
040536             0005*   smul24x8:
040536             0006*   ; make hl positive and store sign flag
040536 CD 08 25 04 0007*       call hlu_abs
04053A F5          0008*       push af
04053B             0009*   ; do the multiplication
04053B CD 46 05 04 0010*       call mul24x8 ; hl = product
04053F             0011*   ; adjust sign of result
04053F F1          0012*       pop af ; sign de
040540 F0          0013*       ret p ; hl was positive, nothing to do
040541 CD 18 25 04 0014*       call neg_hlu ; result is negative
040545 C9          0015*       ret
040546             0016*   
040546             0017*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040546             0018*   ; uses EZ80 MLT instruction for speed
040546             0019*   ; operation: UHL * A --> AUHL
040546             0020*   ; destroys: AF, HL
040546             0021*   mul24x8:
040546 D5          0022*       push de ; preserve de
040547             0023*   ; low byte
040547 5D          0024*       ld e,l
040548 57          0025*       ld d,a
040549 ED 5C       0026*       mlt de
04054B 6B          0027*       ld l,e ; product low byte
04054C 08          0028*       ex af,af' ; save multiplier
04054D 7A          0029*       ld a,d ; carry
04054E 08          0030*       ex af,af' ; save carry, restore multiplier
04054F             0031*   ; high byte
04054F 5C          0032*       ld e,h
040550 57          0033*       ld d,a
040551 ED 5C       0034*       mlt de
040553 08          0035*       ex af,af' ; save multiplier, restore carry
040554 83          0036*       add a,e ; add carry
040555 67          0037*       ld h,a ; product middle byte
040556 7A          0038*       ld a,d ; carry
040557 08          0039*       ex af,af' ; save carry, restore multiplier
040558             0040*   ; upper byte
040558 22 73 05 04 0041*       ld (@scratch),hl ; 7 cycles
04055C 5F          0042*       ld e,a
04055D 3A 75 05 04 0043*       ld a,(@scratch+2)
040561 57          0044*       ld d,a
040562 ED 5C       0045*       mlt de
040564 08          0046*       ex af,af' ; restore carry
040565 8B          0047*       adc a,e ; add carry
040566 32 75 05 04 0048*       ld (@scratch+2),a ; 5 cycles
04056A 2A 73 05 04 0049*       ld hl,(@scratch) ; 7 cycles
04056E             0050*   ; highest byte
04056E 3E 00       0051*       ld a,0 ; preserve carry flag
040570 8A          0052*       adc a,d ; product highest byte
040571 D1          0053*       pop de ; restore de
040572 C9          0054*       ret
040573             0055*   @scratch: ds 3
040576             0056*   
       FF FF FF 
040576 00 00 00 00 0057*   mul24out: blkb 6,0
       00 00       
04057C             0058*   
04057C             0059*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
04057C             0060*   ; operation: UHL * UDE --> mul24out
04057C             0061*   mul24:
04057C DD E5       0062*       push ix ; preserve
04057E             0063*   ; point to output buffer and clear it
04057E DD 21 76 05 0064*       ld ix,mul24out
       04          
040583 C5          0065*       push bc
040584 01 00 00 00 0066*       ld bc,0
040588 DD 0F 00    0067*       ld (ix),bc
04058B DD 0F 03    0068*       ld (ix+3),bc
04058E C1          0069*       pop bc
04058F             0070*   ; STEP 1: UHL * E
04058F 7B          0071*       ld a,e
040590 E5          0072*       push hl
040591 CD 46 05 04 0073*       call mul24x8
040595 DD 2F 00    0074*       ld (ix+0),hl
040598 DD 77 03    0075*       ld (ix+3),a
04059B             0076*   ; STEP 2: UHL * D
04059B E1          0077*       pop hl
04059C E5          0078*       push hl
04059D 7A          0079*       ld a,d
04059E CD 46 05 04 0080*       call mul24x8
0405A2 CD BB 05 04 0081*       call @accumulate
0405A6             0082*   ; STEP 3: UHL * DEU
0405A6 E1          0083*       pop hl
0405A7 ED 53 EB 05 0084*       ld (@de),de
       04          
0405AC 3A ED 05 04 0085*       ld a,(@de+2)
0405B0 CD 46 05 04 0086*       call mul24x8
0405B4 CD BB 05 04 0087*       call @accumulate
0405B8             0088*   ; all done
0405B8 DD E1       0089*       pop ix ; restore
0405BA C9          0090*       ret
0405BB             0091*   @accumulate:
0405BB DD 23       0092*       inc ix
0405BD             0093*   ; highest byte of product to carry
0405BD DD 77 03    0094*       ld (ix+3),a
0405C0             0095*   ; low byte of product
0405C0 7D          0096*       ld a,l
0405C1 DD 86 00    0097*       add a,(ix+0)
0405C4 DD 77 00    0098*       ld (ix+0),a
0405C7             0099*   ; high byte of product
0405C7 7C          0100*       ld a,h
0405C8 DD 8E 01    0101*       adc a,(ix+1)
0405CB DD 77 01    0102*       ld (ix+1),a
0405CE             0103*   ; uppper byte of product
0405CE 22 E8 05 04 0104*       ld (@hl),hl
0405D2 3A EA 05 04 0105*       ld a,(@hl+2)
0405D6 DD 8E 02    0106*       adc a,(ix+2)
0405D9 DD 77 02    0107*       ld (ix+2),a
0405DC             0108*   ; carry
0405DC 3E 00       0109*       ld a,0 ; preserve flags
0405DE DD 8E 03    0110*       adc a,(ix+3)
0405E1 DD 77 03    0111*       ld (ix+3),a
0405E4 C9          0112*       ret
0405E5             0113*   
0405E5 00 00 00    0114*   @ix: dl 0
0405E8 00 00 00    0115*   @hl: dl 0
0405EB 00 00 00    0116*   @de: dl 0
0405EE             0117*   
0405EE             0118*   ; UH.L = UH.L*UD.E (unsigned)
0405EE             0119*   umul168:
0405EE CD 7C 05 04 0120*       call mul24
0405F2 2A 77 05 04 0121*       ld hl,(mul24out+1)
0405F6 C9          0122*       ret
0405F7             0123*   
0405F7             0124*   ; UH.L * UD.E --> UH.L (signed)
0405F7             0125*   smul168:
0405F7             0126*   ; make everything positive and store sign flags
0405F7 CD 08 25 04 0127*       call hlu_abs
0405FB F5          0128*       push af
0405FC EB          0129*       ex de,hl
0405FD CD 08 25 04 0130*       call hlu_abs
040601 EB          0131*       ex de,hl
040602 F5          0132*       push af
040603             0133*   ; do the division
040603 CD EE 05 04 0134*       call umul168 ; hl = product
040607             0135*   ; adjust sign of result
040607 F1          0136*       pop af ; sign de
040608 FA 13 06 04 0137*       jp m,@de_neg
04060C F1          0138*       pop af ; sign hl
04060D F0          0139*       ret p ; both positive, nothing to do
04060E             0140*   @hl_neg:
04060E CD 18 25 04 0141*       call neg_hlu ; de pos, hl neg, result is negative
040612 C9          0142*       ret
040613             0143*   @de_neg:
040613 F1          0144*       pop af
040614 F8          0145*       ret m ; both negative, nothing to do
040615 CD 18 25 04 0146*       call neg_hlu ; result is negative
040619 C9          0147*       ret
04061A             0148*   
04061A             0149*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
04061A             0150*   ; perform unsigned division of 16.8 fixed place values
04061A             0151*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
04061A             0152*   udiv168:
04061A             0153*   ; back up divisor
04061A ED 53 51 06 0154*       ld (@ude),de
       04          
04061F             0155*   ; get the 16-bit integer part of the quotient
04061F CD 24 04 04 0156*       call udiv24 ; de = quotient, hl = remainder
040623             0157*   ; load quotient to upper three bytes of output
040623 ED 53 58 06 0158*       ld (div168_out+1),de
       04          
040628             0159*   @div256:
040628             0160*   ; multiply remainder by 256
040628             0161*       HLU_MUL_256
                       M1 Args: none
040628 29          0001*M1     add hl,hl ; * 2
040629 29          0002*M1     add hl,hl ; * 4
04062A 29          0003*M1     add hl,hl ; * 8
04062B 29          0004*M1     add hl,hl ; * 16
04062C 29          0005*M1     add hl,hl ; * 32
04062D 29          0006*M1     add hl,hl ; * 64
04062E 29          0007*M1     add hl,hl ; * 128
04062F 29          0008*M1     add hl,hl ; * 256
040630             0162*   ; skip fractional computation if remainder is zero
040630             0163*       SIGN_UHL
                       M1 Args: none
040630 19          0001*M1     add hl,de ; 1 cycle
040631 B7          0002*M1     or a ; clear flags ; 1 cycle
040632 ED 52       0003*M1     sbc hl,de ; 2 cycles
040634             0004*M1     ; 4 cycles total
040634 20 03       0164*       jr nz,@div_frac
040636 AF          0165*       xor a
040637 18 0A       0166*       jr @write_frac
040639             0167*   ; now divide the shifted remainder by the divisor
040639             0168*   @div_frac:
040639 ED 5B 51 06 0169*       ld de,(@ude) ; get back divisor
       04          
04063E CD 24 04 04 0170*       call udiv24 ; de = quotient, hl = remainder
040642             0171*   ; load low byte of quotient to low byte of output
040642 7B          0172*       ld a,e
040643             0173*   @write_frac:
040643 32 57 06 04 0174*       ld (div168_out),a
040647             0175*   ; load de with return value
040647 ED 5B 57 06 0176*       ld de,(div168_out)
       04          
04064C             0177*   ; load a with any overflow
04064C 3A 5A 06 04 0178*       ld a,(div168_out+3)
040650 C9          0179*       ret ; ud.e is the 16.8 result
040651             0180*   @ude: ds 6
040657             0181*   div168_out: ds 4 ; the extra byte is for overflow
04065B             0182*   
04065B             0183*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
04065B             0184*   ; perform signed division of 16.8 fixed place values
04065B             0185*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
04065B             0186*   sdiv168:
04065B             0187*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
04065B CD 08 25 04 0188*       call hlu_abs
04065F F5          0189*       push af
040660 EB          0190*       ex de,hl
040661 CD 08 25 04 0191*       call hlu_abs
040665 EB          0192*       ex de,hl
040666 F5          0193*       push af
040667             0194*   ; do the division
040667 CD 1A 06 04 0195*       call udiv168 ; de = quotient, hl = remainder
04066B             0196*   ; adjust sign of result
04066B F1          0197*       pop af ; sign de
04066C FA 79 06 04 0198*       jp m,@de_neg
040670 F1          0199*       pop af ; sign hl
040671 F0          0200*       ret p ; both positive, nothing to do
040672             0201*   @hl_neg:
040672 EB          0202*       ex de,hl ; hl = quotient, de = remainder
040673 CD 18 25 04 0203*       call neg_hlu ; de pos, hl neg, result is negative
040677 EB          0204*       ex de,hl ; de = negated quotient, hl = remainder
040678 C9          0205*       ret
040679             0206*   @de_neg:
040679 F1          0207*       pop af
04067A F8          0208*       ret m ; both negative, nothing to do
04067B EB          0209*       ex de,hl ; hl = quotient, de = remainder
04067C CD 18 25 04 0210*       call neg_hlu ; result is negative
040680 EB          0211*       ex de,hl ; de = negated quotient, hl = remainder
040681 C9          0212*       ret
040682             0213*   
040682             0214*   ; convert signed angles from a 360 to 256 degree circle
040682             0215*   ; inputs: uh.l is the angle360 in 16.8 fixed format
040682             0216*   ; outputs: uh.l is the angle256 in 16.8 fixed format
040682             0217*   ; destroys: TODO
040682             0218*   deg_360_to_256:
040682 D5          0219*       push de ; preserve de
040683             0220*   ; make angle positive and store sign flag
040683 CD 08 25 04 0221*       call hlu_abs
040687 F5          0222*       push af
040688             0223*   ; multiply by coversion factor of 256/360
040688 11 B6 00 00 0224*       ld de,0x0000B6 ; 0.711
04068C CD EE 05 04 0225*       call umul168 ; uh.l = uh.l * 0.711
040690             0226*   ; restore sign flag and adjust output accordingly
040690 F1          0227*       pop af
040691 F2 99 06 04 0228*       jp p,@pos ; positive number
040695 CD 18 25 04 0229*       call neg_hlu
040699             0230*   @pos:
040699             0231*   ; restore de and return uh.l as the result
040699 D1          0232*       pop de
04069A C9          0233*       ret
04069B             0234*   
04069B             0235*   ; convert signed angles from a 256 to 360 degree circle
04069B             0236*   ; inputs: uh.l is the angle256 in 16.8 fixed format
04069B             0237*   ; outputs: uh.l is the angle360 in 16.8 fixed format
04069B             0238*   ; destroys: TODO
04069B             0239*   deg_256_to_360:
04069B D5          0240*       push de ; preserve de
04069C             0241*   ; make angle positive and store sign flag
04069C CD 08 25 04 0242*       call hlu_abs
0406A0 F5          0243*       push af
0406A1             0244*   ; multiply by coversion factor of 360/256
0406A1 11 68 01 00 0245*       ld de,0x000168 ; 1.406
0406A5 CD EE 05 04 0246*       call umul168 ; uh.l = uh.l * 1.406
0406A9             0247*   ; restore sign flag and adjust output accordingly
0406A9 F1          0248*       pop af
0406AA F2 B2 06 04 0249*       jp p,@pos ; positive number
0406AE CD 18 25 04 0250*       call neg_hlu
0406B2             0251*   @pos:
0406B2             0252*   ; restore de and return uh.l as the result
0406B2 D1          0253*       pop de
0406B3 C9          0254*       ret
0406B4             0255*   
0406B4             0256*   ; fixed 16.8 routine
0406B4             0257*   ; cos(uh.l) --> uh.l
0406B4             0258*   ; destroys: f, hl
0406B4             0259*   cos168:
0406B4 D5          0260*       push de ; preserve de
0406B5             0261*   ; for cos we simply increment the angle by 90 degrees
0406B5             0262*   ; or 0x004000 in 16.8 degrees256
0406B5             0263*   ; which makes it a sin problem
0406B5 11 00 40 00 0264*       ld de,0x004000
0406B9 19          0265*       add hl,de ; modulo 256 happens below
0406BA D1          0266*       pop de ; restore de
0406BB             0267*   ; fall through to sin168
0406BB             0268*   
0406BB             0269*   ; ---------------------
0406BB             0270*   ; fixed 16.8 routine
0406BB             0271*   ; sin(uh.l) --> uh.l
0406BB             0272*   ; destroys: f, hl
0406BB             0273*   sin168:
0406BB D5          0274*       push de
0406BC             0275*   ; handle negative angles appropriately
0406BC CD 08 25 04 0276*       call hlu_abs
0406C0 F2 C9 06 04 0277*       jp p,@F
0406C4 11 00 00 FF 0278*       ld de,-256*256
0406C8 19          0279*       add hl,de
0406C9             0280*   @@:
0406C9 2E 03       0281*       ld l,3 ; multiply by 3 to get our lookup index
0406CB ED 6C       0282*       mlt hl
0406CD 11 81 09 04 0283*       ld de,sin_lut_168 ; grab the lut address
0406D1 19          0284*       add hl,de ; bump hl by the index
0406D2 ED 27       0285*       ld hl,(hl) ; don't try this on a z80!
0406D4 D1          0286*       pop de
0406D5 C9          0287*       ret
0406D6             0288*   
0406D6             0289*   ; 16.8 fixed inputs / outputs
0406D6             0290*   ; takes: uh.l as angle in degrees 256
0406D6             0291*   ;        ud.e as radius
0406D6             0292*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
0406D6             0293*   ;        displacements from origin (0,0)
0406D6             0294*   ; destroys: everything except indexes
0406D6             0295*   polar_to_cartesian:
0406D6             0296*   ; back up input parameters
0406D6 22 05 07 04 0297*       ld (@angle), hl
0406DA ED 53 08 07 0298*       ld (@radius), de
       04          
0406DF             0299*   ; compute dx = sin(uh.l) * ud.e
0406DF CD BB 06 04 0300*       call sin168 ; uh.l = sin(uh.l)
0406E3 ED 5B 08 07 0301*       ld de,(@radius)
       04          
0406E8 CD F7 05 04 0302*       call smul168 ; uh.l = dx
0406EC E5          0303*       push hl
0406ED             0304*   ; compute dy = -cos(uh.l) * ud.e
0406ED 2A 05 07 04 0305*       ld hl,(@angle)
0406F1 CD B4 06 04 0306*       call cos168 ; uh.l = cos(uh.l)
0406F5 ED 5B 08 07 0307*       ld de,(@radius)
       04          
0406FA CD F7 05 04 0308*       call smul168 ; uh.l = dy
0406FE CD 18 25 04 0309*       call neg_hlu ; invert dy for screen coords convention
040702 EB          0310*       ex de,hl ; de = dy for output
040703 C1          0311*       pop bc ; bc = dx for output
040704             0312*   ; and out
040704 C9          0313*       ret
040705             0314*   @angle: ds 3
040708             0315*   @radius: ds 3
04070B             0316*   
04070B             0317*   ; 16.8 fixed inputs / outputs
04070B             0318*   ; inputs: ub.c as dx, ud.e as dy
04070B             0319*   ;        displacements from origin (0,0)
04070B             0320*   ; returns: uh.l as angle in degrees 256
04070B             0321*   ;        ud.e as radius
04070B             0322*   ; destroys: everything except indexes
04070B             0323*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
04070B ED 43 64 07 0324*       ld (dx168),bc ; dx argument for distance168
       04          
040710 ED 53 6A 07 0325*       ld (dy168),de ; dy argument for distance168
       04          
040715             0326*   ; compute radius
040715 CD 70 07 04 0327*       call distance168 ; uh.l = radius
040719 E5          0328*       push hl ; save radius
04071A             0329*   ; compute angle
04071A ED 4B 64 07 0330*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
04071F ED 5B 6A 07 0331*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040724 CD D0 07 04 0332*       call atan2_168fast ; uh.l = angle
040728             0333*   ; return result
040728 D1          0334*       pop de ; de = radius (was hl)
040729 C9          0335*       ret
04072A             0336*   ; end cartesian_to_polar
04072A             0337*   
04072A             0338*   ; 16.8 fixed inputs / outputs
04072A             0339*   ; inputs: ub.c as dx, ud.e as dy
04072A             0340*   ;        displacements from origin (0,0)
04072A             0341*   ; returns: uh.l as angle in degrees 256
04072A             0342*   ;        ud.e as radius
04072A             0343*   ; destroys: everything except indexes
04072A             0344*   ; note: uses distance168sm which is more accurate for small deltas
04072A             0345*   cartesian_to_polar_sm:
04072A ED 43 64 07 0346*       ld (dx168),bc ; dx argument for distance168
       04          
04072F ED 53 6A 07 0347*       ld (dy168),de ; dy argument for distance168
       04          
040734             0348*   ; compute radius
040734 CD AB 07 04 0349*       call distance168sm ; uh.l = radius
040738 E5          0350*       push hl ; save radius
040739             0351*   ; compute angle
040739 ED 4B 64 07 0352*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
04073E ED 5B 6A 07 0353*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
040743 CD D0 07 04 0354*       call atan2_168fast ; uh.l = angle
040747             0355*   ; return result
040747 D1          0356*       pop de ; de = radius (was hl)
040748 C9          0357*       ret
040749             0358*   ; end cartesian_to_polar
040749             0359*   
040749             0360*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040749             0361*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040749             0362*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040749             0363*   ;         also populates scratch locations dx168 and dy168
040749             0364*   ; destroys: a,hl,bc,de
040749             0365*   dxy168:
040749             0366*   ; compute dx = x1-x0
040749 AF          0367*       xor a ; clear carry
04074A DD E5       0368*       push ix ; move ix to hl via the stack
04074C E1          0369*       pop hl ; hl = x1
04074D ED 42       0370*       sbc hl,bc ; hl = dx
04074F 22 64 07 04 0371*       ld (dx168),hl ; dx to scratch
040753             0372*   ; compute dy = y1-y0
040753 AF          0373*       xor a ; clear carry
040754 FD E5       0374*       push iy ; move iy to hl via the stack
040756 E1          0375*       pop hl ; hl = y1
040757 ED 52       0376*       sbc hl,de ; hl = dy
040759 22 6A 07 04 0377*       ld (dy168),hl ; dy to scratch
04075D             0378*   ; populate output registers and return
04075D EB          0379*       ex de,hl ; ud.e = dy
04075E ED 4B 64 07 0380*       ld bc,(dx168) ; ub.c = dx
       04          
040763 C9          0381*       ret
040764 00 00 00 00 0382*   dx168: blkb 6,0
       00 00       
04076A 00 00 00 00 0383*   dy168: blkb 6,0
       00 00       
040770             0384*   
040770             0385*   ; compute the euclidian distance between two cartesian coordinates
040770             0386*   ; using the formula d = sqrt(dx^2+dy^2)
040770             0387*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040770             0388*   ; output; uh.l is the 16.8 fixed format distance
040770             0389*   ;         also populates scratch locations dx168 and dy168
040770             0390*   ; destroys: a,hl,bc,de
040770             0391*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040770             0392*   ;       thus the result will always be an integer, albeit in 16.8 format
040770             0393*   distance168:
040770             0394*   ; compute dy^2
040770 2A 6A 07 04 0395*       ld hl,(dy168)
040774 CD 08 25 04 0396*       call hlu_abs
040778             0397*       ; call hlu_udiv256 ; make integer to avoid overflow
040778             0398*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
040778 3B          0001*M1     dec sp ; 1 cycle
040779 E5          0002*M1     push hl ; 4 cycles
04077A 33          0003*M1     inc sp ; 1 cycle
04077B E1          0004*M1     pop hl ; 4 cycles
04077C 23          0005*M1     inc hl ; 1 cycle
04077D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04077F             0007*M1     ; 13 cycles total
04077F E5          0399*       push hl
040780 D1          0400*       pop de
040781 CD 0B 04 04 0401*       call umul24 ; hl = dy^2
040785 E5          0402*       push hl ; save dy^2
040786             0403*   ; compute dx^2
040786 2A 64 07 04 0404*       ld hl,(dx168)
04078A CD 08 25 04 0405*       call hlu_abs
04078E             0406*       ; call hlu_udiv256 ; make integer to avoid overflow
04078E             0407*       SRL_UHL ; make integer to avoid overflow
                       M1 Args: none
04078E 3B          0001*M1     dec sp ; 1 cycle
04078F E5          0002*M1     push hl ; 4 cycles
040790 33          0003*M1     inc sp ; 1 cycle
040791 E1          0004*M1     pop hl ; 4 cycles
040792 23          0005*M1     inc hl ; 1 cycle
040793 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040795             0007*M1     ; 13 cycles total
040795 E5          0408*       push hl
040796 D1          0409*       pop de
040797 CD 0B 04 04 0410*       call umul24 ; hl = dx^2
04079B             0411*   ; add dx^2 and dy^2
04079B D1          0412*       pop de ; de = dy^2 (was hl)
04079C 19          0413*       add hl,de ; hl = dx^2 + dy^2
04079D             0414*   ; compute the square root
04079D CD 9B 08 04 0415*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0407A1 EB          0416*       ex de,hl ; hl = distance
0407A2             0417*       HLU_MUL_256 ; convert back to 16.8 fixed
                       M1 Args: none
0407A2 29          0001*M1     add hl,hl ; * 2
0407A3 29          0002*M1     add hl,hl ; * 4
0407A4 29          0003*M1     add hl,hl ; * 8
0407A5 29          0004*M1     add hl,hl ; * 16
0407A6 29          0005*M1     add hl,hl ; * 32
0407A7 29          0006*M1     add hl,hl ; * 64
0407A8 29          0007*M1     add hl,hl ; * 128
0407A9 29          0008*M1     add hl,hl ; * 256
0407AA C9          0418*       ret
0407AB             0419*   
0407AB             0420*   ; compute the euclidian distance between two cartesian coordinates
0407AB             0421*   ; using the formula d = sqrt(dx^2+dy^2)
0407AB             0422*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
0407AB             0423*   ; output; uh.l is the 16.8 fixed format distance
0407AB             0424*   ;         also populates scratch locations dx168 and dy168
0407AB             0425*   ; destroys: a,hl,bc,de
0407AB             0426*   ; NOTE: sm means 'small' because it doesn't round down the deltas
0407AB             0427*   ;       making it more accurate for small deltas,
0407AB             0428*   ;       but will overflow if used for screen-sized deltas
0407AB             0429*   distance168sm:
0407AB             0430*   ; compute dy^2
0407AB 2A 6A 07 04 0431*       ld hl,(dy168)
0407AF CD 08 25 04 0432*       call hlu_abs
0407B3 E5          0433*       push hl
0407B4 D1          0434*       pop de
0407B5 CD 0B 04 04 0435*       call umul24 ; hl = dy^2
0407B9 E5          0436*       push hl ; save dy^2
0407BA             0437*   ; compute dx^2
0407BA 2A 64 07 04 0438*       ld hl,(dx168)
0407BE CD 08 25 04 0439*       call hlu_abs
0407C2 E5          0440*       push hl
0407C3 D1          0441*       pop de
0407C4 CD 0B 04 04 0442*       call umul24 ; hl = dx^2
0407C8             0443*   ; add dx^2 and dy^2
0407C8 D1          0444*       pop de ; de = dy^2 (was hl)
0407C9 19          0445*       add hl,de ; hl = dx^2 + dy^2
0407CA             0446*   ; compute the square root
0407CA CD 9B 08 04 0447*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
0407CE EB          0448*       ex de,hl ; hl = distance
0407CF C9          0449*       ret
0407D0             0450*   
0407D0             0451*   ; atan2_(ub.c,ud.e) --> uh.l
0407D0             0452*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0407D0             0453*   ;   whether inputs are integers or fractional doesn't matter
0407D0             0454*   ;   so long as the sign bit of the upper byte is correct
0407D0             0455*   ; output: uh.l is the 16.8 fixed angle in degrees 256
0407D0             0456*   ; angles are COMPASS HEADINGS based on
0407D0             0457*   ; screen coordinate conventions,where the y axis is flipped
0407D0             0458*   ; #E0 224      0       32 #20
0407D0             0459*   ;        -x,-y | +x,-y
0407D0             0460*   ; #C0 192------+------ 64 #40
0407D0             0461*   ;        -x,+y | +x,+y
0407D0             0462*   ; #A0 160   128 #80   96 #60
0407D0             0463*   atan2_168fast:
0407D0             0464*   ; get signs and make everything positive
0407D0             0465*   ; get abs(x) and store its original sign
0407D0 C5          0466*       push bc
0407D1 E1          0467*       pop hl
0407D2 CD 08 25 04 0468*       call hlu_abs ; if x was negative this also sets the sign flag
0407D6 E5          0469*       push hl ; store abs(x)
0407D7 C1          0470*       pop bc ; bc = abs(x)
0407D8 F5          0471*       push af ; store sign of x
0407D9             0472*   ; get abs(y) and store its original sign
0407D9 EB          0473*       ex de,hl ; hl = y
0407DA CD 08 25 04 0474*       call hlu_abs ; if y was negative this also sets the sign flag
0407DE EB          0475*       ex de,hl ; de = abs(y)
0407DF F5          0476*       push af ; store sign of y
0407E0             0477*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0407E0             0478*   ; this ensures that our lookup value is between 0 and 1 inclusive
0407E0 AF          0479*       xor a ; clear the carry flag
0407E1 D5          0480*       push de
0407E2 E1          0481*       pop hl
0407E3 ED 42       0482*       sbc hl,bc
0407E5 F5          0483*       push af ; save sign of de - bc
0407E6 F2 EF 07 04 0484*       jp p,@1 ; bc <= de, so we skip ahead
0407EA             0485*   ; otherwise we swap bc and de
0407EA C5          0486*       push bc
0407EB E1          0487*       pop hl
0407EC EB          0488*       ex de,hl
0407ED E5          0489*       push hl
0407EE C1          0490*       pop bc
0407EF             0491*   @1:
0407EF             0492*   ; now we're ready to snag our preliminary result
0407EF C5          0493*       push bc
0407F0 E1          0494*       pop hl
0407F1 CD 5F 08 04 0495*       call atan_168fast ; uh.l comes back with prelim result
0407F5             0496*   ; now we adjust uh.l based on sign of de - bc
0407F5 F1          0497*       pop af
0407F6 F2 02 08 04 0498*       jp p,@2 ; bc <= de,so we skip ahead
0407FA EB          0499*       ex de,hl
0407FB 21 00 40 00 0500*       ld hl,64*256 ; subtract from 64 (90) degrees
0407FF AF          0501*       xor a ; clear the carry flag
040800 ED 52       0502*       sbc hl,de
040802             0503*   @2:
040802             0504*   ; adjust the result based on quadrant
040802             0505*   ; #E0 224      0       32 #20
040802             0506*   ;        -x,-y | +x,-y
040802             0507*   ; #C0 192------+------ 64 #40
040802             0508*   ;        -x,+y | +x,+y
040802             0509*   ; #A0 160   128 #80   96 #60
040802 F1          0510*       pop af ; sign of y
040803 CA 40 08 04 0511*       jp z,@y_zero
040807 F2 20 08 04 0512*       jp p,@y_pos
04080B             0513*   ; y neg,check x
04080B F1          0514*       pop af ; sign of x
04080C CA 1A 08 04 0515*       jp z,@y_neg_x_zero
040810 F2 1F 08 04 0516*       jp p,@y_neg_x_pos
040814             0517*   ; y neg,x neg
040814             0518*   ; angle is 128 to 256 (270 to 360)
040814             0519*   ; negating the intermediate does the trick
040814 CD 18 25 04 0520*       call neg_hlu
040818 18 31       0521*       jr @zero_hlu
04081A             0522*   
04081A             0523*   @y_neg_x_zero:
04081A             0524*   ; y neg,x zero
04081A             0525*   ; angle is 0
04081A 21 00 00 00 0526*       ld hl,0
04081E C9          0527*       ret
04081F             0528*   @y_neg_x_pos:
04081F             0529*   ; y neg,x pos
04081F             0530*   ; angle is 0 to 64 (0 to 90)
04081F             0531*   ; so we're good
04081F C9          0532*       ret
040820             0533*   
040820             0534*   @y_pos:
040820 F1          0535*       pop af ; sign of x
040821 CA 30 08 04 0536*       jp z,@y_pos_x_zero
040825 F2 35 08 04 0537*       jp p,@y_pos_x_pos
040829             0538*   ; y pos,x neg
040829             0539*   ; angle is 128 to 192 (180-270)
040829             0540*   ; so we add 128 to intermediate
040829 11 00 80 00 0541*       ld de,128*256
04082D 19          0542*       add hl,de
04082E 18 1B       0543*       jr @zero_hlu
040830             0544*   @y_pos_x_zero:
040830             0545*   ; y pos,x zero
040830             0546*   ; angle is 128 (180)
040830 21 00 80 00 0547*       ld hl,128*256
040834 C9          0548*       ret
040835             0549*   @y_pos_x_pos:
040835             0550*   ; y pos,x pos
040835             0551*   ; angle is 64 to 128 (90 to 180)
040835             0552*   ; neg the intermediate and add 180 degrees
040835 CD 18 25 04 0553*       call neg_hlu
040839 11 00 80 00 0554*       ld de,128*256
04083D 19          0555*       add hl,de
04083E 18 0B       0556*       jr @zero_hlu
040840             0557*   
040840             0558*   @y_zero:
040840 F1          0559*       pop af ; sign of x
040841 FA 46 08 04 0560*       jp m,@y_zero_x_neg
040845             0561*   ; y zero,x pos
040845             0562*   ; angle is 64 (90),nothing to do
040845 C9          0563*       ret
040846             0564*   @y_zero_x_neg:
040846             0565*   ; y zero ,x neg
040846             0566*   ; angle is 192 (270)
040846 21 00 C0 00 0567*       ld hl,192*256
04084A C9          0568*       ret
04084B             0569*   @zero_hlu:
04084B AF          0570*       xor a
04084C 22 59 08 04 0571*       ld (@scratch),hl
040850 32 5B 08 04 0572*       ld (@scratch+2),a
040854 2A 59 08 04 0573*       ld hl,(@scratch)
040858 C9          0574*       ret
040859             0575*   @scratch: ds 6
04085F             0576*   
04085F             0577*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04085F             0578*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
04085F             0579*   ; destroys: a,hl,bc,de
04085F             0580*   ; note: only works for angles from 0 to 32 (45) degrees
04085F             0581*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
04085F             0582*   atan_168fast:
04085F             0583*   ; because we use compass headings instead of geometric angles
04085F             0584*   ; we compute dx/dy which is 1/tan(theta) in the maths world
04085F             0585*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
04085F CD 1A 06 04 0586*       call udiv168 ; ud.e = dx/dy
040863 EB          0587*       ex de,hl ; uh.l = dx/dy
040864             0588*   ; test uh.l for 0
040864 19          0589*       add hl,de
040865 B7          0590*       or a
040866 ED 52       0591*       sbc hl,de
040868 28 22       0592*       jr z,@is_zero
04086A             0593*   ; test uh.l for 1
04086A AF          0594*       xor a ; clear carry
04086B EB          0595*       ex de,hl
04086C 21 00 01 00 0596*       ld hl,1*256 ; 1 in 16.8 fixed format
040870 ED 52       0597*       sbc hl,de
040872 28 13       0598*       jr z,@is_45
040874 EB          0599*       ex de,hl
040875             0600*   ; no special cases so we move on
040875             0601*   ; l contains the fractional portion of tan(uh.l)
040875             0602*   ; we multiply it by three to get our lookup table index
040875 26 03       0603*       ld h,3
040877 ED 6C       0604*       mlt hl ; index into lut
040879 11 00 00 00 0605*       ld de,0 ; clear deu
04087D 54          0606*       ld d,h ; copy hl to de
04087E 5D          0607*       ld e,l ; de contains our index
04087F 21 84 0C 04 0608*       ld hl,atan_lut_168 ; grab the lut address
040883 19          0609*       add hl,de ; bump hl by the index
040884 ED 27       0610*       ld hl,(hl) ; don't try this on a z80!
040886 C9          0611*       ret ; and out
040887             0612*   @is_45:
040887 21 00 20 00 0613*       ld hl,32*256
04088B C9          0614*       ret
04088C             0615*   ; for the case tan(0)
04088C             0616*   @is_zero:
04088C 21 00 00 00 0617*       ld hl,0*256
040890 C9          0618*       ret
040891             0619*   
040891             0620*   ; Expects  ADL mode
040891             0621*   ; Inputs:  UH.L
040891             0622*   ; Outputs: UH.L is the 16.8 square root
040891             0623*   ;          UDE is the integer difference inputHL-DE^2
040891             0624*   sqrt168:
040891 CD 9B 08 04 0625*       call sqrt24
040895 EB          0626*       ex de,hl
040896 29          0627*       add hl,hl
040897 29          0628*       add hl,hl
040898 29          0629*       add hl,hl
040899 29          0630*       add hl,hl
04089A C9          0631*       ret
04089B             0632*   
04089B             0633*   ; credit: xeda112358
04089B             0634*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
04089B             0635*   sqrt24:
04089B             0636*   ; Expects ADL mode
04089B             0637*   ; Inputs: HL
04089B             0638*   ; Outputs: DE is the integer square root
04089B             0639*   ;  HL is the difference inputHL-DE^2
04089B             0640*   ;  c flag reset
04089B 01 00 00 00 0641*       ld bc,0 ; clear bcu
04089F 11 00 00 00 0642*       ld de,0 ; clear deu
0408A3 AF          0643*       xor a
0408A4 45          0644*       ld b,l
0408A5 C5          0645*       push bc
0408A6 47          0646*       ld b,a
0408A7 6F          0647*       ld l,a
0408A8             0648*   ; Iteration 1
0408A8 29          0649*       add hl,hl
0408A9 CB 11       0650*       rl c
0408AB 29          0651*       add hl,hl
0408AC CB 11       0652*       rl c
0408AE 91          0653*       sub c
0408AF 30 04       0654*       jr nc,$+6
0408B1 1C          0655*       inc e
0408B2 1C          0656*       inc e
0408B3 2F          0657*       cpl
0408B4 4F          0658*       ld c,a
0408B5             0659*   ; Iteration 2
0408B5 29          0660*       add hl,hl
0408B6 CB 11       0661*       rl c
0408B8 29          0662*       add hl,hl
0408B9 CB 11       0663*       rl c
0408BB CB 13       0664*       rl e
0408BD 7B          0665*       ld a,e
0408BE 91          0666*       sub c
0408BF 30 04       0667*       jr nc,$+6
0408C1 1C          0668*       inc e
0408C2 1C          0669*       inc e
0408C3 2F          0670*       cpl
0408C4 4F          0671*       ld c,a
0408C5             0672*   ; Iteration 3
0408C5 29          0673*       add hl,hl
0408C6 CB 11       0674*       rl c
0408C8 29          0675*       add hl,hl
0408C9 CB 11       0676*       rl c
0408CB CB 13       0677*       rl e
0408CD 7B          0678*       ld a,e
0408CE 91          0679*       sub c
0408CF 30 04       0680*       jr nc,$+6
0408D1 1C          0681*       inc e
0408D2 1C          0682*       inc e
0408D3 2F          0683*       cpl
0408D4 4F          0684*       ld c,a
0408D5             0685*   ; Iteration 4
0408D5 29          0686*       add hl,hl
0408D6 CB 11       0687*       rl c
0408D8 29          0688*       add hl,hl
0408D9 CB 11       0689*       rl c
0408DB CB 13       0690*       rl e
0408DD 7B          0691*       ld a,e
0408DE 91          0692*       sub c
0408DF 30 04       0693*       jr nc,$+6
0408E1 1C          0694*       inc e
0408E2 1C          0695*       inc e
0408E3 2F          0696*       cpl
0408E4 4F          0697*       ld c,a
0408E5             0698*   ; Iteration 5
0408E5 29          0699*       add hl,hl
0408E6 CB 11       0700*       rl c
0408E8 29          0701*       add hl,hl
0408E9 CB 11       0702*       rl c
0408EB CB 13       0703*       rl e
0408ED 7B          0704*       ld a,e
0408EE 91          0705*       sub c
0408EF 30 04       0706*       jr nc,$+6
0408F1 1C          0707*       inc e
0408F2 1C          0708*       inc e
0408F3 2F          0709*       cpl
0408F4 4F          0710*       ld c,a
0408F5             0711*   ; Iteration 6
0408F5 29          0712*       add hl,hl
0408F6 CB 11       0713*       rl c
0408F8 29          0714*       add hl,hl
0408F9 CB 11       0715*       rl c
0408FB CB 13       0716*       rl e
0408FD 7B          0717*       ld a,e
0408FE 91          0718*       sub c
0408FF 30 04       0719*       jr nc,$+6
040901 1C          0720*       inc e
040902 1C          0721*       inc e
040903 2F          0722*       cpl
040904 4F          0723*       ld c,a
040905             0724*   ; Iteration 7
040905 29          0725*       add hl,hl
040906 CB 11       0726*       rl c
040908 29          0727*       add hl,hl
040909 CB 11       0728*       rl c
04090B CB 10       0729*       rl b
04090D EB          0730*       ex de,hl
04090E 29          0731*       add hl,hl
04090F E5          0732*       push hl
040910 ED 42       0733*       sbc hl,bc
040912 30 06       0734*       jr nc,$+8
040914 7C          0735*       ld a,h
040915 2F          0736*       cpl
040916 47          0737*       ld b,a
040917 7D          0738*       ld a,l
040918 2F          0739*       cpl
040919 4F          0740*       ld c,a
04091A E1          0741*       pop hl
04091B 30 02       0742*       jr nc,$+4
04091D 23          0743*       inc hl
04091E 23          0744*       inc hl
04091F EB          0745*       ex de,hl
040920             0746*   ; Iteration 8
040920 29          0747*       add hl,hl
040921 69          0748*       ld l,c
040922 60          0749*       ld h,b
040923 ED 6A       0750*       adc hl,hl
040925 ED 6A       0751*       adc hl,hl
040927 EB          0752*       ex de,hl
040928 29          0753*       add hl,hl
040929 ED 52       0754*       sbc hl,de
04092B 19          0755*       add hl,de
04092C EB          0756*       ex de,hl
04092D 30 04       0757*       jr nc,$+6
04092F ED 52       0758*       sbc hl,de
040931 13          0759*       inc de
040932 13          0760*       inc de
040933             0761*   ; Iteration 9
040933 F1          0762*       pop af
040934 17          0763*       rla
040935 ED 6A       0764*       adc hl,hl
040937 17          0765*       rla
040938 ED 6A       0766*       adc hl,hl
04093A EB          0767*       ex de,hl
04093B 29          0768*       add hl,hl
04093C ED 52       0769*       sbc hl,de
04093E 19          0770*       add hl,de
04093F EB          0771*       ex de,hl
040940 30 04       0772*       jr nc,$+6
040942 ED 52       0773*       sbc hl,de
040944 13          0774*       inc de
040945 13          0775*       inc de
040946             0776*   ; Iteration 10
040946 17          0777*       rla
040947 ED 6A       0778*       adc hl,hl
040949 17          0779*       rla
04094A ED 6A       0780*       adc hl,hl
04094C EB          0781*       ex de,hl
04094D 29          0782*       add hl,hl
04094E ED 52       0783*       sbc hl,de
040950 19          0784*       add hl,de
040951 EB          0785*       ex de,hl
040952 30 04       0786*       jr nc,$+6
040954 ED 52       0787*       sbc hl,de
040956 13          0788*       inc de
040957 13          0789*       inc de
040958             0790*   ; Iteration 11
040958 17          0791*       rla
040959 ED 6A       0792*       adc hl,hl
04095B 17          0793*       rla
04095C ED 6A       0794*       adc hl,hl
04095E EB          0795*       ex de,hl
04095F 29          0796*       add hl,hl
040960 ED 52       0797*       sbc hl,de
040962 19          0798*       add hl,de
040963 EB          0799*       ex de,hl
040964 30 04       0800*       jr nc,$+6
040966 ED 52       0801*       sbc hl,de
040968 13          0802*       inc de
040969 13          0803*       inc de
04096A             0804*   ; Iteration 12
04096A 17          0805*       rla
04096B ED 6A       0806*       adc hl,hl
04096D 17          0807*       rla
04096E ED 6A       0808*       adc hl,hl
040970 EB          0809*       ex de,hl
040971 29          0810*       add hl,hl
040972 ED 52       0811*       sbc hl,de
040974 19          0812*       add hl,de
040975 EB          0813*       ex de,hl
040976 30 04       0814*       jr nc,$+6
040978 ED 52       0815*       sbc hl,de
04097A 13          0816*       inc de
04097B 13          0817*       inc de
04097C CB 1A       0818*       rr d
04097E CB 1B       0819*       rr e
040980 C9          0820*       ret
040981             0821*   
040981             0822*   sin_lut_168:
040981 00 00 00    0823*       dl 0x000000 ; 0.000 00, 0.000
040984 06 00 00    0824*       dl 0x000006 ; 1.406 01, 0.025
040987 0C 00 00    0825*       dl 0x00000C ; 2.813 02, 0.049
04098A 12 00 00    0826*       dl 0x000012 ; 4.219 03, 0.074
04098D 19 00 00    0827*       dl 0x000019 ; 5.625 04, 0.098
040990 1F 00 00    0828*       dl 0x00001F ; 7.031 05, 0.122
040993 25 00 00    0829*       dl 0x000025 ; 8.438 06, 0.147
040996 2B 00 00    0830*       dl 0x00002B ; 9.844 07, 0.171
040999 31 00 00    0831*       dl 0x000031 ; 11.250 08, 0.195
04099C 38 00 00    0832*       dl 0x000038 ; 12.656 09, 0.219
04099F 3E 00 00    0833*       dl 0x00003E ; 14.063 0A, 0.243
0409A2 44 00 00    0834*       dl 0x000044 ; 15.469 0B, 0.267
0409A5 4A 00 00    0835*       dl 0x00004A ; 16.875 0C, 0.290
0409A8 50 00 00    0836*       dl 0x000050 ; 18.281 0D, 0.314
0409AB 56 00 00    0837*       dl 0x000056 ; 19.688 0E, 0.337
0409AE 5C 00 00    0838*       dl 0x00005C ; 21.094 0F, 0.360
0409B1 61 00 00    0839*       dl 0x000061 ; 22.500 10, 0.383
0409B4 67 00 00    0840*       dl 0x000067 ; 23.906 11, 0.405
0409B7 6D 00 00    0841*       dl 0x00006D ; 25.313 12, 0.428
0409BA 73 00 00    0842*       dl 0x000073 ; 26.719 13, 0.450
0409BD 78 00 00    0843*       dl 0x000078 ; 28.125 14, 0.471
0409C0 7E 00 00    0844*       dl 0x00007E ; 29.531 15, 0.493
0409C3 83 00 00    0845*       dl 0x000083 ; 30.938 16, 0.514
0409C6 88 00 00    0846*       dl 0x000088 ; 32.344 17, 0.535
0409C9 8E 00 00    0847*       dl 0x00008E ; 33.750 18, 0.556
0409CC 93 00 00    0848*       dl 0x000093 ; 35.156 19, 0.576
0409CF 98 00 00    0849*       dl 0x000098 ; 36.563 1A, 0.596
0409D2 9D 00 00    0850*       dl 0x00009D ; 37.969 1B, 0.615
0409D5 A2 00 00    0851*       dl 0x0000A2 ; 39.375 1C, 0.634
0409D8 A7 00 00    0852*       dl 0x0000A7 ; 40.781 1D, 0.653
0409DB AB 00 00    0853*       dl 0x0000AB ; 42.188 1E, 0.672
0409DE B0 00 00    0854*       dl 0x0000B0 ; 43.594 1F, 0.690
0409E1 B5 00 00    0855*       dl 0x0000B5 ; 45.000 20, 0.707
0409E4 B9 00 00    0856*       dl 0x0000B9 ; 46.406 21, 0.724
0409E7 BD 00 00    0857*       dl 0x0000BD ; 47.813 22, 0.741
0409EA C1 00 00    0858*       dl 0x0000C1 ; 49.219 23, 0.757
0409ED C5 00 00    0859*       dl 0x0000C5 ; 50.625 24, 0.773
0409F0 C9 00 00    0860*       dl 0x0000C9 ; 52.031 25, 0.788
0409F3 CD 00 00    0861*       dl 0x0000CD ; 53.438 26, 0.803
0409F6 D1 00 00    0862*       dl 0x0000D1 ; 54.844 27, 0.818
0409F9 D4 00 00    0863*       dl 0x0000D4 ; 56.250 28, 0.831
0409FC D8 00 00    0864*       dl 0x0000D8 ; 57.656 29, 0.845
0409FF DB 00 00    0865*       dl 0x0000DB ; 59.063 2A, 0.858
040A02 DE 00 00    0866*       dl 0x0000DE ; 60.469 2B, 0.870
040A05 E1 00 00    0867*       dl 0x0000E1 ; 61.875 2C, 0.882
040A08 E4 00 00    0868*       dl 0x0000E4 ; 63.281 2D, 0.893
040A0B E7 00 00    0869*       dl 0x0000E7 ; 64.688 2E, 0.904
040A0E EA 00 00    0870*       dl 0x0000EA ; 66.094 2F, 0.914
040A11 EC 00 00    0871*       dl 0x0000EC ; 67.500 30, 0.924
040A14 EE 00 00    0872*       dl 0x0000EE ; 68.906 31, 0.933
040A17 F1 00 00    0873*       dl 0x0000F1 ; 70.313 32, 0.942
040A1A F3 00 00    0874*       dl 0x0000F3 ; 71.719 33, 0.950
040A1D F4 00 00    0875*       dl 0x0000F4 ; 73.125 34, 0.957
040A20 F6 00 00    0876*       dl 0x0000F6 ; 74.531 35, 0.964
040A23 F8 00 00    0877*       dl 0x0000F8 ; 75.938 36, 0.970
040A26 F9 00 00    0878*       dl 0x0000F9 ; 77.344 37, 0.976
040A29 FB 00 00    0879*       dl 0x0000FB ; 78.750 38, 0.981
040A2C FC 00 00    0880*       dl 0x0000FC ; 80.156 39, 0.985
040A2F FD 00 00    0881*       dl 0x0000FD ; 81.563 3A, 0.989
040A32 FE 00 00    0882*       dl 0x0000FE ; 82.969 3B, 0.992
040A35 FE 00 00    0883*       dl 0x0000FE ; 84.375 3C, 0.995
040A38 FF 00 00    0884*       dl 0x0000FF ; 85.781 3D, 0.997
040A3B FF 00 00    0885*       dl 0x0000FF ; 87.188 3E, 0.999
040A3E FF 00 00    0886*       dl 0x0000FF ; 88.594 3F, 1.000
040A41 00 01 00    0887*       dl 0x000100 ; 90.000 40, 1.000
040A44 FF 00 00    0888*       dl 0x0000FF ; 91.406 41, 1.000
040A47 FF 00 00    0889*       dl 0x0000FF ; 92.813 42, 0.999
040A4A FF 00 00    0890*       dl 0x0000FF ; 94.219 43, 0.997
040A4D FE 00 00    0891*       dl 0x0000FE ; 95.625 44, 0.995
040A50 FE 00 00    0892*       dl 0x0000FE ; 97.031 45, 0.992
040A53 FD 00 00    0893*       dl 0x0000FD ; 98.438 46, 0.989
040A56 FC 00 00    0894*       dl 0x0000FC ; 99.844 47, 0.985
040A59 FB 00 00    0895*       dl 0x0000FB ; 101.250 48, 0.981
040A5C F9 00 00    0896*       dl 0x0000F9 ; 102.656 49, 0.976
040A5F F8 00 00    0897*       dl 0x0000F8 ; 104.063 4A, 0.970
040A62 F6 00 00    0898*       dl 0x0000F6 ; 105.469 4B, 0.964
040A65 F4 00 00    0899*       dl 0x0000F4 ; 106.875 4C, 0.957
040A68 F3 00 00    0900*       dl 0x0000F3 ; 108.281 4D, 0.950
040A6B F1 00 00    0901*       dl 0x0000F1 ; 109.688 4E, 0.942
040A6E EE 00 00    0902*       dl 0x0000EE ; 111.094 4F, 0.933
040A71 EC 00 00    0903*       dl 0x0000EC ; 112.500 50, 0.924
040A74 EA 00 00    0904*       dl 0x0000EA ; 113.906 51, 0.914
040A77 E7 00 00    0905*       dl 0x0000E7 ; 115.313 52, 0.904
040A7A E4 00 00    0906*       dl 0x0000E4 ; 116.719 53, 0.893
040A7D E1 00 00    0907*       dl 0x0000E1 ; 118.125 54, 0.882
040A80 DE 00 00    0908*       dl 0x0000DE ; 119.531 55, 0.870
040A83 DB 00 00    0909*       dl 0x0000DB ; 120.938 56, 0.858
040A86 D8 00 00    0910*       dl 0x0000D8 ; 122.344 57, 0.845
040A89 D4 00 00    0911*       dl 0x0000D4 ; 123.750 58, 0.831
040A8C D1 00 00    0912*       dl 0x0000D1 ; 125.156 59, 0.818
040A8F CD 00 00    0913*       dl 0x0000CD ; 126.563 5A, 0.803
040A92 C9 00 00    0914*       dl 0x0000C9 ; 127.969 5B, 0.788
040A95 C5 00 00    0915*       dl 0x0000C5 ; 129.375 5C, 0.773
040A98 C1 00 00    0916*       dl 0x0000C1 ; 130.781 5D, 0.757
040A9B BD 00 00    0917*       dl 0x0000BD ; 132.188 5E, 0.741
040A9E B9 00 00    0918*       dl 0x0000B9 ; 133.594 5F, 0.724
040AA1 B5 00 00    0919*       dl 0x0000B5 ; 135.000 60, 0.707
040AA4 B0 00 00    0920*       dl 0x0000B0 ; 136.406 61, 0.690
040AA7 AB 00 00    0921*       dl 0x0000AB ; 137.813 62, 0.672
040AAA A7 00 00    0922*       dl 0x0000A7 ; 139.219 63, 0.653
040AAD A2 00 00    0923*       dl 0x0000A2 ; 140.625 64, 0.634
040AB0 9D 00 00    0924*       dl 0x00009D ; 142.031 65, 0.615
040AB3 98 00 00    0925*       dl 0x000098 ; 143.438 66, 0.596
040AB6 93 00 00    0926*       dl 0x000093 ; 144.844 67, 0.576
040AB9 8E 00 00    0927*       dl 0x00008E ; 146.250 68, 0.556
040ABC 88 00 00    0928*       dl 0x000088 ; 147.656 69, 0.535
040ABF 83 00 00    0929*       dl 0x000083 ; 149.063 6A, 0.514
040AC2 7E 00 00    0930*       dl 0x00007E ; 150.469 6B, 0.493
040AC5 78 00 00    0931*       dl 0x000078 ; 151.875 6C, 0.471
040AC8 73 00 00    0932*       dl 0x000073 ; 153.281 6D, 0.450
040ACB 6D 00 00    0933*       dl 0x00006D ; 154.688 6E, 0.428
040ACE 67 00 00    0934*       dl 0x000067 ; 156.094 6F, 0.405
040AD1 61 00 00    0935*       dl 0x000061 ; 157.500 70, 0.383
040AD4 5C 00 00    0936*       dl 0x00005C ; 158.906 71, 0.360
040AD7 56 00 00    0937*       dl 0x000056 ; 160.313 72, 0.337
040ADA 50 00 00    0938*       dl 0x000050 ; 161.719 73, 0.314
040ADD 4A 00 00    0939*       dl 0x00004A ; 163.125 74, 0.290
040AE0 44 00 00    0940*       dl 0x000044 ; 164.531 75, 0.267
040AE3 3E 00 00    0941*       dl 0x00003E ; 165.938 76, 0.243
040AE6 38 00 00    0942*       dl 0x000038 ; 167.344 77, 0.219
040AE9 31 00 00    0943*       dl 0x000031 ; 168.750 78, 0.195
040AEC 2B 00 00    0944*       dl 0x00002B ; 170.156 79, 0.171
040AEF 25 00 00    0945*       dl 0x000025 ; 171.563 7A, 0.147
040AF2 1F 00 00    0946*       dl 0x00001F ; 172.969 7B, 0.122
040AF5 19 00 00    0947*       dl 0x000019 ; 174.375 7C, 0.098
040AF8 12 00 00    0948*       dl 0x000012 ; 175.781 7D, 0.074
040AFB 0C 00 00    0949*       dl 0x00000C ; 177.188 7E, 0.049
040AFE 06 00 00    0950*       dl 0x000006 ; 178.594 7F, 0.025
040B01 00 00 00    0951*       dl 0x000000 ; 180.000 80, 0.000
040B04 FA FF FF    0952*       dl 0xFFFFFA ; 181.406 81, -0.025
040B07 F4 FF FF    0953*       dl 0xFFFFF4 ; 182.813 82, -0.049
040B0A EE FF FF    0954*       dl 0xFFFFEE ; 184.219 83, -0.074
040B0D E7 FF FF    0955*       dl 0xFFFFE7 ; 185.625 84, -0.098
040B10 E1 FF FF    0956*       dl 0xFFFFE1 ; 187.031 85, -0.122
040B13 DB FF FF    0957*       dl 0xFFFFDB ; 188.438 86, -0.147
040B16 D5 FF FF    0958*       dl 0xFFFFD5 ; 189.844 87, -0.171
040B19 CF FF FF    0959*       dl 0xFFFFCF ; 191.250 88, -0.195
040B1C C8 FF FF    0960*       dl 0xFFFFC8 ; 192.656 89, -0.219
040B1F C2 FF FF    0961*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040B22 BC FF FF    0962*       dl 0xFFFFBC ; 195.469 8B, -0.267
040B25 B6 FF FF    0963*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040B28 B0 FF FF    0964*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040B2B AA FF FF    0965*       dl 0xFFFFAA ; 199.688 8E, -0.337
040B2E A4 FF FF    0966*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040B31 9F FF FF    0967*       dl 0xFFFF9F ; 202.500 90, -0.383
040B34 99 FF FF    0968*       dl 0xFFFF99 ; 203.906 91, -0.405
040B37 93 FF FF    0969*       dl 0xFFFF93 ; 205.313 92, -0.428
040B3A 8D FF FF    0970*       dl 0xFFFF8D ; 206.719 93, -0.450
040B3D 88 FF FF    0971*       dl 0xFFFF88 ; 208.125 94, -0.471
040B40 82 FF FF    0972*       dl 0xFFFF82 ; 209.531 95, -0.493
040B43 7D FF FF    0973*       dl 0xFFFF7D ; 210.938 96, -0.514
040B46 78 FF FF    0974*       dl 0xFFFF78 ; 212.344 97, -0.535
040B49 72 FF FF    0975*       dl 0xFFFF72 ; 213.750 98, -0.556
040B4C 6D FF FF    0976*       dl 0xFFFF6D ; 215.156 99, -0.576
040B4F 68 FF FF    0977*       dl 0xFFFF68 ; 216.563 9A, -0.596
040B52 63 FF FF    0978*       dl 0xFFFF63 ; 217.969 9B, -0.615
040B55 5E FF FF    0979*       dl 0xFFFF5E ; 219.375 9C, -0.634
040B58 59 FF FF    0980*       dl 0xFFFF59 ; 220.781 9D, -0.653
040B5B 55 FF FF    0981*       dl 0xFFFF55 ; 222.188 9E, -0.672
040B5E 50 FF FF    0982*       dl 0xFFFF50 ; 223.594 9F, -0.690
040B61 4B FF FF    0983*       dl 0xFFFF4B ; 225.000 A0, -0.707
040B64 47 FF FF    0984*       dl 0xFFFF47 ; 226.406 A1, -0.724
040B67 43 FF FF    0985*       dl 0xFFFF43 ; 227.813 A2, -0.741
040B6A 3F FF FF    0986*       dl 0xFFFF3F ; 229.219 A3, -0.757
040B6D 3B FF FF    0987*       dl 0xFFFF3B ; 230.625 A4, -0.773
040B70 37 FF FF    0988*       dl 0xFFFF37 ; 232.031 A5, -0.788
040B73 33 FF FF    0989*       dl 0xFFFF33 ; 233.438 A6, -0.803
040B76 2F FF FF    0990*       dl 0xFFFF2F ; 234.844 A7, -0.818
040B79 2C FF FF    0991*       dl 0xFFFF2C ; 236.250 A8, -0.831
040B7C 28 FF FF    0992*       dl 0xFFFF28 ; 237.656 A9, -0.845
040B7F 25 FF FF    0993*       dl 0xFFFF25 ; 239.063 AA, -0.858
040B82 22 FF FF    0994*       dl 0xFFFF22 ; 240.469 AB, -0.870
040B85 1F FF FF    0995*       dl 0xFFFF1F ; 241.875 AC, -0.882
040B88 1C FF FF    0996*       dl 0xFFFF1C ; 243.281 AD, -0.893
040B8B 19 FF FF    0997*       dl 0xFFFF19 ; 244.688 AE, -0.904
040B8E 16 FF FF    0998*       dl 0xFFFF16 ; 246.094 AF, -0.914
040B91 14 FF FF    0999*       dl 0xFFFF14 ; 247.500 B0, -0.924
040B94 12 FF FF    1000*       dl 0xFFFF12 ; 248.906 B1, -0.933
040B97 0F FF FF    1001*       dl 0xFFFF0F ; 250.313 B2, -0.942
040B9A 0D FF FF    1002*       dl 0xFFFF0D ; 251.719 B3, -0.950
040B9D 0C FF FF    1003*       dl 0xFFFF0C ; 253.125 B4, -0.957
040BA0 0A FF FF    1004*       dl 0xFFFF0A ; 254.531 B5, -0.964
040BA3 08 FF FF    1005*       dl 0xFFFF08 ; 255.938 B6, -0.970
040BA6 07 FF FF    1006*       dl 0xFFFF07 ; 257.344 B7, -0.976
040BA9 05 FF FF    1007*       dl 0xFFFF05 ; 258.750 B8, -0.981
040BAC 04 FF FF    1008*       dl 0xFFFF04 ; 260.156 B9, -0.985
040BAF 03 FF FF    1009*       dl 0xFFFF03 ; 261.563 BA, -0.989
040BB2 02 FF FF    1010*       dl 0xFFFF02 ; 262.969 BB, -0.992
040BB5 02 FF FF    1011*       dl 0xFFFF02 ; 264.375 BC, -0.995
040BB8 01 FF FF    1012*       dl 0xFFFF01 ; 265.781 BD, -0.997
040BBB 01 FF FF    1013*       dl 0xFFFF01 ; 267.188 BE, -0.999
040BBE 01 FF FF    1014*       dl 0xFFFF01 ; 268.594 BF, -1.000
040BC1 00 FF FF    1015*       dl 0xFFFF00 ; 270.000 C0, -1.000
040BC4 01 FF FF    1016*       dl 0xFFFF01 ; 271.406 C1, -1.000
040BC7 01 FF FF    1017*       dl 0xFFFF01 ; 272.813 C2, -0.999
040BCA 01 FF FF    1018*       dl 0xFFFF01 ; 274.219 C3, -0.997
040BCD 02 FF FF    1019*       dl 0xFFFF02 ; 275.625 C4, -0.995
040BD0 02 FF FF    1020*       dl 0xFFFF02 ; 277.031 C5, -0.992
040BD3 03 FF FF    1021*       dl 0xFFFF03 ; 278.438 C6, -0.989
040BD6 04 FF FF    1022*       dl 0xFFFF04 ; 279.844 C7, -0.985
040BD9 05 FF FF    1023*       dl 0xFFFF05 ; 281.250 C8, -0.981
040BDC 07 FF FF    1024*       dl 0xFFFF07 ; 282.656 C9, -0.976
040BDF 08 FF FF    1025*       dl 0xFFFF08 ; 284.063 CA, -0.970
040BE2 0A FF FF    1026*       dl 0xFFFF0A ; 285.469 CB, -0.964
040BE5 0C FF FF    1027*       dl 0xFFFF0C ; 286.875 CC, -0.957
040BE8 0D FF FF    1028*       dl 0xFFFF0D ; 288.281 CD, -0.950
040BEB 0F FF FF    1029*       dl 0xFFFF0F ; 289.688 CE, -0.942
040BEE 12 FF FF    1030*       dl 0xFFFF12 ; 291.094 CF, -0.933
040BF1 14 FF FF    1031*       dl 0xFFFF14 ; 292.500 D0, -0.924
040BF4 16 FF FF    1032*       dl 0xFFFF16 ; 293.906 D1, -0.914
040BF7 19 FF FF    1033*       dl 0xFFFF19 ; 295.313 D2, -0.904
040BFA 1C FF FF    1034*       dl 0xFFFF1C ; 296.719 D3, -0.893
040BFD 1F FF FF    1035*       dl 0xFFFF1F ; 298.125 D4, -0.882
040C00 22 FF FF    1036*       dl 0xFFFF22 ; 299.531 D5, -0.870
040C03 25 FF FF    1037*       dl 0xFFFF25 ; 300.938 D6, -0.858
040C06 28 FF FF    1038*       dl 0xFFFF28 ; 302.344 D7, -0.845
040C09 2C FF FF    1039*       dl 0xFFFF2C ; 303.750 D8, -0.831
040C0C 2F FF FF    1040*       dl 0xFFFF2F ; 305.156 D9, -0.818
040C0F 33 FF FF    1041*       dl 0xFFFF33 ; 306.563 DA, -0.803
040C12 37 FF FF    1042*       dl 0xFFFF37 ; 307.969 DB, -0.788
040C15 3B FF FF    1043*       dl 0xFFFF3B ; 309.375 DC, -0.773
040C18 3F FF FF    1044*       dl 0xFFFF3F ; 310.781 DD, -0.757
040C1B 43 FF FF    1045*       dl 0xFFFF43 ; 312.188 DE, -0.741
040C1E 47 FF FF    1046*       dl 0xFFFF47 ; 313.594 DF, -0.724
040C21 4B FF FF    1047*       dl 0xFFFF4B ; 315.000 E0, -0.707
040C24 50 FF FF    1048*       dl 0xFFFF50 ; 316.406 E1, -0.690
040C27 55 FF FF    1049*       dl 0xFFFF55 ; 317.813 E2, -0.672
040C2A 59 FF FF    1050*       dl 0xFFFF59 ; 319.219 E3, -0.653
040C2D 5E FF FF    1051*       dl 0xFFFF5E ; 320.625 E4, -0.634
040C30 63 FF FF    1052*       dl 0xFFFF63 ; 322.031 E5, -0.615
040C33 68 FF FF    1053*       dl 0xFFFF68 ; 323.438 E6, -0.596
040C36 6D FF FF    1054*       dl 0xFFFF6D ; 324.844 E7, -0.576
040C39 72 FF FF    1055*       dl 0xFFFF72 ; 326.250 E8, -0.556
040C3C 78 FF FF    1056*       dl 0xFFFF78 ; 327.656 E9, -0.535
040C3F 7D FF FF    1057*       dl 0xFFFF7D ; 329.063 EA, -0.514
040C42 82 FF FF    1058*       dl 0xFFFF82 ; 330.469 EB, -0.493
040C45 88 FF FF    1059*       dl 0xFFFF88 ; 331.875 EC, -0.471
040C48 8D FF FF    1060*       dl 0xFFFF8D ; 333.281 ED, -0.450
040C4B 93 FF FF    1061*       dl 0xFFFF93 ; 334.688 EE, -0.428
040C4E 99 FF FF    1062*       dl 0xFFFF99 ; 336.094 EF, -0.405
040C51 9F FF FF    1063*       dl 0xFFFF9F ; 337.500 F0, -0.383
040C54 A4 FF FF    1064*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040C57 AA FF FF    1065*       dl 0xFFFFAA ; 340.313 F2, -0.337
040C5A B0 FF FF    1066*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040C5D B6 FF FF    1067*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040C60 BC FF FF    1068*       dl 0xFFFFBC ; 344.531 F5, -0.267
040C63 C2 FF FF    1069*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040C66 C8 FF FF    1070*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040C69 CF FF FF    1071*       dl 0xFFFFCF ; 348.750 F8, -0.195
040C6C D5 FF FF    1072*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040C6F DB FF FF    1073*       dl 0xFFFFDB ; 351.563 FA, -0.147
040C72 E1 FF FF    1074*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040C75 E7 FF FF    1075*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040C78 EE FF FF    1076*       dl 0xFFFFEE ; 355.781 FD, -0.074
040C7B F4 FF FF    1077*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040C7E FA FF FF    1078*       dl 0xFFFFFA ; 358.594 FF, -0.025
040C81 00 00 00    1079*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040C84             1080*   
040C84             1081*   atan_lut_168:
040C84 00 00 00    1082*       dl 0x000000 ; 000000, 0.000
040C87 28 00 00    1083*       dl 0x000028 ; 000001, 0.224
040C8A 51 00 00    1084*       dl 0x000051 ; 000002, 0.448
040C8D 7A 00 00    1085*       dl 0x00007A ; 000003, 0.671
040C90 A2 00 00    1086*       dl 0x0000A2 ; 000004, 0.895
040C93 CB 00 00    1087*       dl 0x0000CB ; 000005, 1.119
040C96 F4 00 00    1088*       dl 0x0000F4 ; 000006, 1.343
040C99 1D 01 00    1089*       dl 0x00011D ; 000007, 1.566
040C9C 45 01 00    1090*       dl 0x000145 ; 000008, 1.790
040C9F 6E 01 00    1091*       dl 0x00016E ; 000009, 2.013
040CA2 97 01 00    1092*       dl 0x000197 ; 00000A, 2.237
040CA5 BF 01 00    1093*       dl 0x0001BF ; 00000B, 2.460
040CA8 E8 01 00    1094*       dl 0x0001E8 ; 00000C, 2.684
040CAB 11 02 00    1095*       dl 0x000211 ; 00000D, 2.907
040CAE 39 02 00    1096*       dl 0x000239 ; 00000E, 3.130
040CB1 62 02 00    1097*       dl 0x000262 ; 00000F, 3.353
040CB4 8B 02 00    1098*       dl 0x00028B ; 000010, 3.576
040CB7 B3 02 00    1099*       dl 0x0002B3 ; 000011, 3.799
040CBA DC 02 00    1100*       dl 0x0002DC ; 000012, 4.022
040CBD 04 03 00    1101*       dl 0x000304 ; 000013, 4.245
040CC0 2D 03 00    1102*       dl 0x00032D ; 000014, 4.467
040CC3 55 03 00    1103*       dl 0x000355 ; 000015, 4.690
040CC6 7E 03 00    1104*       dl 0x00037E ; 000016, 4.912
040CC9 A6 03 00    1105*       dl 0x0003A6 ; 000017, 5.134
040CCC CE 03 00    1106*       dl 0x0003CE ; 000018, 5.356
040CCF F7 03 00    1107*       dl 0x0003F7 ; 000019, 5.578
040CD2 1F 04 00    1108*       dl 0x00041F ; 00001A, 5.799
040CD5 48 04 00    1109*       dl 0x000448 ; 00001B, 6.021
040CD8 70 04 00    1110*       dl 0x000470 ; 00001C, 6.242
040CDB 98 04 00    1111*       dl 0x000498 ; 00001D, 6.463
040CDE C0 04 00    1112*       dl 0x0004C0 ; 00001E, 6.684
040CE1 E8 04 00    1113*       dl 0x0004E8 ; 00001F, 6.905
040CE4 11 05 00    1114*       dl 0x000511 ; 000020, 7.125
040CE7 39 05 00    1115*       dl 0x000539 ; 000021, 7.345
040CEA 61 05 00    1116*       dl 0x000561 ; 000022, 7.565
040CED 89 05 00    1117*       dl 0x000589 ; 000023, 7.785
040CF0 B1 05 00    1118*       dl 0x0005B1 ; 000024, 8.005
040CF3 D9 05 00    1119*       dl 0x0005D9 ; 000025, 8.224
040CF6 01 06 00    1120*       dl 0x000601 ; 000026, 8.443
040CF9 28 06 00    1121*       dl 0x000628 ; 000027, 8.662
040CFC 50 06 00    1122*       dl 0x000650 ; 000028, 8.881
040CFF 78 06 00    1123*       dl 0x000678 ; 000029, 9.099
040D02 A0 06 00    1124*       dl 0x0006A0 ; 00002A, 9.317
040D05 C7 06 00    1125*       dl 0x0006C7 ; 00002B, 9.535
040D08 EF 06 00    1126*       dl 0x0006EF ; 00002C, 9.752
040D0B 16 07 00    1127*       dl 0x000716 ; 00002D, 9.970
040D0E 3E 07 00    1128*       dl 0x00073E ; 00002E, 10.187
040D11 65 07 00    1129*       dl 0x000765 ; 00002F, 10.403
040D14 8D 07 00    1130*       dl 0x00078D ; 000030, 10.620
040D17 B4 07 00    1131*       dl 0x0007B4 ; 000031, 10.836
040D1A DB 07 00    1132*       dl 0x0007DB ; 000032, 11.051
040D1D 03 08 00    1133*       dl 0x000803 ; 000033, 11.267
040D20 2A 08 00    1134*       dl 0x00082A ; 000034, 11.482
040D23 51 08 00    1135*       dl 0x000851 ; 000035, 11.697
040D26 78 08 00    1136*       dl 0x000878 ; 000036, 11.911
040D29 9F 08 00    1137*       dl 0x00089F ; 000037, 12.125
040D2C C6 08 00    1138*       dl 0x0008C6 ; 000038, 12.339
040D2F ED 08 00    1139*       dl 0x0008ED ; 000039, 12.553
040D32 13 09 00    1140*       dl 0x000913 ; 00003A, 12.766
040D35 3A 09 00    1141*       dl 0x00093A ; 00003B, 12.978
040D38 61 09 00    1142*       dl 0x000961 ; 00003C, 13.191
040D3B 87 09 00    1143*       dl 0x000987 ; 00003D, 13.403
040D3E AE 09 00    1144*       dl 0x0009AE ; 00003E, 13.614
040D41 D4 09 00    1145*       dl 0x0009D4 ; 00003F, 13.825
040D44 FB 09 00    1146*       dl 0x0009FB ; 000040, 14.036
040D47 21 0A 00    1147*       dl 0x000A21 ; 000041, 14.247
040D4A 47 0A 00    1148*       dl 0x000A47 ; 000042, 14.457
040D4D 6D 0A 00    1149*       dl 0x000A6D ; 000043, 14.666
040D50 94 0A 00    1150*       dl 0x000A94 ; 000044, 14.876
040D53 BA 0A 00    1151*       dl 0x000ABA ; 000045, 15.085
040D56 E0 0A 00    1152*       dl 0x000AE0 ; 000046, 15.293
040D59 05 0B 00    1153*       dl 0x000B05 ; 000047, 15.501
040D5C 2B 0B 00    1154*       dl 0x000B2B ; 000048, 15.709
040D5F 51 0B 00    1155*       dl 0x000B51 ; 000049, 15.916
040D62 77 0B 00    1156*       dl 0x000B77 ; 00004A, 16.123
040D65 9C 0B 00    1157*       dl 0x000B9C ; 00004B, 16.329
040D68 C2 0B 00    1158*       dl 0x000BC2 ; 00004C, 16.535
040D6B E7 0B 00    1159*       dl 0x000BE7 ; 00004D, 16.740
040D6E 0C 0C 00    1160*       dl 0x000C0C ; 00004E, 16.945
040D71 32 0C 00    1161*       dl 0x000C32 ; 00004F, 17.150
040D74 57 0C 00    1162*       dl 0x000C57 ; 000050, 17.354
040D77 7C 0C 00    1163*       dl 0x000C7C ; 000051, 17.558
040D7A A1 0C 00    1164*       dl 0x000CA1 ; 000052, 17.761
040D7D C6 0C 00    1165*       dl 0x000CC6 ; 000053, 17.964
040D80 EB 0C 00    1166*       dl 0x000CEB ; 000054, 18.166
040D83 0F 0D 00    1167*       dl 0x000D0F ; 000055, 18.368
040D86 34 0D 00    1168*       dl 0x000D34 ; 000056, 18.569
040D89 58 0D 00    1169*       dl 0x000D58 ; 000057, 18.770
040D8C 7D 0D 00    1170*       dl 0x000D7D ; 000058, 18.970
040D8F A1 0D 00    1171*       dl 0x000DA1 ; 000059, 19.170
040D92 C6 0D 00    1172*       dl 0x000DC6 ; 00005A, 19.370
040D95 EA 0D 00    1173*       dl 0x000DEA ; 00005B, 19.569
040D98 0E 0E 00    1174*       dl 0x000E0E ; 00005C, 19.767
040D9B 32 0E 00    1175*       dl 0x000E32 ; 00005D, 19.965
040D9E 56 0E 00    1176*       dl 0x000E56 ; 00005E, 20.163
040DA1 7A 0E 00    1177*       dl 0x000E7A ; 00005F, 20.360
040DA4 9E 0E 00    1178*       dl 0x000E9E ; 000060, 20.556
040DA7 C1 0E 00    1179*       dl 0x000EC1 ; 000061, 20.752
040DAA E5 0E 00    1180*       dl 0x000EE5 ; 000062, 20.947
040DAD 08 0F 00    1181*       dl 0x000F08 ; 000063, 21.142
040DB0 2C 0F 00    1182*       dl 0x000F2C ; 000064, 21.337
040DB3 4F 0F 00    1183*       dl 0x000F4F ; 000065, 21.531
040DB6 72 0F 00    1184*       dl 0x000F72 ; 000066, 21.724
040DB9 95 0F 00    1185*       dl 0x000F95 ; 000067, 21.917
040DBC B8 0F 00    1186*       dl 0x000FB8 ; 000068, 22.109
040DBF DB 0F 00    1187*       dl 0x000FDB ; 000069, 22.301
040DC2 FE 0F 00    1188*       dl 0x000FFE ; 00006A, 22.493
040DC5 21 10 00    1189*       dl 0x001021 ; 00006B, 22.683
040DC8 44 10 00    1190*       dl 0x001044 ; 00006C, 22.874
040DCB 66 10 00    1191*       dl 0x001066 ; 00006D, 23.063
040DCE 89 10 00    1192*       dl 0x001089 ; 00006E, 23.253
040DD1 AB 10 00    1193*       dl 0x0010AB ; 00006F, 23.441
040DD4 CD 10 00    1194*       dl 0x0010CD ; 000070, 23.629
040DD7 EF 10 00    1195*       dl 0x0010EF ; 000071, 23.817
040DDA 11 11 00    1196*       dl 0x001111 ; 000072, 24.004
040DDD 33 11 00    1197*       dl 0x001133 ; 000073, 24.191
040DE0 55 11 00    1198*       dl 0x001155 ; 000074, 24.376
040DE3 77 11 00    1199*       dl 0x001177 ; 000075, 24.562
040DE6 99 11 00    1200*       dl 0x001199 ; 000076, 24.747
040DE9 BA 11 00    1201*       dl 0x0011BA ; 000077, 24.931
040DEC DC 11 00    1202*       dl 0x0011DC ; 000078, 25.115
040DEF FD 11 00    1203*       dl 0x0011FD ; 000079, 25.298
040DF2 1E 12 00    1204*       dl 0x00121E ; 00007A, 25.481
040DF5 3F 12 00    1205*       dl 0x00123F ; 00007B, 25.663
040DF8 60 12 00    1206*       dl 0x001260 ; 00007C, 25.844
040DFB 81 12 00    1207*       dl 0x001281 ; 00007D, 26.025
040DFE A2 12 00    1208*       dl 0x0012A2 ; 00007E, 26.206
040E01 C3 12 00    1209*       dl 0x0012C3 ; 00007F, 26.386
040E04 E4 12 00    1210*       dl 0x0012E4 ; 000080, 26.565
040E07 04 13 00    1211*       dl 0x001304 ; 000081, 26.744
040E0A 25 13 00    1212*       dl 0x001325 ; 000082, 26.922
040E0D 45 13 00    1213*       dl 0x001345 ; 000083, 27.100
040E10 65 13 00    1214*       dl 0x001365 ; 000084, 27.277
040E13 85 13 00    1215*       dl 0x001385 ; 000085, 27.453
040E16 A5 13 00    1216*       dl 0x0013A5 ; 000086, 27.629
040E19 C5 13 00    1217*       dl 0x0013C5 ; 000087, 27.805
040E1C E5 13 00    1218*       dl 0x0013E5 ; 000088, 27.979
040E1F 05 14 00    1219*       dl 0x001405 ; 000089, 28.154
040E22 24 14 00    1220*       dl 0x001424 ; 00008A, 28.327
040E25 44 14 00    1221*       dl 0x001444 ; 00008B, 28.501
040E28 63 14 00    1222*       dl 0x001463 ; 00008C, 28.673
040E2B 83 14 00    1223*       dl 0x001483 ; 00008D, 28.845
040E2E A2 14 00    1224*       dl 0x0014A2 ; 00008E, 29.017
040E31 C1 14 00    1225*       dl 0x0014C1 ; 00008F, 29.187
040E34 E0 14 00    1226*       dl 0x0014E0 ; 000090, 29.358
040E37 FF 14 00    1227*       dl 0x0014FF ; 000091, 29.527
040E3A 1E 15 00    1228*       dl 0x00151E ; 000092, 29.697
040E3D 3C 15 00    1229*       dl 0x00153C ; 000093, 29.865
040E40 5B 15 00    1230*       dl 0x00155B ; 000094, 30.033
040E43 79 15 00    1231*       dl 0x001579 ; 000095, 30.201
040E46 98 15 00    1232*       dl 0x001598 ; 000096, 30.368
040E49 B6 15 00    1233*       dl 0x0015B6 ; 000097, 30.534
040E4C D4 15 00    1234*       dl 0x0015D4 ; 000098, 30.700
040E4F F2 15 00    1235*       dl 0x0015F2 ; 000099, 30.865
040E52 10 16 00    1236*       dl 0x001610 ; 00009A, 31.030
040E55 2E 16 00    1237*       dl 0x00162E ; 00009B, 31.194
040E58 4C 16 00    1238*       dl 0x00164C ; 00009C, 31.357
040E5B 6A 16 00    1239*       dl 0x00166A ; 00009D, 31.520
040E5E 87 16 00    1240*       dl 0x001687 ; 00009E, 31.682
040E61 A5 16 00    1241*       dl 0x0016A5 ; 00009F, 31.844
040E64 C2 16 00    1242*       dl 0x0016C2 ; 0000A0, 32.005
040E67 DF 16 00    1243*       dl 0x0016DF ; 0000A1, 32.166
040E6A FC 16 00    1244*       dl 0x0016FC ; 0000A2, 32.326
040E6D 19 17 00    1245*       dl 0x001719 ; 0000A3, 32.486
040E70 36 17 00    1246*       dl 0x001736 ; 0000A4, 32.645
040E73 53 17 00    1247*       dl 0x001753 ; 0000A5, 32.803
040E76 70 17 00    1248*       dl 0x001770 ; 0000A6, 32.961
040E79 8C 17 00    1249*       dl 0x00178C ; 0000A7, 33.118
040E7C A9 17 00    1250*       dl 0x0017A9 ; 0000A8, 33.275
040E7F C5 17 00    1251*       dl 0x0017C5 ; 0000A9, 33.431
040E82 E2 17 00    1252*       dl 0x0017E2 ; 0000AA, 33.587
040E85 FE 17 00    1253*       dl 0x0017FE ; 0000AB, 33.742
040E88 1A 18 00    1254*       dl 0x00181A ; 0000AC, 33.896
040E8B 36 18 00    1255*       dl 0x001836 ; 0000AD, 34.050
040E8E 52 18 00    1256*       dl 0x001852 ; 0000AE, 34.203
040E91 6E 18 00    1257*       dl 0x00186E ; 0000AF, 34.356
040E94 8A 18 00    1258*       dl 0x00188A ; 0000B0, 34.509
040E97 A5 18 00    1259*       dl 0x0018A5 ; 0000B1, 34.660
040E9A C1 18 00    1260*       dl 0x0018C1 ; 0000B2, 34.811
040E9D DC 18 00    1261*       dl 0x0018DC ; 0000B3, 34.962
040EA0 F7 18 00    1262*       dl 0x0018F7 ; 0000B4, 35.112
040EA3 13 19 00    1263*       dl 0x001913 ; 0000B5, 35.262
040EA6 2E 19 00    1264*       dl 0x00192E ; 0000B6, 35.410
040EA9 49 19 00    1265*       dl 0x001949 ; 0000B7, 35.559
040EAC 64 19 00    1266*       dl 0x001964 ; 0000B8, 35.707
040EAF 7F 19 00    1267*       dl 0x00197F ; 0000B9, 35.854
040EB2 99 19 00    1268*       dl 0x001999 ; 0000BA, 36.001
040EB5 B4 19 00    1269*       dl 0x0019B4 ; 0000BB, 36.147
040EB8 CE 19 00    1270*       dl 0x0019CE ; 0000BC, 36.293
040EBB E9 19 00    1271*       dl 0x0019E9 ; 0000BD, 36.438
040EBE 03 1A 00    1272*       dl 0x001A03 ; 0000BE, 36.582
040EC1 1D 1A 00    1273*       dl 0x001A1D ; 0000BF, 36.726
040EC4 37 1A 00    1274*       dl 0x001A37 ; 0000C0, 36.870
040EC7 51 1A 00    1275*       dl 0x001A51 ; 0000C1, 37.013
040ECA 6B 1A 00    1276*       dl 0x001A6B ; 0000C2, 37.155
040ECD 85 1A 00    1277*       dl 0x001A85 ; 0000C3, 37.297
040ED0 9F 1A 00    1278*       dl 0x001A9F ; 0000C4, 37.439
040ED3 B9 1A 00    1279*       dl 0x001AB9 ; 0000C5, 37.579
040ED6 D2 1A 00    1280*       dl 0x001AD2 ; 0000C6, 37.720
040ED9 EC 1A 00    1281*       dl 0x001AEC ; 0000C7, 37.859
040EDC 05 1B 00    1282*       dl 0x001B05 ; 0000C8, 37.999
040EDF 1E 1B 00    1283*       dl 0x001B1E ; 0000C9, 38.137
040EE2 37 1B 00    1284*       dl 0x001B37 ; 0000CA, 38.276
040EE5 50 1B 00    1285*       dl 0x001B50 ; 0000CB, 38.413
040EE8 69 1B 00    1286*       dl 0x001B69 ; 0000CC, 38.550
040EEB 82 1B 00    1287*       dl 0x001B82 ; 0000CD, 38.687
040EEE 9B 1B 00    1288*       dl 0x001B9B ; 0000CE, 38.823
040EF1 B4 1B 00    1289*       dl 0x001BB4 ; 0000CF, 38.959
040EF4 CC 1B 00    1290*       dl 0x001BCC ; 0000D0, 39.094
040EF7 E5 1B 00    1291*       dl 0x001BE5 ; 0000D1, 39.228
040EFA FD 1B 00    1292*       dl 0x001BFD ; 0000D2, 39.362
040EFD 16 1C 00    1293*       dl 0x001C16 ; 0000D3, 39.496
040F00 2E 1C 00    1294*       dl 0x001C2E ; 0000D4, 39.629
040F03 46 1C 00    1295*       dl 0x001C46 ; 0000D5, 39.762
040F06 5E 1C 00    1296*       dl 0x001C5E ; 0000D6, 39.894
040F09 76 1C 00    1297*       dl 0x001C76 ; 0000D7, 40.025
040F0C 8E 1C 00    1298*       dl 0x001C8E ; 0000D8, 40.156
040F0F A5 1C 00    1299*       dl 0x001CA5 ; 0000D9, 40.286
040F12 BD 1C 00    1300*       dl 0x001CBD ; 0000DA, 40.416
040F15 D5 1C 00    1301*       dl 0x001CD5 ; 0000DB, 40.546
040F18 EC 1C 00    1302*       dl 0x001CEC ; 0000DC, 40.675
040F1B 04 1D 00    1303*       dl 0x001D04 ; 0000DD, 40.803
040F1E 1B 1D 00    1304*       dl 0x001D1B ; 0000DE, 40.931
040F21 32 1D 00    1305*       dl 0x001D32 ; 0000DF, 41.059
040F24 49 1D 00    1306*       dl 0x001D49 ; 0000E0, 41.186
040F27 60 1D 00    1307*       dl 0x001D60 ; 0000E1, 41.312
040F2A 77 1D 00    1308*       dl 0x001D77 ; 0000E2, 41.438
040F2D 8E 1D 00    1309*       dl 0x001D8E ; 0000E3, 41.564
040F30 A5 1D 00    1310*       dl 0x001DA5 ; 0000E4, 41.689
040F33 BB 1D 00    1311*       dl 0x001DBB ; 0000E5, 41.814
040F36 D2 1D 00    1312*       dl 0x001DD2 ; 0000E6, 41.938
040F39 E9 1D 00    1313*       dl 0x001DE9 ; 0000E7, 42.061
040F3C FF 1D 00    1314*       dl 0x001DFF ; 0000E8, 42.184
040F3F 15 1E 00    1315*       dl 0x001E15 ; 0000E9, 42.307
040F42 2C 1E 00    1316*       dl 0x001E2C ; 0000EA, 42.429
040F45 42 1E 00    1317*       dl 0x001E42 ; 0000EB, 42.551
040F48 58 1E 00    1318*       dl 0x001E58 ; 0000EC, 42.672
040F4B 6E 1E 00    1319*       dl 0x001E6E ; 0000ED, 42.793
040F4E 84 1E 00    1320*       dl 0x001E84 ; 0000EE, 42.913
040F51 99 1E 00    1321*       dl 0x001E99 ; 0000EF, 43.033
040F54 AF 1E 00    1322*       dl 0x001EAF ; 0000F0, 43.152
040F57 C5 1E 00    1323*       dl 0x001EC5 ; 0000F1, 43.271
040F5A DA 1E 00    1324*       dl 0x001EDA ; 0000F2, 43.390
040F5D F0 1E 00    1325*       dl 0x001EF0 ; 0000F3, 43.508
040F60 05 1F 00    1326*       dl 0x001F05 ; 0000F4, 43.625
040F63 1B 1F 00    1327*       dl 0x001F1B ; 0000F5, 43.742
040F66 30 1F 00    1328*       dl 0x001F30 ; 0000F6, 43.859
040F69 45 1F 00    1329*       dl 0x001F45 ; 0000F7, 43.975
040F6C 5A 1F 00    1330*       dl 0x001F5A ; 0000F8, 44.091
040F6F 6F 1F 00    1331*       dl 0x001F6F ; 0000F9, 44.206
040F72 84 1F 00    1332*       dl 0x001F84 ; 0000FA, 44.321
040F75 99 1F 00    1333*       dl 0x001F99 ; 0000FB, 44.435
040F78 AD 1F 00    1334*       dl 0x001FAD ; 0000FC, 44.549
040F7B C2 1F 00    1335*       dl 0x001FC2 ; 0000FD, 44.662
040F7E D7 1F 00    1336*       dl 0x001FD7 ; 0000FE, 44.775
040F81 EB 1F 00    1337*       dl 0x001FEB ; 0000FF, 44.888
040F84 00 20 00    1338*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
040F87             0033        include "../agon/fpp_ext.inc"
040F87             0001*   ; integer operations
040F87             0002*   iand:	EQU 58	; AND (INTEGER)
040F87             0003*   ibdiv:	EQU 59	; DIV
040F87             0004*   ieor:	EQU 60	; EOR
040F87             0005*   imod:	EQU 61	; MOD
040F87             0006*   ior:	EQU 62	; OR
040F87             0007*   ile:	EQU 63	; <=
040F87             0008*   ine:	EQU 64	; <>
040F87             0009*   ige:	EQU 65	; >=
040F87             0010*   ilt:	EQU 66	; <
040F87             0011*   ieq:	EQU 67	; =
040F87             0012*   imul:	EQU 68	; *
040F87             0013*   iadd:	EQU 69	; +
040F87             0014*   igt:	EQU 70	; >
040F87             0015*   isub:	EQU 71	; -
040F87             0016*   ipow:	EQU 72	; ^
040F87             0017*   idiv:	EQU 73	; /
040F87             0018*   ;
040F87             0019*   ; floating point functions
040F87             0020*   absv:	EQU 16	; ABS
040F87             0021*   acs:	EQU 17	; ACS
040F87             0022*   asn:	EQU 18	; ASN
040F87             0023*   atn:	EQU 19	; ATN
040F87             0024*   cos:	EQU 20	; COS
040F87             0025*   deg:	EQU 21	; DEG
040F87             0026*   exp:	EQU 22	; EXP
040F87             0027*   int_:	EQU 23	; INT
040F87             0028*   ln:	    EQU 24	; LN
040F87             0029*   log:	EQU 25	; LOG
040F87             0030*   notk:	EQU 26	; NOT
040F87             0031*   rad:	EQU 27	; RAD
040F87             0032*   sgn:	EQU 28	; SGN
040F87             0033*   sin:	EQU 29	; SIN
040F87             0034*   sqr:	EQU 30	; SQR
040F87             0035*   tan:	EQU 31	; TAN
040F87             0036*   zero:	EQU 32	; ZERO
040F87             0037*   fone:	EQU 33	; FONE
040F87             0038*   true:	EQU 34	; TRUE
040F87             0039*   pi:	    EQU 35	; PI
040F87             0040*   val:	EQU 36	; VAL
040F87             0041*   str:	EQU 37	; STR$
040F87             0042*   sfix:	EQU 38	; FIX
040F87             0043*   sfloat:	EQU 39	; FLOAT
040F87             0044*   ftest:	EQU 40	; TEST
040F87             0045*   fcomp:	EQU 41	; COMPARE
040F87             0046*   ;
040F87             0047*   ; floating point operations
040F87             0048*   fand:	EQU  0	; AND (FLOATING-POINT)
040F87             0049*   fbdiv:	EQU  1	; DIV
040F87             0050*   feor:	EQU  2	; EOR
040F87             0051*   fmod:	EQU  3	; MOD
040F87             0052*   ffor:	EQU  4	; OR
040F87             0053*   fle:	EQU  5	; <=
040F87             0054*   fne:	EQU  6	; <>
040F87             0055*   fge:	EQU  7	; >=
040F87             0056*   flt:	EQU  8	; <
040F87             0057*   feq:	EQU  9	; =
040F87             0058*   fmul:	EQU 10	; *
040F87             0059*   fadd:	EQU 11	; +
040F87             0060*   fgt:	EQU 12	; >
040F87             0061*   fsub:	EQU 13	; -
040F87             0062*   fpow:	EQU 14	; ^
040F87             0063*   fdiv:	EQU 15	; /
040F87             0064*   
040F87             0065*       MACRO LOAD_FLOAT ARG
040F87             0066*       ld ix,$+11
040F87             0067*       call val_fp ; convert the string to a float
040F87             0068*       jp (ix)
040F87             0069*       asciz ARG
040F87             0070*       ENDMACRO
040F87             0071*   
040F87             0072*   ; --- originally in eval.asm ---
040F87             0073*   ;SWAP - Swap arguments
040F87             0074*   ;Exchanges DE,HL D'E',H'L' and B,C
040F87             0075*   ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
040F87             0076*   ;
040F87 79          0077*   SWAP:			LD      A,C
040F88 48          0078*   			LD      C,B
040F89 47          0079*   			LD      B,A
040F8A EB          0080*   			EX      DE,HL
040F8B D9          0081*   			EXX
040F8C EB          0082*   			EX      DE,HL
040F8D D9          0083*   			EXX
040F8E C9          0084*   			RET
040F8F             0085*   
040F8F             0086*   ; same as VAL_FP in fpp.asm, but preserves any float stored in DED'E'B
040F8F             0087*   val_fp:
040F8F FD E5       0088*       push iy ; preserve
040F91 FD 21 AC 0F 0089*       ld iy,@val
       04          
040F96 CD 50 10 04 0090*       call store_float_iy_alt
040F9A 3E 24       0091*       ld a,val
040F9C CD 00 13 04 0092*       call FPP ; string converted to float in HLH'L'C
040FA0 FD 21 AC 0F 0093*       ld iy,@val
       04          
040FA5 CD 62 10 04 0094*       call fetch_float_iy_alt
040FA9 FD E1       0095*       pop iy ; restore
040FAB C9          0096*       ret
040FAC             0097*   @val: ds 5
040FB1             0098*   
040FB1             0099*   ; same as INT_FP_ in fpp.asm but preserves B, which keeps any float stored in DED'E'B intact
040FB1             0100*   ; af will also return differently from the original
040FB1             0101*   ;INT - Floor function
040FB1             0102*   ;Result is integer numeric.
040FB1             0103*   ;
040FB1             0104*   int_fp_:
       FF FF FF FF 
       FF 
040FB1 C5          0105*       push bc ; preserve b
040FB2 3E 17       0106*       ld a,int_
040FB4 CD 00 13 04 0107*       call FPP
040FB8 F1          0108*       pop af ; restore b to a
040FB9 47          0109*       ld b,a ; restore b
040FBA C9          0110*       RET
040FBB             0111*   
040FBB             0112*   ; convert floating point number to integer and store it in HLU
040FBB             0113*   ; inputs: HLH'L'C = floating point number
040FBB             0114*   ; outputs: HLU = integer part of the number
040FBB             0115*   ; destroys: all except DEU and U'D'E'B, index registers
040FBB             0116*   int2hlu:
040FBB CD B1 0F 04 0117*       call int_fp_
040FBF 7D          0118*       ld a,l
040FC0 F5          0119*       push af
040FC1 D9          0120*       exx
040FC2 E5          0121*       push hl
040FC3 D9          0122*       exx
040FC4 E1          0123*       pop hl
040FC5 F1          0124*       pop af
040FC6             0125*       A_TO_HLU
                       M1 Args: none
040FC6 AF          0001*M1     xor a ; 1 cycle
040FC7 22 D0 0F 04 0002*M1     ld ($+8+1),hl ; 7 cycles
040FCB 32 D2 0F 04 0003*M1     ld ($+4+3),a ; 5 cycles
040FCF 21 00 00 00 0004*M1     ld hl,0x000000 ; 4 cycles
040FD3             0005*M1     ; 17 cycles total
040FD3 C9          0126*       ret
040FD4             0127*   
040FD4             0128*   ; convert the integer value in HLU to a floating point number with exponent of 0
040FD4             0129*   hlu2float:
040FD4 0E 00       0130*       ld c,0 ; exponent = 0
040FD6 E5          0131*       push hl
040FD7 D9          0132*       exx
040FD8 E1          0133*       pop hl
040FD9 D9          0134*       exx
040FDA             0135*       HLU_TO_A
                       M1 Args: none
040FDA 3B          0001*M1     dec sp ; 1 cycle
040FDB E5          0002*M1     push hl ; 4 cycles
040FDC 33          0003*M1     inc sp ; 1 cycle
040FDD F1          0004*M1     pop af ; 4 cycles
040FDE             0005*M1     ; 10 cycles total
040FDE 21 00 00 00 0136*       ld hl,0
040FE2 6F          0137*       ld l,a
040FE3 C9          0138*       ret
040FE4             0139*   
040FE4             0140*   ; store HLH'L'C floating point number in a 40-bit buffer
040FE4             0141*   ; inputs: HLH'L'C = floating point number
040FE4             0142*   ;         ix = buffer address
040FE4             0143*   ; outputs: buffer filled with floating point number
040FE4             0144*   ; destroys: nothing
040FE4             0145*   store_float_nor:
040FE4 DD 71 00    0146*       ld (ix+0),c
040FE7 D9          0147*       exx
040FE8 DD 75 01    0148*       ld (ix+1),l
040FEB DD 74 02    0149*       ld (ix+2),h
040FEE D9          0150*       exx
040FEF DD 75 03    0151*       ld (ix+3),l
040FF2 DD 74 04    0152*       ld (ix+4),h
040FF5 C9          0153*       ret
040FF6             0154*   
040FF6             0155*   ; fetch HLH'L'C floating point number from a 40-bit buffer
040FF6             0156*   ; inputs: ix = buffer address
040FF6             0157*   ; outputs: HLH'L'C = floating point number
040FF6             0158*   ; destroys: HLH'L'C
040FF6             0159*   fetch_float_nor:
040FF6 DD 4E 00    0160*       ld c,(ix+0)
040FF9 D9          0161*       exx
040FFA DD 6E 01    0162*       ld l,(ix+1)
040FFD DD 66 02    0163*       ld h,(ix+2)
041000 D9          0164*       exx
041001 DD 6E 03    0165*       ld l,(ix+3)
041004 DD 66 04    0166*       ld h,(ix+4)
041007 C9          0167*       ret
041008             0168*   
041008             0169*   ; store DED'E'B floating point number in a 40-bit buffer
041008             0170*   ; inputs: DED'E'B = floating point number
041008             0171*   ;         ix = buffer address
041008             0172*   ; outputs: buffer filled with floating point number
041008             0173*   ; destroys: nothing
041008             0174*   store_float_alt:
041008 DD 70 00    0175*       ld (ix+0),b
04100B D9          0176*       exx
04100C DD 73 01    0177*       ld (ix+1),e
04100F DD 72 02    0178*       ld (ix+2),d
041012 D9          0179*       exx
041013 DD 73 03    0180*       ld (ix+3),e
041016 DD 72 04    0181*       ld (ix+4),d
041019 C9          0182*       ret
04101A             0183*   
04101A             0184*   ; fetch DED'E'B floating point number from a 40-bit buffer
04101A             0185*   ; inputs: ix = buffer address
04101A             0186*   ; outputs: DED'E'B = floating point number
04101A             0187*   ; destroys: DED'E'B
04101A             0188*   fetch_float_alt:
04101A DD 46 00    0189*       ld b,(ix+0)
04101D D9          0190*       exx
04101E DD 5E 01    0191*       ld e,(ix+1)
041021 DD 56 02    0192*       ld d,(ix+2)
041024 D9          0193*       exx
041025 DD 5E 03    0194*       ld e,(ix+3)
041028 DD 56 04    0195*       ld d,(ix+4)
04102B C9          0196*       ret
04102C             0197*   
04102C             0198*   
04102C             0199*   ; store HLH'L'C floating point number in a 40-bit buffer
04102C             0200*   ; inputs: HLH'L'C = floating point number
04102C             0201*   ;         iy = buffer address
04102C             0202*   ; outputs: buffer filled with floating point number
04102C             0203*   ; destroys: nothing
04102C             0204*   store_float_iy_nor:
04102C FD 71 00    0205*       ld (iy+0),c
04102F D9          0206*       exx
041030 FD 75 01    0207*       ld (iy+1),l
041033 FD 74 02    0208*       ld (iy+2),h
041036 D9          0209*       exx
041037 FD 75 03    0210*       ld (iy+3),l
04103A FD 74 04    0211*       ld (iy+4),h
04103D C9          0212*       ret
04103E             0213*   
04103E             0214*   ; fetch HLH'L'C floating point number from a 40-bit buffer
04103E             0215*   ; inputs: iy = buffer address
04103E             0216*   ; outputs: HLH'L'C = floating point number
04103E             0217*   ; destroys: HLH'L'C
04103E             0218*   fetch_float_iy_nor:
04103E FD 4E 00    0219*       ld c,(iy+0)
041041 D9          0220*       exx
041042 FD 6E 01    0221*       ld l,(iy+1)
041045 FD 66 02    0222*       ld h,(iy+2)
041048 D9          0223*       exx
041049 FD 6E 03    0224*       ld l,(iy+3)
04104C FD 66 04    0225*       ld h,(iy+4)
04104F C9          0226*       ret
041050             0227*   
041050             0228*   ; store DED'E'B floating point number in a 40-bit buffer
041050             0229*   ; inputs: DED'E'B = floating point number
041050             0230*   ;         iy = buffer address
041050             0231*   ; outputs: buffer filled with floating point number
041050             0232*   ; destroys: nothing
041050             0233*   store_float_iy_alt:
041050 FD 70 00    0234*       ld (iy+0),b
041053 D9          0235*       exx
041054 FD 73 01    0236*       ld (iy+1),e
041057 FD 72 02    0237*       ld (iy+2),d
04105A D9          0238*       exx
04105B FD 73 03    0239*       ld (iy+3),e
04105E FD 72 04    0240*       ld (iy+4),d
041061 C9          0241*       ret
041062             0242*   
041062             0243*   ; fetch DED'E'B floating point number from a 40-bit buffer
041062             0244*   ; inputs: iy = buffer address
041062             0245*   ; outputs: DED'E'B = floating point number
041062             0246*   ; destroys: DED'E'B
041062             0247*   fetch_float_iy_alt:
041062 FD 46 00    0248*       ld b,(iy+0)
041065 D9          0249*       exx
041066 FD 5E 01    0250*       ld e,(iy+1)
041069 FD 56 02    0251*       ld d,(iy+2)
04106C D9          0252*       exx
04106D FD 5E 03    0253*       ld e,(iy+3)
041070 FD 56 04    0254*       ld d,(iy+4)
041073 C9          0255*       ret
041074             0256*   
041074             0257*   ; store HLH'L'C integer number in a 32-bit buffer
041074             0258*   ; inputs: HLH'L'C = integer number
041074             0259*   ;         ix = buffer address
041074             0260*   ; outputs: buffer filled with integer number
041074             0261*   ; destroys: nothing
041074             0262*   store_int_nor:
041074 D9          0263*       exx
041075 DD 75 00    0264*       ld (ix+0),l
041078 DD 74 01    0265*       ld (ix+1),h
04107B D9          0266*       exx
04107C DD 75 02    0267*       ld (ix+2),l
04107F DD 74 03    0268*       ld (ix+3),h
041082 C9          0269*       ret
041083             0270*   
041083             0271*   ; fetch HLH'L'C integer number from a 32-bit buffer
041083             0272*   ; inputs: ix = buffer address
041083             0273*   ; outputs: HLH'L'C = integer number
041083             0274*   ; destroys: HLH'L'C
041083             0275*   fetch_int_nor:
041083 0E 00       0276*       ld c,0 ; set exponent to 0
041085 D9          0277*       exx
041086 DD 6E 00    0278*       ld l,(ix+0)
041089 DD 66 01    0279*       ld h,(ix+1)
04108C D9          0280*       exx
04108D DD 6E 02    0281*       ld l,(ix+2)
041090 DD 66 03    0282*       ld h,(ix+3)
041093 C9          0283*       ret
041094             0284*   
041094             0285*   ; store DED'E'B integer number in a 32-bit buffer
041094             0286*   ; inputs: DED'E'B = integer number
041094             0287*   ;         ix = buffer address
041094             0288*   ; outputs: buffer filled with integer number
041094             0289*   ; destroys: nothing
041094             0290*   store_int_alt:
041094 D9          0291*       exx
041095 DD 73 00    0292*       ld (ix+0),e
041098 DD 72 01    0293*       ld (ix+1),d
04109B D9          0294*       exx
04109C DD 73 02    0295*       ld (ix+2),e
04109F DD 72 03    0296*       ld (ix+3),d
0410A2 C9          0297*       ret
0410A3             0298*   
0410A3             0299*   ; fetch DED'E'B integer number from a 32-bit buffer
0410A3             0300*   ; inputs: ix = buffer address
0410A3             0301*   ; outputs: DED'E'B = integer number
0410A3             0302*   ; destroys: DED'E'B
0410A3             0303*   fetch_int_alt:
0410A3 06 00       0304*       ld b,0 ; set exponent to 0
0410A5 D9          0305*       exx
0410A6 DD 5E 00    0306*       ld e,(ix+0)
0410A9 DD 56 01    0307*       ld d,(ix+1)
0410AC D9          0308*       exx
0410AD DD 5E 02    0309*       ld e,(ix+2)
0410B0 DD 56 03    0310*       ld d,(ix+3)
0410B3 C9          0311*       ret
0410B4             0312*   
0410B4             0313*   ; store HLH'L'C integer number in a 32-bit buffer
0410B4             0314*   ; inputs: HLH'L'C = integer number
0410B4             0315*   ;         iy = buffer address
0410B4             0316*   ; outputs: buffer filled with integer number
0410B4             0317*   ; destroys: nothing
0410B4             0318*   store_int_iy_nor:
0410B4 D9          0319*       exx
0410B5 FD 75 00    0320*       ld (iy+0),l
0410B8 FD 74 01    0321*       ld (iy+1),h
0410BB D9          0322*       exx
0410BC FD 75 02    0323*       ld (iy+2),l
0410BF FD 74 03    0324*       ld (iy+3),h
0410C2 C9          0325*       ret
0410C3             0326*   
0410C3             0327*   ; fetch HLH'L'C integer number from a 32-bit buffer
0410C3             0328*   ; inputs: iy = buffer address
0410C3             0329*   ; outputs: HLH'L'C = integer number
0410C3             0330*   ; destroys: HLH'L'C
0410C3             0331*   fetch_int_iy_nor:
0410C3 0E 00       0332*       ld c,0 ; set exponent to 0
0410C5 D9          0333*       exx
0410C6 FD 6E 00    0334*       ld l,(iy+0)
0410C9 FD 66 01    0335*       ld h,(iy+1)
0410CC D9          0336*       exx
0410CD FD 6E 02    0337*       ld l,(iy+2)
0410D0 FD 66 03    0338*       ld h,(iy+3)
0410D3 C9          0339*       ret
0410D4             0340*   
0410D4             0341*   ; store DED'E'B integer number in a 32-bit buffer
0410D4             0342*   ; inputs: DED'E'B = integer number
0410D4             0343*   ;         iy = buffer address
0410D4             0344*   ; outputs: buffer filled with integer number
0410D4             0345*   ; destroys: nothing
0410D4             0346*   store_int_iy_alt:
0410D4 D9          0347*       exx
0410D5 FD 73 00    0348*       ld (iy+0),e
0410D8 FD 72 01    0349*       ld (iy+1),d
0410DB D9          0350*       exx
0410DC FD 73 02    0351*       ld (iy+2),e
0410DF FD 72 03    0352*       ld (iy+3),d
0410E2 C9          0353*       ret
0410E3             0354*   
0410E3             0355*   ; fetch DED'E'B integer number from a 32-bit buffer
0410E3             0356*   ; inputs: iy = buffer address
0410E3             0357*   ; outputs: DED'E'B = integer number
0410E3             0358*   ; destroys: DED'E'B
0410E3             0359*   fetch_int_iy_alt:
0410E3 06 00       0360*       ld b,0 ; set exponent to 0
0410E5 D9          0361*       exx
0410E6 FD 5E 00    0362*       ld e,(iy+0)
0410E9 FD 56 01    0363*       ld d,(iy+1)
0410EC D9          0364*       exx
0410ED FD 5E 02    0365*       ld e,(iy+2)
0410F0 FD 56 03    0366*       ld d,(iy+3)
0410F3 C9          0367*       ret
0410F4             0368*   
0410F4             0369*   ; print HLH'L'C floating point number in hex format
0410F4             0370*   ; inputs: HLH'L'C = floating point number
0410F4             0371*   print_float_hex_nor:
0410F4             0372*       PUSH_ALL
                       M1 Args: none
0410F4 08          0001*M1     ex af,af'
0410F5 D9          0002*M1     exx
0410F6 F5          0003*M1     push af
0410F7 E5          0004*M1     push hl
0410F8 C5          0005*M1     push bc
0410F9 D5          0006*M1     push de
0410FA             0007*M1 
0410FA 08          0008*M1     ex af,af'
0410FB D9          0009*M1     exx
0410FC F5          0010*M1     push af
0410FD E5          0011*M1     push hl
0410FE C5          0012*M1     push bc
0410FF D5          0013*M1     push de
041100 DD E5       0014*M1     push ix
041102 FD E5       0015*M1     push iy
041104 C5          0373*       push bc ; preserve c
041105 CD 2D 21 04 0374*       call printHex16
041109 3E 2E       0375*       ld a,'.'
04110B 5B D7       0376*       rst.lil 10h
04110D D9          0377*       exx
04110E CD 2D 21 04 0378*       call printHex16
041112 D9          0379*       exx
041113 3E 5E       0380*       ld a,'^'
041115 5B D7       0381*       rst.lil 10h
041117 C1          0382*       pop bc ; restore c
041118 79          0383*       ld a,c
041119 CD 33 21 04 0384*       call printHex8
04111D             0385*       POP_ALL
                       M1 Args: none
04111D FD E1       0001*M1     pop iy
04111F DD E1       0002*M1     pop ix
041121 D1          0003*M1     pop de
041122 C1          0004*M1     pop bc
041123 E1          0005*M1     pop hl
041124 F1          0006*M1     pop af
041125 08          0007*M1     ex af,af'
041126 D9          0008*M1     exx
041127             0009*M1 
041127 D1          0010*M1     pop de
041128 C1          0011*M1     pop bc
041129 E1          0012*M1     pop hl
04112A F1          0013*M1     pop af
04112B 08          0014*M1     ex af,af'
04112C D9          0015*M1     exx
04112D C9          0386*       ret
04112E             0387*   
04112E             0388*   ; print DED'E'B floating point number in hex format
04112E             0389*   ; inputs: DED'E'B = floating point number
04112E             0390*   print_float_hex_alt:
04112E             0391*       PUSH_ALL
                       M1 Args: none
04112E 08          0001*M1     ex af,af'
04112F D9          0002*M1     exx
041130 F5          0003*M1     push af
041131 E5          0004*M1     push hl
041132 C5          0005*M1     push bc
041133 D5          0006*M1     push de
041134             0007*M1 
041134 08          0008*M1     ex af,af'
041135 D9          0009*M1     exx
041136 F5          0010*M1     push af
041137 E5          0011*M1     push hl
041138 C5          0012*M1     push bc
041139 D5          0013*M1     push de
04113A DD E5       0014*M1     push ix
04113C FD E5       0015*M1     push iy
04113E C5          0392*       push bc ; preserve b
04113F EB          0393*       ex de,hl
041140 CD 2D 21 04 0394*       call printHex16
041144 EB          0395*       ex de,hl
041145 3E 2E       0396*       ld a,'.'
041147 5B D7       0397*       rst.lil 10h
041149 D9          0398*       exx
04114A EB          0399*       ex de,hl
04114B CD 2D 21 04 0400*       call printHex16
04114F EB          0401*       ex de,hl
041150 D9          0402*       exx
041151 3E 5E       0403*       ld a,'^'
041153 5B D7       0404*       rst.lil 10h
041155 F1          0405*       pop af ; restore b to a
041156 CD 33 21 04 0406*       call printHex8
04115A             0407*       POP_ALL
                       M1 Args: none
04115A FD E1       0001*M1     pop iy
04115C DD E1       0002*M1     pop ix
04115E D1          0003*M1     pop de
04115F C1          0004*M1     pop bc
041160 E1          0005*M1     pop hl
041161 F1          0006*M1     pop af
041162 08          0007*M1     ex af,af'
041163 D9          0008*M1     exx
041164             0009*M1 
041164 D1          0010*M1     pop de
041165 C1          0011*M1     pop bc
041166 E1          0012*M1     pop hl
041167 F1          0013*M1     pop af
041168 08          0014*M1     ex af,af'
041169 D9          0015*M1     exx
04116A C9          0408*       ret
04116B             0409*   
04116B             0410*   print_floats_hex:
04116B CD F4 10 04 0411*       call print_float_hex_nor
04116F 3E 20       0412*       ld a,' '
041171 5B D7       0413*       rst.lil 10h
041173 CD 2E 11 04 0414*       call print_float_hex_alt
041177 C9          0415*       ret
041178             0416*   
041178             0417*   ; print a floating point number in decimal format
041178             0418*   ; inputs: HL'H'L'C is the number to print
041178             0419*   ; outputs: number printed to screen
041178             0420*   ;          ACCS null-terminated string representation of the number
041178             0421*   ; destroys: everything except ix
041178             0422*   print_float_dec:
041178             0423*   print_float_dec_nor:
041178 DD E5       0424*       push ix             ; preserve
04117A             0425*   
04117A             0426*   ; back up floats in normal and alternate registers
04117A DD 21 BB 11 0427*       ld ix,@float_nor
       04          
04117F CD E4 0F 04 0428*       call store_float_nor
041183 DD 21 C0 11 0429*       ld ix,@float_alt
       04          
041188 CD 08 10 04 0430*       call store_float_alt
04118C             0431*   
04118C             0432*   ; convert the number to a string
04118C 11 00 12 04 0433*       ld de,ACCS          ; point to the string accumulator
041190 DD 21 B8 11 0434*       ld ix,@G9-1         ; get the format code for the number
       04          
041195 CD FF 1A 04 0435*       call STR_FP         ; convert the number to a string
041199 EB          0436*       ex de,hl            ; point to end of the string
04119A 36 00       0437*       ld (hl),0           ; null-terminate the string
04119C 21 00 12 04 0438*       ld hl,ACCS          ; point to the string accumulator
0411A0 CD EC 20 04 0439*       call printString
0411A4             0440*   
0411A4             0441*   ; restore floats in normal and alternate registers
0411A4 DD 21 BB 11 0442*       ld ix,@float_nor
       04          
0411A9 CD F6 0F 04 0443*       call fetch_float_nor
0411AD DD 21 C0 11 0444*       ld ix,@float_alt
       04          
0411B2 CD 1A 10 04 0445*       call fetch_float_alt
0411B6             0446*   
0411B6             0447*   ; cleanup and go home
0411B6 DD E1       0448*       pop ix              ; restore
0411B8 C9          0449*       ret
0411B9 09 00       0450*   @G9:			DW    9
0411BB             0451*   @float_nor: ds 5
0411C0             0452*   @float_alt: ds 5
0411C5             0453*   
0411C5             0454*   print_float_dec_alt:
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
0411C5 CD 87 0F 04 0455*       CALL SWAP
0411C9 CD 78 11 04 0456*       CALL print_float_dec_nor
0411CD CD 87 0F 04 0457*       CALL SWAP
0411D1 C9          0458*       ret
0411D2             0459*   
0411D2             0460*   ;PI - Return PI (3.14159265)
0411D2             0461*   ;Result is floating-point numeric.
0411D2             0462*   ;
0411D2 11 0F 49 00 0463*   pi_alt:			LD      DE,0x490F
0411D6 D9          0464*           		EXX
0411D7 11 A2 DA 00 0465*           		LD      DE,0xDAA2
0411DB D9          0466*           		EXX
0411DC 06 81       0467*           		LD      B,0x81
0411DE AF          0468*           		XOR     A               ;NUMERIC MARKER
0411DF C9          0469*           		RET
0411E0             0470*   
0411E0             0471*   ;PI - Return PI * 2 (6.28318531)
0411E0             0472*   ;Result is floating-point numeric.
0411E0             0473*   ;
0411E0 11 0F 49 00 0474*   pi2_alt:		LD      DE,0x490F
0411E4 D9          0475*           		EXX
0411E5 11 A3 DA 00 0476*           		LD      DE,0xDAA3
0411E9 D9          0477*           		EXX
0411EA 06 82       0478*           		LD      B,0x82
0411EC AF          0479*           		XOR     A               ;NUMERIC MARKER
0411ED C9          0480*           		RET
0411EE             0481*   
0411EE             0482*   			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
041200             0483*   RAM_START:
041200             0484*   ;
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
041200 00 00 00 00 0485*   ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041300             0034        include "../agon/fpp.inc"
041300             0001*   ;
041300             0002*   ; Title:	BBC Basic Interpreter - Z80 version
041300             0003*   ;		Z80 Floating Point Package
041300             0004*   ; Author:	(C) Copyright  R.T.Russell  1986
041300             0005*   ; Modified By:	Dean Belfield
041300             0006*   ; Created:	03/05/2022
041300             0007*   ; Last Updated:	07/06/2023
041300             0008*   ;
041300             0009*   ; Modinfo:
041300             0010*   ; 26/10/1986:	Version 0.0
041300             0011*   ; 14/12/1988:	Vesion 0.1 (Bug Fix)
041300             0012*   ; 12/05/2023:	Modified by Dean Belfield
041300             0013*   ; 07/06/2023:	Modified to run in ADL mode
041300             0014*   
041300             0015*   			; .ASSUME	ADL = 1
041300             0016*   
041300             0017*   			; SEGMENT CODE
041300             0018*   
041300             0019*   			; XDEF	FPP
041300             0020*   			; XDEF	DLOAD5
041300             0021*   			; XDEF	DLOAD5_SPL
041300             0022*   ;
041300             0023*   ;BINARY FLOATING POINT REPRESENTATION:
041300             0024*   ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
041300             0025*   ;    8 BIT EXCESS-128 SIGNED EXPONENT
041300             0026*   ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
041300             0027*   ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
041300             0028*   ;
041300             0029*   ;BINARY INTEGER REPRESENTATION:
041300             0030*   ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
041300             0031*   ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
041300             0032*   ;
041300             0033*   ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
041300             0034*   ;                            EXPONENT - C
041300             0035*   ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
041300             0036*   ;                               EXPONENT - B
041300             0037*   
041300             0038*   ;
041300             0039*   ;Error codes:
041300             0040*   ;
041300             0041*   
041300             0042*   BADOP:			EQU     1               ;Bad operation code
041300             0043*   DIVBY0:			EQU     18              ;Division by zero
041300             0044*   TOOBIG_FP:			EQU     20              ;Too big
041300             0045*   NGROOT:			EQU     21              ;Negative root
041300             0046*   LOGRNG:			EQU     22              ;Log range
041300             0047*   ACLOST:			EQU     23              ;Accuracy lost
041300             0048*   EXPRNG:			EQU     24              ;Exp range
041300             0049*   ;
041300             0050*   ;Call entry and despatch code:
041300             0051*   ;
041300 FD E5       0052*   FPP:			PUSH    IY              ;Save IY
041302 FD 21 00 00 0053*           		LD      IY,0
       00          
041307 FD 39       0054*           		ADD     IY,SP           ;Save SP in IY
041309 CD 19 13 04 0055*           		CALL    OP              ;Perform operation
04130D BF          0056*           		CP      A               ;Good return (Z, NC)
04130E FD E1       0057*   EXIT_FP_:			POP     IY              ;Restore IY
041310 C9          0058*           		RET                     ;Return to caller
041311             0059*   ;
041311             0060*   ;Error exit:
041311             0061*   ;
041311 3E 01       0062*   BAD_FP:			LD      A,BADOP         ;"Bad operation code"
041313 FD F9       0063*   ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
041315 B7          0064*           		OR      A               ;Set NZ
041316 37          0065*           		SCF                     ;Set C
041317 18 F5       0066*           		JR      EXIT_FP_
041319             0067*   ;
041319             0068*   ;Perform operation or function:
041319             0069*   ;
041319             0070*   ; OP:			CP      (RTABLE-DTABLE)/3
041319 FE 2A       0071*   OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
04131B             0072*   
04131B 30 F4       0073*           		JR      NC,BAD_FP
04131D             0074*           		; CP      (FTABLE-DTABLE)/3
04131D FE 10       0075*   				CP      FTABLE-DTABLE/3 ; ditto
04131F 30 08       0076*           		JR      NC,DISPAT_FP
041321 08          0077*           		EX      AF,AF'
041322 78          0078*           		LD      A,B
041323 B1          0079*           		OR      C               ;Both integer?
041324 C4 2C 1E 04 0080*           		CALL    NZ,FLOATA       ;No, so float both
041328 08          0081*           		EX      AF,AF'
041329 E5          0082*   DISPAT_FP:			PUSH    HL
04132A 21 3C 13 04 0083*           		LD      HL,DTABLE
04132E C5          0084*           		PUSH    BC
04132F 01 03 00 00 0085*   			LD	BC, 3		; C = 3
041333 47          0086*   			LD	B, A 		; B = op-code
041334 ED 4C       0087*   			MLT 	BC 		;BC = op-code * 3
041336 09          0088*   			ADD	HL, BC 		;Add to table base
041337 ED 27       0089*   			LD	HL, (HL)	;Get the routine address (24-bit)
041339             0090*   
041339             0091*   ;        		ADD     A, A            ;A = op-code * 2
041339             0092*   ;        		LD      C,A
041339             0093*   ;        		LD      B,0             ;BC = op-code * 2
041339             0094*   ;        		ADD     HL,BC
041339             0095*   ;        		LD      A,(HL)          ;Get low byte
041339             0096*   ;        		INC     HL
041339             0097*   ;        		LD      H,(HL)          ;Get high byte
041339             0098*   ;        		LD      L,A
041339             0099*   
041339 C1          0100*           		POP     BC
04133A E3          0101*           		EX      (SP),HL
04133B C9          0102*           		RET                     ;Off to routine
04133C             0103*   ;
04133C             0104*   ;Despatch table:
04133C             0105*   ;
04133C EE 13 04    0106*   DTABLE:			DW24  IAND            ;AND (INTEGER)
04133F 5C 14 04    0107*           		DW24  IBDIV           ;DIV
041342 01 14 04    0108*           		DW24  IEOR            ;EOR
041345 27 14 04    0109*           		DW24  IMOD            ;MOD
041348 14 14 04    0110*           		DW24  IOR             ;OR
04134B E2 16 04    0111*           		DW24  ILE             ;<=
04134E F1 16 04    0112*           		DW24  INE             ;<>
041351 D5 16 04    0113*           		DW24  IGE             ;>=
041354 BA 16 04    0114*           		DW24  ILT             ;<
041357 FE 16 04    0115*           		DW24  IEQ             ;=
04135A 4A 15 04    0116*           		DW24  IMUL            ;*
04135D 85 14 04    0117*           		DW24  IADD            ;+
041360 C7 16 04    0118*           		DW24  IGT             ;>
041363 6C 14 04    0119*           		DW24  ISUB            ;-
041366 01 16 04    0120*           		DW24  IPOW            ;^
041369 F7 14 04    0121*           		DW24  IDIV            ;/
04136C             0122*   ;
04136C             0123*   FTABLE:
04136C 10 17 04    0124*   				DW24  ABSV_FP            ;ABS
04136F F6 1A 04    0125*           		DW24  ACS_FP             ;ACS
041372 34 1A 04    0126*           		DW24  ASN_FP             ;ASN
041375 64 1A 04    0127*           		DW24  ATN_FP             ;ATN
041378 2F 18 04    0128*           		DW24  COS_FP             ;COS
04137B 3E 17 04    0129*           		DW24  DEG_FP             ;DEG
04137E EB 18 04    0130*           		DW24  EXP_FP             ;EXP
041381 92 17 04    0131*           		DW24  INT_FP_            ;INT
041384 89 19 04    0132*           		DW24  LN_FP              ;LN
041387 1E 1A 04    0133*           		DW24  LOG_FP             ;LOG
04138A 1C 17 04    0134*           		DW24  NOTK_FP            ;NOT
04138D 48 17 04    0135*           		DW24  RAD_FP             ;RAD
041390 63 17 04    0136*           		DW24  SGN_FP             ;SGN
041393 3C 18 04    0137*           		DW24  SIN_FP             ;SIN
041396 AB 17 04    0138*           		DW24  SQR_FP             ;SQR
041399 09 18 04    0139*           		DW24  TAN_FP             ;TAN
04139C             0140*   ;
04139C B9 1E 04    0141*   		        DW24  ZERO_FP            ;ZERO
04139F C4 18 04    0142*           		DW24  FONE_FP            ;FONE
0413A2 03 17 04    0143*           		DW24  TRUE_FP            ;TRUE
0413A5 30 17 04    0144*           		DW24  PI_FP              ;PI
0413A8             0145*   ;
0413A8 77 17 04    0146*   		        DW24  VAL_FP             ;VAL
0413AB FF 1A 04    0147*           		DW24  STR_FP             ;STR$
0413AE             0148*   ;
0413AE 60 1D 04    0149*           		DW24  SFIX_FP            ;FIX
0413B1 3C 1E 04    0150*           		DW24  SFLOAT_FP          ;FLOAT
0413B4             0151*   ;
0413B4 8A 1E 04    0152*   		        DW24  FTEST_FP           ;TEST
0413B7 9C 1E 04    0153*           		DW24  FCOMP_FP           ;COMPARE
0413BA             0154*   ;
0413BA EA 13 04    0155*   RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0413BD 58 14 04    0156*           		DW24  FBDIV           ;DIV
0413C0 FD 13 04    0157*           		DW24  FEOR            ;EOR
0413C3 23 14 04    0158*           		DW24  FMOD            ;MOD
0413C6 10 14 04    0159*           		DW24  FFOR             ;OR
0413C9 DC 16 04    0160*           		DW24  FLE             ;<=
0413CC EB 16 04    0161*           		DW24  FNE             ;<>
0413CF CF 16 04    0162*           		DW24  FGE             ;>=
0413D2 B4 16 04    0163*           		DW24  FLT             ;<
0413D5 F8 16 04    0164*           		DW24  FEQ             ;=
0413D8 A4 15 04    0165*           		DW24  FMUL            ;*
0413DB 92 14 04    0166*           		DW24  FADD            ;+
0413DE C1 16 04    0167*           		DW24  FGT             ;>
0413E1 79 14 04    0168*           		DW24  FSUB            ;-
0413E4 81 16 04    0169*           		DW24  FPOW            ;^
0413E7 FB 14 04    0170*           		DW24  FDIV            ;/
0413EA             0171*   ;
0413EA             0172*   ;       PAGE
0413EA             0173*   ;
0413EA             0174*   ;ARITHMETIC AND LOGICAL OPERATORS:
0413EA             0175*   ;All take two arguments, in HLH'L'C & DED'E'B.
0413EA             0176*   ;Output in HLH'L'C
0413EA             0177*   ;All registers except IX, IY destroyed.
0413EA             0178*   ; (N.B. FPOW destroys IX).
0413EA             0179*   ;
0413EA             0180*   ;FAND - Floating-point AND.
0413EA             0181*   ;IAND - Integer AND.
0413EA             0182*   ;
0413EA CD 54 1D 04 0183*   FAND:			CALL    FIX2
0413EE 7C          0184*   IAND:			LD      A,H
0413EF A2          0185*           		AND     D
0413F0 67          0186*           		LD      H,A
0413F1 7D          0187*           		LD      A,L
0413F2 A3          0188*           		AND     E
0413F3 6F          0189*           		LD      L,A
0413F4 D9          0190*           		EXX
0413F5 7C          0191*           		LD      A,H
0413F6 A2          0192*           		AND     D
0413F7 67          0193*           		LD      H,A
0413F8 7D          0194*           		LD      A,L
0413F9 A3          0195*           		AND     E
0413FA 6F          0196*           		LD      L,A
0413FB D9          0197*           		EXX
0413FC C9          0198*           		RET
0413FD             0199*   ;
0413FD             0200*   ;FEOR - Floating-point exclusive-OR.
0413FD             0201*   ;IEOR - Integer exclusive-OR.
0413FD             0202*   ;
0413FD CD 54 1D 04 0203*   FEOR:			CALL    FIX2
041401 7C          0204*   IEOR:			LD      A,H
041402 AA          0205*           		XOR     D
041403 67          0206*           		LD      H,A
041404 7D          0207*           		LD      A,L
041405 AB          0208*           		XOR     E
041406 6F          0209*           		LD      L,A
041407 D9          0210*           		EXX
041408 7C          0211*           		LD      A,H
041409 AA          0212*           		XOR     D
04140A 67          0213*           		LD      H,A
04140B 7D          0214*           		LD      A,L
04140C AB          0215*           		XOR     E
04140D 6F          0216*           		LD      L,A
04140E D9          0217*           		EXX
04140F C9          0218*           		RET
041410             0219*   ;
041410             0220*   ;FOR - Floating-point OR.
041410             0221*   ;IOR - Integer OR.
041410             0222*   ;
041410 CD 54 1D 04 0223*   FFOR:			CALL    FIX2
041414 7C          0224*   IOR:			LD      A,H
041415 B2          0225*           		OR      D
041416 67          0226*           		LD      H,A
041417 7D          0227*           		LD      A,L
041418 B3          0228*           		OR      E
041419 6F          0229*           		LD      L,A
04141A D9          0230*           		EXX
04141B 7C          0231*           		LD      A,H
04141C B2          0232*           		OR      D
04141D 67          0233*           		LD      H,A
04141E 7D          0234*           		LD      A,L
04141F B3          0235*           		OR      E
041420 6F          0236*           		LD      L,A
041421 D9          0237*           		EXX
041422 C9          0238*           		RET
041423             0239*   ;
041423             0240*   ;FMOD - Floating-point remainder.
041423             0241*   ;IMOD - Integer remainder.
041423             0242*   ;
041423 CD 54 1D 04 0243*   FMOD:			CALL    FIX2
041427 7C          0244*   IMOD:			LD      A,H
041428 AA          0245*           		XOR     D               ;DIV RESULT SIGN
041429 CB 7C       0246*           		BIT     7,H
04142B 08          0247*           		EX      AF,AF'
04142C CB 7C       0248*           		BIT     7,H
04142E C4 70 1D 04 0249*           		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
041432 CD 6D 1E 04 0250*           		CALL    SWAP_FP
041436 CB 7C       0251*           		BIT     7,H
041438 C4 70 1D 04 0252*           		CALL    NZ,NEGATE
04143C 44          0253*           		LD      B,H
04143D 4D          0254*           		LD      C,L
04143E 21 00 00 00 0255*           		LD      HL,0
041442 D9          0256*           		EXX
041443 44          0257*           		LD      B,H
041444 4D          0258*           		LD      C,L
041445 21 00 00 00 0259*           		LD      HL,0
041449 3E DF       0260*           		LD      A,-33
04144B CD FA 1F 04 0261*           		CALL    DIVA            ;DIVIDE
04144F D9          0262*           		EXX
041450 0E 00       0263*           		LD      C,0             ;INTEGER MARKER
041452 08          0264*           		EX      AF,AF'
041453 C8          0265*           		RET     Z
041454 C3 70 1D 04 0266*           		JP      NEGATE
041458             0267*   ;
041458             0268*   ;BDIV - Integer division.
041458             0269*   ;
041458 CD 54 1D 04 0270*   FBDIV:			CALL    FIX2
04145C CD 27 14 04 0271*   IBDIV:			CALL    IMOD
041460 B7          0272*           		OR      A
041461 CD 6D 1E 04 0273*           		CALL    SWAP_FP
041465 0E 00       0274*           		LD      C,0
041467 F0          0275*           		RET     P
041468 C3 70 1D 04 0276*           		JP      NEGATE
04146C             0277*   ;
04146C             0278*   ;ISUB - Integer subtraction.
04146C             0279*   ;FSUB - Floating point subtraction with rounding.
04146C             0280*   ;
04146C CD 08 1F 04 0281*   ISUB:			CALL    SUB_
041470 E0          0282*           		RET     PO
041471 CD 00 1F 04 0283*           		CALL    ADD_
041475 CD 30 1E 04 0284*           		CALL    FLOAT2
041479 7A          0285*   FSUB:			LD      A,D
04147A EE 80       0286*           		XOR     80H             ;CHANGE SIGN THEN ADD
04147C 57          0287*           		LD      D,A
04147D 18 13       0288*           		JR      FADD
04147F             0289*   ;
04147F             0290*   ;Reverse subtract.
04147F             0291*   ;
04147F 7C          0292*   RSUB:			LD      A,H
041480 EE 80       0293*           		XOR     80H
041482 67          0294*           		LD      H,A
041483 18 0D       0295*           		JR      FADD
041485             0296*   ;
041485             0297*   ;IADD - Integer addition.
041485             0298*   ;FADD - Floating point addition with rounding.
041485             0299*   ;
041485 CD 00 1F 04 0300*   IADD:			CALL    ADD_
041489 E0          0301*           		RET     PO
04148A CD 08 1F 04 0302*           		CALL    SUB_
04148E CD 30 1E 04 0303*           		CALL    FLOAT2
041492 05          0304*   FADD:			DEC     B
041493 04          0305*           		INC     B
041494 C8          0306*           		RET     Z               ;ARG 2 ZERO
041495 0D          0307*           		DEC     C
041496 0C          0308*           		INC     C
041497 CA 6D 1E 04 0309*           		JP      Z,SWAP_FP          ;ARG 1 ZERO
04149B D9          0310*           		EXX
04149C 01 00 00 00 0311*           		LD      BC,0            ;INITIALISE
0414A0 D9          0312*           		EXX
0414A1 7C          0313*           		LD      A,H
0414A2 AA          0314*           		XOR     D               ;XOR SIGNS
0414A3 F5          0315*           		PUSH    AF
0414A4 78          0316*           		LD      A,B
0414A5 B9          0317*           		CP      C               ;COMPARE EXPONENTS
0414A6 DC 6D 1E 04 0318*           		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0414AA 78          0319*           		LD      A,B
0414AB CB FC       0320*           		SET     7,H             ;IMPLIED 1
0414AD C4 41 1D 04 0321*           		CALL    NZ,FIX          ;ALIGN
0414B1 F1          0322*           		POP     AF
0414B2 7A          0323*           		LD      A,D             ;SIGN OF LARGER
0414B3 CB FA       0324*           		SET     7,D             ;IMPLIED 1
0414B5 FA C5 14 04 0325*           		JP      M,FADD3         ;SIGNS DIFFERENT
0414B9 CD 00 1F 04 0326*           		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0414BD DC 75 1E 04 0327*           		CALL    C,DIV2          ;NORMALISE
0414C1 CB FC       0328*           		SET     7,H
0414C3 18 0D       0329*           		JR      FADD4
0414C5             0330*   ;
0414C5 CD 08 1F 04 0331*   FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0414C9 DC 88 1D 04 0332*           		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0414CD CD 07 1E 04 0333*           		CALL    FLO48
0414D1 2F          0334*           		CPL                     ;CHANGE RESULT SIGN
0414D2 D9          0335*   FADD4:			EXX
0414D3 EB          0336*           		EX      DE,HL
0414D4 21 00 80 00 0337*           		LD      HL,8000H
0414D8 B7          0338*           		OR      A               ;CLEAR CARRY
0414D9 52 ED 42    0339*           		SBC.S   HL,BC
0414DC EB          0340*           		EX      DE,HL
0414DD D9          0341*           		EXX
0414DE CC 67 1E 04 0342*           		CALL    Z,ODD           ;ROUND UNBIASSED
0414E2 DC 55 1E 04 0343*           		CALL    C,ADD1_FP          ;ROUND UP
0414E6 DC 82 1E 04 0344*           		CALL    C,INCC
0414EA CB BC       0345*           		RES     7,H
0414EC 0D          0346*           		DEC     C
0414ED 0C          0347*           		INC     C
0414EE CA B9 1E 04 0348*           		JP      Z,ZERO_FP
0414F2 B7          0349*           		OR      A               ;RESULT SIGNQ
0414F3 F0          0350*           		RET     P               ;POSITIVE
0414F4 CB FC       0351*           		SET     7,H             ;NEGATIVE
0414F6 C9          0352*           		RET
0414F7             0353*   ;
0414F7             0354*   ;IDIV - Integer division.
0414F7             0355*   ;FDIV - Floating point division with rounding.
0414F7             0356*   ;
0414F7 CD 30 1E 04 0357*   IDIV:			CALL    FLOAT2
0414FB 05          0358*   FDIV:			DEC     B               ;TEST FOR ZERO
0414FC 04          0359*           		INC     B
0414FD 3E 12       0360*           		LD      A,DIVBY0
0414FF CA 13 13 04 0361*           		JP      Z,ERROR_FP_         ;"Division by zero"
041503 0D          0362*           		DEC     C               ;TEST FOR ZERO
041504 0C          0363*           		INC     C
041505 C8          0364*           		RET     Z
041506 7C          0365*           		LD      A,H
041507 AA          0366*           		XOR     D               ;CALC. RESULT SIGN
041508 08          0367*           		EX      AF,AF'          ;SAVE SIGN
041509 CB FA       0368*           		SET     7,D             ;REPLACE IMPLIED 1's
04150B CB FC       0369*           		SET     7,H
04150D C5          0370*           		PUSH    BC              ;SAVE EXPONENTS
04150E 42          0371*           		LD      B,D             ;LOAD REGISTERS
04150F 4B          0372*           		LD      C,E
041510 11 00 00 00 0373*           		LD      DE,0
041514 D9          0374*           		EXX
041515 42          0375*           		LD      B,D
041516 4B          0376*           		LD      C,E
041517 11 00 00 00 0377*           		LD      DE,0
04151B 3E E0       0378*           		LD      A,-32           ;LOOP COUNTER
04151D CD FA 1F 04 0379*           		CALL    DIVA            ;DIVIDE
041521 D9          0380*           		EXX
041522 CB 7A       0381*           		BIT     7,D
041524 D9          0382*           		EXX
041525 CC 19 20 04 0383*           		CALL    Z,DIVB          ;NORMALISE & INC A
041529 EB          0384*           		EX      DE,HL
04152A D9          0385*           		EXX
04152B CB 38       0386*           		SRL     B               ;DIVISOR/2
04152D CB 19       0387*           		RR      C
04152F B7          0388*           		OR      A               ;CLEAR CARRY
041530 52 ED 42    0389*           		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
041533 3F          0390*           		CCF
041534 EB          0391*           		EX      DE,HL           ;RESULT IN HLH'L'
041535 CC 67 1E 04 0392*           		CALL    Z,ODD           ;ROUND UNBIASSED
041539 DC 55 1E 04 0393*           		CALL    C,ADD1_FP          ;ROUND UP
04153D C1          0394*           		POP     BC              ;RESTORE EXPONENTS
04153E DC 82 1E 04 0395*           		CALL    C,INCC
041542 1F          0396*           		RRA                     ;LSB OF A TO CARRY
041543 79          0397*           		LD      A,C             ;COMPUTE NEW EXPONENT
041544 98          0398*           		SBC     A,B
041545 3F          0399*           		CCF
041546 C3 E7 15 04 0400*           		JP      CHKOVF
04154A             0401*   ;
04154A             0402*   ;IMUL - Integer multiplication.
04154A             0403*   ;
04154A 7C          0404*   IMUL:			LD      A,H
04154B AA          0405*           		XOR     D
04154C 08          0406*           		EX      AF,AF'          ;SAVE RESULT SIGN
04154D CB 7C       0407*           		BIT     7,H
04154F C4 70 1D 04 0408*           		CALL    NZ,NEGATE
041553 CD 6D 1E 04 0409*           		CALL    SWAP_FP
041557 CB 7C       0410*           		BIT     7,H
041559 C4 70 1D 04 0411*           		CALL    NZ,NEGATE
04155D 44          0412*           		LD      B,H
04155E 4D          0413*           		LD      C,L
04155F 21 00 00 00 0414*           		LD      HL,0
041563 D9          0415*           		EXX
041564 44          0416*           		LD      B,H
041565 4D          0417*           		LD      C,L
041566 21 00 00 00 0418*           		LD      HL,0
04156A 3E DF       0419*           		LD      A,-33
04156C CD 31 20 04 0420*           		CALL    MULA            ;MULTIPLY
041570 D9          0421*           		EXX
041571 0E BF       0422*           		LD      C,191           ;PRESET EXPONENT
041573 CD 95 1E 04 0423*           		CALL    TEST_FP            ;TEST RANGE
041577 20 0F       0424*           		JR      NZ,IMUL1        ;TOO BIG
041579 CB 7A       0425*           		BIT     7,D
04157B 20 0B       0426*           		JR      NZ,IMUL1
04157D CD 6D 1E 04 0427*           		CALL    SWAP_FP
041581 4A          0428*           		LD      C,D             ;INTEGER MARKER
041582 08          0429*           		EX      AF,AF'
041583 F0          0430*           		RET     P
041584 C3 70 1D 04 0431*           		JP      NEGATE
041588             0432*   ;
041588 0D          0433*   IMUL1:			DEC     C
041589 D9          0434*           		EXX
04158A CB 23       0435*           		SLA     E
04158C CB 12       0436*           		RL      D
04158E D9          0437*           		EXX
04158F CB 13       0438*           		RL      E
041591 CB 12       0439*           		RL      D
041593 D9          0440*           		EXX
041594 52 ED 6A    0441*           		ADC.S   HL,HL
041597 D9          0442*           		EXX
041598 52 ED 6A    0443*           		ADC.S   HL,HL
04159B F2 88 15 04 0444*           		JP      P,IMUL1         ;NORMALISE
04159F 08          0445*           		EX      AF,AF'
0415A0 F8          0446*           		RET     M
0415A1 CB BC       0447*           		RES     7,H             ;POSITIVE
0415A3 C9          0448*           		RET
0415A4             0449*   ;
0415A4             0450*   ;FMUL - Floating point multiplication with rounding.
0415A4             0451*   ;
0415A4 05          0452*   FMUL:			DEC     B               ;TEST FOR ZERO
0415A5 04          0453*           		INC     B
0415A6 CA B9 1E 04 0454*           		JP      Z,ZERO_FP
0415AA 0D          0455*           		DEC     C               ;TEST FOR ZERO
0415AB 0C          0456*           		INC     C
0415AC C8          0457*           		RET     Z
0415AD 7C          0458*           		LD      A,H
0415AE AA          0459*           		XOR     D               ;CALC. RESULT SIGN
0415AF 08          0460*           		EX      AF,AF'
0415B0 CB FA       0461*           		SET     7,D             ;REPLACE IMPLIED 1's
0415B2 CB FC       0462*           		SET     7,H
0415B4 C5          0463*           		PUSH    BC              ;SAVE EXPONENTS
0415B5 44          0464*           		LD      B,H             ;LOAD REGISTERS
0415B6 4D          0465*           		LD      C,L
0415B7 21 00 00 00 0466*           		LD      HL,0
0415BB D9          0467*           		EXX
0415BC 44          0468*           		LD      B,H
0415BD 4D          0469*           		LD      C,L
0415BE 21 00 00 00 0470*           		LD      HL,0
0415C2 3E E0       0471*           		LD      A,-32           ;LOOP COUNTER
0415C4 CD 31 20 04 0472*           		CALL    MULA            ;MULTIPLY
0415C8 DC 47 20 04 0473*           		CALL    C,MULB          ;NORMALISE & INC A
0415CC D9          0474*           		EXX
0415CD E5          0475*           		PUSH    HL
0415CE 21 00 80 00 0476*           		LD      HL,8000H
0415D2 B7          0477*           		OR      A               ;CLEAR CARRY
0415D3 52 ED 52    0478*           		SBC.S   HL,DE
0415D6 E1          0479*           		POP     HL
0415D7 CC 67 1E 04 0480*           		CALL    Z,ODD           ;ROUND UNBIASSED
0415DB DC 55 1E 04 0481*           		CALL    C,ADD1_FP          ;ROUND UP
0415DF C1          0482*           		POP     BC              ;RESTORE EXPONENTS
0415E0 DC 82 1E 04 0483*           		CALL    C,INCC
0415E4 1F          0484*           		RRA                     ;LSB OF A TO CARRY
0415E5 79          0485*           		LD      A,C             ;COMPUTE NEW EXPONENT
0415E6 88          0486*           		ADC     A,B
0415E7 38 06       0487*   CHKOVF:			JR      C,CHKO1
0415E9 F2 B9 1E 04 0488*           		JP      P,ZERO_FP          ;UNDERFLOW
0415ED 18 04       0489*           		JR      CHKO2
0415EF FA 84 1E 04 0490*   CHKO1:			JP      M,OFLOW         ;OVERFLOW
0415F3 C6 80       0491*   CHKO2:			ADD     A,80H
0415F5 4F          0492*           		LD      C,A
0415F6 CA B9 1E 04 0493*           		JP      Z,ZERO_FP
0415FA 08          0494*           		EX      AF,AF'          ;RESTORE SIGN BIT
0415FB CB BC       0495*           		RES     7,H
0415FD F0          0496*           		RET     P
0415FE CB FC       0497*           		SET     7,H
041600 C9          0498*           		RET
041601             0499*   ;
041601             0500*   ;IPOW - Integer involution.
041601             0501*   ;
041601 CD 6D 1E 04 0502*   IPOW:			CALL    SWAP_FP
041605 CB 7C       0503*           		BIT     7,H
041607 F5          0504*           		PUSH    AF              ;SAVE SIGN
041608 C4 70 1D 04 0505*           		CALL    NZ,NEGATE
04160C 48          0506*   IPOW0:			LD      C,B
04160D 06 20       0507*           		LD      B,32            ;LOOP COUNTER
04160F CD 25 1F 04 0508*   IPOW1:			CALL    X2
041613 38 08       0509*           		JR      C,IPOW2
041615 10 F8       0510*           		DJNZ    IPOW1
041617 F1          0511*           		POP     AF
041618 D9          0512*           		EXX
041619 2C          0513*           		INC     L               ;RESULT=1
04161A D9          0514*           		EXX
04161B 4C          0515*           		LD      C,H
04161C C9          0516*           		RET
04161D             0517*   ;
04161D F1          0518*   IPOW2:			POP     AF
04161E C5          0519*           		PUSH    BC
04161F EB          0520*           		EX      DE,HL
041620 E5          0521*           		PUSH    HL
041621 D9          0522*           		EXX
041622 EB          0523*           		EX      DE,HL
041623 E5          0524*           		PUSH    HL
041624 D9          0525*           		EXX
041625 DD 21 00 00 0526*           		LD      IX,0
       00          
04162A DD 39       0527*           		ADD     IX,SP
04162C 28 48       0528*           		JR      Z,IPOW4
04162E C5          0529*           		PUSH    BC
04162F D9          0530*           		EXX
041630 D5          0531*           		PUSH    DE
041631 D9          0532*           		EXX
041632 D5          0533*           		PUSH    DE
041633 CD 3C 1E 04 0534*           		CALL    SFLOAT_FP
041637 CD 70 19 04 0535*           		CALL    RECIP
04163B DD 71 04    0536*           		LD      (IX+4),C
04163E D9          0537*           		EXX
04163F DD 75 00    0538*           		LD      (IX+0),L
041642 DD 74 01    0539*           		LD      (IX+1),H
041645 D9          0540*           		EXX
041646 DD 75 02    0541*           		LD      (IX+2),L
041649 DD 74 03    0542*           		LD      (IX+3),H
04164C 18 21       0543*           		JR      IPOW5
04164E             0544*   ;
04164E C5          0545*   IPOW3:			PUSH    BC
04164F D9          0546*           		EXX
041650 CB 23       0547*           		SLA     E
041652 CB 12       0548*           		RL      D
041654 D5          0549*           		PUSH    DE
041655 D9          0550*           		EXX
041656 CB 13       0551*           		RL      E
041658 CB 12       0552*           		RL      D
04165A D5          0553*           		PUSH    DE
04165B 3E 0A       0554*           		LD      A,'*' & 0FH
04165D F5          0555*           		PUSH    AF
04165E CD 39 1F 04 0556*           		CALL    COPY_
041662 CD 19 13 04 0557*           		CALL    OP              ;SQUARE
041666 F1          0558*           		POP     AF
041667 CD 65 1C 04 0559*           		CALL    DLOAD5
04166B DC 19 13 04 0560*           		CALL    C,OP            ;MULTIPLY BY X
04166F D1          0561*   IPOW5:			POP     DE
041670 D9          0562*           		EXX
041671 D1          0563*           		POP     DE
041672 D9          0564*           		EXX
041673 79          0565*           		LD      A,C
041674 C1          0566*           		POP     BC
041675 4F          0567*           		LD      C,A
041676 10 D6       0568*   IPOW4:			DJNZ    IPOW3
041678 F1          0569*           		POP     AF
041679 F1          0570*           		POP     AF
04167A F1          0571*           		POP     AF
04167B C9          0572*           		RET
04167C             0573*   ;
04167C F1          0574*   FPOW0:			POP     AF
04167D F1          0575*           		POP     AF
04167E F1          0576*           		POP     AF
04167F 18 8B       0577*           		JR      IPOW0
041681             0578*   ;
041681             0579*   ;FPOW - Floating-point involution.
041681             0580*   ;
041681 CB 7A       0581*   FPOW:			BIT     7,D
041683 F5          0582*           		PUSH    AF
041684 CD 6D 1E 04 0583*           		CALL    SWAP_FP
041688 CD 49 1F 04 0584*           		CALL    PUSH5
04168C 0D          0585*           		DEC     C
04168D 0C          0586*           		INC     C
04168E 28 EC       0587*           		JR      Z,FPOW0
041690 3E 9E       0588*           		LD      A,158
041692 B9          0589*           		CP      C
041693 38 0A       0590*           		JR      C,FPOW1
041695 3C          0591*           		INC     A
041696 CD 41 1D 04 0592*           		CALL    FIX
04169A 08          0593*           		EX      AF,AF'
04169B F2 7C 16 04 0594*           		JP      P,FPOW0
04169F CD 6D 1E 04 0595*   FPOW1:			CALL    SWAP_FP
0416A3 CD 8D 19 04 0596*           		CALL    LN0
0416A7 CD 52 1F 04 0597*           		CALL    POP5
0416AB F1          0598*           		POP     AF
0416AC CD A4 15 04 0599*           		CALL    FMUL
0416B0 C3 EF 18 04 0600*           		JP      EXP0
0416B4             0601*   ;
0416B4             0602*   ;Integer and floating-point compare.
0416B4             0603*   ;Result is TRUE (-1) or FALSE (0).
0416B4             0604*   ;
0416B4 CD C3 1E 04 0605*   FLT:			CALL    FCP
0416B8 18 04       0606*           		JR      ILT1
0416BA CD B5 1E 04 0607*   ILT:			CALL    ICP
0416BE D0          0608*   ILT1:			RET     NC
0416BF 18 42       0609*           		JR      TRUE_FP
0416C1             0610*   ;
0416C1 CD C3 1E 04 0611*   FGT:			CALL    FCP
0416C5 18 04       0612*           		JR      IGT1
0416C7 CD B5 1E 04 0613*   IGT:			CALL    ICP
0416CB C8          0614*   IGT1:			RET     Z
0416CC D8          0615*           		RET     C
0416CD 18 34       0616*           		JR      TRUE_FP
0416CF             0617*   ;
0416CF CD C3 1E 04 0618*   FGE:			CALL    FCP
0416D3 18 04       0619*           		JR      IGE1
0416D5 CD B5 1E 04 0620*   IGE:			CALL    ICP
0416D9 D8          0621*   IGE1:			RET     C
0416DA 18 27       0622*           		JR      TRUE_FP
0416DC             0623*   ;
0416DC CD C3 1E 04 0624*   FLE:			CALL    FCP
0416E0 18 04       0625*           		JR      ILE1
0416E2 CD B5 1E 04 0626*   ILE:			CALL    ICP
0416E6 28 1B       0627*   ILE1:			JR      Z,TRUE_FP
0416E8 D0          0628*           		RET     NC
0416E9 18 18       0629*           		JR      TRUE_FP
0416EB             0630*   ;
0416EB CD C3 1E 04 0631*   FNE:			CALL    FCP
0416EF 18 04       0632*           		JR      INE1
0416F1 CD B5 1E 04 0633*   INE:			CALL    ICP
0416F5 C8          0634*   INE1:			RET     Z
0416F6 18 0B       0635*           		JR      TRUE_FP
0416F8             0636*   ;
0416F8 CD C3 1E 04 0637*   FEQ:			CALL    FCP
0416FC 18 04       0638*           		JR      IEQ1
0416FE CD B5 1E 04 0639*   IEQ:			CALL    ICP
041702 C0          0640*   IEQ1:			RET     NZ
041703 21 FF FF FF 0641*   TRUE_FP:			LD      HL,-1
041707 D9          0642*           		EXX
041708 21 FF FF FF 0643*           		LD      HL,-1
04170C D9          0644*           		EXX
04170D AF          0645*           		XOR     A
04170E 4F          0646*           		LD      C,A
04170F C9          0647*           		RET
041710             0648*   ;
041710             0649*   ;FUNCTIONS:
041710             0650*   ;
041710             0651*   ;Result returned in HLH'L'C (floating point)
041710             0652*   ;Result returned in HLH'L' (C=0) (integer)
041710             0653*   ;All registers except IY destroyed.
041710             0654*   ;
041710             0655*   ;ABS - Absolute value
041710             0656*   ;Result is numeric, variable type.
041710             0657*   ;
041710 CB 7C       0658*   ABSV_FP:			BIT     7,H
041712 C8          0659*           		RET     Z               ;POSITIVE/ZERO
041713 0D          0660*           		DEC     C
041714 0C          0661*           		INC     C
041715 CA 70 1D 04 0662*           		JP      Z,NEGATE        ;INTEGER
041719 CB BC       0663*           		RES     7,H
04171B C9          0664*           		RET
04171C             0665*   ;
04171C             0666*   ;NOT - Complement integer.
04171C             0667*   ;Result is integer numeric.
04171C             0668*   ;
04171C CD 60 1D 04 0669*   NOTK_FP:			CALL    SFIX_FP
041720 7C          0670*           		LD      A,H
041721 2F          0671*           		CPL
041722 67          0672*           		LD      H,A
041723 7D          0673*           		LD      A,L
041724 2F          0674*           		CPL
041725 6F          0675*           		LD      L,A
041726 D9          0676*           		EXX
041727 7C          0677*           		LD      A,H
041728 2F          0678*           		CPL
041729 67          0679*           		LD      H,A
04172A 7D          0680*           		LD      A,L
04172B 2F          0681*           		CPL
04172C 6F          0682*           		LD      L,A
04172D D9          0683*           		EXX
04172E AF          0684*           		XOR     A               ;NUMERIC MARKER
04172F C9          0685*           		RET
041730             0686*   ;
041730             0687*   ;PI - Return PI (3.141592654)
041730             0688*   ;Result is floating-point numeric.
041730             0689*   ;
041730 21 0F 49 00 0690*   PI_FP:			LD      HL,490FH
041734 D9          0691*           		EXX
041735 21 A2 DA 00 0692*           		LD      HL,0DAA2H
041739 D9          0693*           		EXX
04173A 0E 81       0694*           		LD      C,81H
04173C AF          0695*           		XOR     A               ;NUMERIC MARKER
04173D C9          0696*           		RET
04173E             0697*   ;
04173E             0698*   ;DEG - Convert radians to degrees
04173E             0699*   ;Result is floating-point numeric.
04173E             0700*   ;
04173E CD 52 17 04 0701*   DEG_FP:			CALL    FPI180
041742 CD A4 15 04 0702*           		CALL    FMUL
041746 AF          0703*           		XOR     A
041747 C9          0704*           		RET
041748             0705*   ;
041748             0706*   ;RAD - Convert degrees to radians
041748             0707*   ;Result is floating-point numeric.
041748             0708*   ;
041748 CD 52 17 04 0709*   RAD_FP:			CALL    FPI180
04174C CD FB 14 04 0710*           		CALL    FDIV
041750 AF          0711*           		XOR     A
041751 C9          0712*           		RET
041752             0713*   ;
041752             0714*   ;180/PI
041752             0715*   ;
041752 CD 3C 1E 04 0716*   FPI180:			CALL    SFLOAT_FP
041756 11 2E 65 00 0717*           		LD      DE,652EH
04175A D9          0718*           		EXX
04175B 11 D3 E0 00 0719*           		LD      DE,0E0D3H
04175F D9          0720*           		EXX
041760 06 85       0721*           		LD      B,85H
041762 C9          0722*           		RET
041763             0723*   ;
041763             0724*   ;SGN - Return -1, 0 or +1
041763             0725*   ;Result is integer numeric.
041763             0726*   ;
041763 CD 95 1E 04 0727*   SGN_FP:			CALL    TEST_FP
041767 B1          0728*           		OR      C
041768 C8          0729*           		RET     Z               ;ZERO
041769 CB 7C       0730*           		BIT     7,H
04176B C2 03 17 04 0731*           		JP      NZ,TRUE_FP         ;-1
04176F CD B9 1E 04 0732*           		CALL    ZERO_FP
041773 C3 55 1E 04 0733*           		JP      ADD1_FP            ;1
041777             0734*   ;
041777             0735*   ;VAL - Return numeric value of string.
041777             0736*   ;Input: ASCII string at IX
041777             0737*   ;Result is variable type numeric.
041777             0738*   ;
041777 CD D3 20 04 0739*   VAL_FP:			CALL    SIGNQ
04177B F5          0740*           		PUSH    AF
04177C CD 83 1C 04 0741*           		CALL    CON_FP
041780 F1          0742*           		POP     AF
041781 FE 2D       0743*           		CP      '-'
041783 3E 00       0744*           		LD      A,0             ;NUMERIC MARKER
041785 C0          0745*           		RET     NZ
041786 0D          0746*           		DEC     C
041787 0C          0747*           		INC     C
041788 CA 70 1D 04 0748*           		JP      Z,NEGATE        ;ZERO/INTEGER
04178C 7C          0749*           		LD      A,H
04178D EE 80       0750*           		XOR     80H             ;CHANGE SIGN (FP)
04178F 67          0751*           		LD      H,A
041790 AF          0752*           		XOR     A
041791 C9          0753*           		RET
041792             0754*   ;
041792             0755*   ;INT - Floor function
041792             0756*   ;Result is integer numeric.
041792             0757*   ;
041792 0D          0758*   INT_FP_:			DEC     C
041793 0C          0759*           		INC     C
041794 C8          0760*           		RET     Z               ;ZERO/INTEGER
041795 3E 9F       0761*           		LD      A,159
041797 44          0762*           		LD      B,H             ;B7=SIGN BIT
041798 CD 41 1D 04 0763*           		CALL    FIX
04179C 08          0764*           		EX      AF,AF'
04179D A0          0765*           		AND     B
04179E FC 55 1E 04 0766*           		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
0417A2 78          0767*           		LD      A,B
0417A3 B7          0768*           		OR      A
0417A4 FC 70 1D 04 0769*           		CALL    M,NEGATE
0417A8 AF          0770*           		XOR     A
0417A9 4F          0771*           		LD      C,A
0417AA C9          0772*           		RET
0417AB             0773*   ;
0417AB             0774*   ;SQR - square root
0417AB             0775*   ;Result is floating-point numeric.
0417AB             0776*   ;
0417AB CD 3C 1E 04 0777*   SQR_FP:			CALL    SFLOAT_FP
0417AF CB 7C       0778*   SQR0:			BIT     7,H
0417B1 3E 15       0779*           		LD      A,NGROOT
0417B3 C2 13 13 04 0780*           		JP      NZ,ERROR_FP_        ;"-ve root"
0417B7 0D          0781*           		DEC     C
0417B8 0C          0782*           		INC     C
0417B9 C8          0783*           		RET     Z               ;ZERO
0417BA CB FC       0784*           		SET     7,H             ;IMPLIED 1
0417BC CB 41       0785*           		BIT     0,C
0417BE CC 75 1E 04 0786*           		CALL    Z,DIV2          ;MAKE EXPONENT ODD
0417C2 79          0787*           		LD      A,C
0417C3 D6 80       0788*           		SUB     80H
0417C5 CB 2F       0789*           		SRA     A               ;HALVE EXPONENT
0417C7 C6 80       0790*           		ADD     A,80H
0417C9 4F          0791*           		LD      C,A
0417CA C5          0792*           		PUSH    BC              ;SAVE EXPONENT
0417CB EB          0793*           		EX      DE,HL
0417CC 21 00 00 00 0794*           		LD      HL,0
0417D0 44          0795*           		LD      B,H
0417D1 4D          0796*           		LD      C,L
0417D2 D9          0797*           		EXX
0417D3 EB          0798*           		EX      DE,HL
0417D4 21 00 00 00 0799*           		LD      HL,0
0417D8 44          0800*           		LD      B,H
0417D9 4D          0801*           		LD      C,L
0417DA 3E E1       0802*           		LD      A,-31
0417DC CD 6B 20 04 0803*           		CALL    SQRA            ;ROOT
0417E0 D9          0804*           		EXX
0417E1 CB 78       0805*           		BIT     7,B
0417E3 D9          0806*           		EXX
0417E4 CC 6B 20 04 0807*           		CALL    Z,SQRA          ;NORMALISE & INC A
0417E8 CD AC 20 04 0808*           		CALL    SQRB
0417EC B7          0809*           		OR      A               ;CLEAR CARRY
0417ED CD 19 20 04 0810*           		CALL    DIVB
0417F1 CB 1B       0811*           		RR      E               ;LSB TO CARRY
0417F3 60          0812*           		LD      H,B
0417F4 69          0813*           		LD      L,C
0417F5 D9          0814*           		EXX
0417F6 60          0815*           		LD      H,B
0417F7 69          0816*           		LD      L,C
0417F8 DC 55 1E 04 0817*           		CALL    C,ADD1_FP          ;ROUND UP
0417FC C1          0818*           		POP     BC              ;RESTORE EXPONENT
0417FD DC 82 1E 04 0819*           		CALL    C,INCC
041801 1F          0820*           		RRA
041802 9F          0821*           		SBC     A,A
041803 81          0822*           		ADD     A,C
041804 4F          0823*           		LD      C,A
041805 CB BC       0824*           		RES     7,H             ;POSITIVE
041807 AF          0825*           		XOR     A
041808 C9          0826*           		RET
041809             0827*   ;
041809             0828*   ;TAN - Tangent function
041809             0829*   ;Result is floating-point numeric.
041809             0830*   ;
041809 CD 3C 1E 04 0831*   TAN_FP:			CALL    SFLOAT_FP
04180D CD 49 1F 04 0832*           		CALL    PUSH5
041811 CD 33 18 04 0833*           		CALL    COS0
041815 CD 52 1F 04 0834*           		CALL    POP5
041819 CD 49 1F 04 0835*           		CALL    PUSH5
04181D CD 6D 1E 04 0836*           		CALL    SWAP_FP
041821 CD 40 18 04 0837*           		CALL    SIN0
041825 CD 52 1F 04 0838*           		CALL    POP5
041829 CD FB 14 04 0839*           		CALL    FDIV
04182D AF          0840*           		XOR     A               ;NUMERIC MARKER
04182E C9          0841*           		RET
04182F             0842*   ;
04182F             0843*   ;COS - Cosine function
04182F             0844*   ;Result is floating-point numeric.
04182F             0845*   ;
04182F CD 3C 1E 04 0846*   COS_FP:			CALL    SFLOAT_FP
041833 CD 98 1D 04 0847*   COS0:			CALL    SCALE
041837 1C          0848*           		INC     E
041838 1C          0849*           		INC     E
041839 7B          0850*           		LD      A,E
04183A 18 10       0851*           		JR      SIN1
04183C             0852*   ;
04183C             0853*   ;SIN - Sine function
04183C             0854*   ;Result is floating-point numeric.
04183C             0855*   ;
04183C CD 3C 1E 04 0856*   SIN_FP:			CALL    SFLOAT_FP
041840 E5          0857*   SIN0:			PUSH    HL              ;H7=SIGN
041841 CD 98 1D 04 0858*           		CALL    SCALE
041845 F1          0859*           		POP     AF
041846 07          0860*           		RLCA
041847 07          0861*           		RLCA
041848 07          0862*           		RLCA
041849 E6 04       0863*           		AND     4
04184B AB          0864*           		XOR     E
04184C F5          0865*   SIN1:			PUSH    AF              ;OCTANT
04184D CB BC       0866*           		RES     7,H
04184F 1F          0867*           		RRA
041850 CD DE 18 04 0868*           		CALL    PIBY4
041854 DC 7F 14 04 0869*           		CALL    C,RSUB          ;X=(PI/4)-X
041858 F1          0870*           		POP     AF
041859 F5          0871*           		PUSH    AF
04185A E6 03       0872*           		AND     3
04185C E2 95 18 04 0873*           		JP      PO,SIN2         ;USE COSINE APPROX.
041860 CD 49 1F 04 0874*           		CALL    PUSH5           ;SAVE X
041864 CD 41 1F 04 0875*           		CALL    SQUARE          ;PUSH X*X
041868 CD 86 1F 04 0876*           		CALL    POLY
04186C B7 A8       0877*           		DW	0A8B7H          ;a(8)
04186E 11 36       0878*           		DW	3611H
041870 6D          0879*           		DB	6DH
041871 26 DE       0880*           		DW	0DE26H          ;a(6)
041873 05 D0       0881*           		DW	0D005H
041875 73          0882*           		DB	73H
041876 C0 80       0883*           		DW	80C0H           ;a(4)
041878 88 08       0884*           		DW	888H
04187A 79          0885*           		DB	79H
04187B 9D AA       0886*           		DW	0AA9DH          ;a(2)
04187D AA AA       0887*           		DW	0AAAAH
04187F 7D          0888*           		DB	7DH
041880 00 00       0889*           		DW	0               ;a(0)
041882 00 00       0890*           		DW	0
041884 80          0891*           		DB	80H
041885 CD 52 1F 04 0892*           		CALL    POP5
041889 CD 52 1F 04 0893*           		CALL    POP5
04188D CD A4 15 04 0894*           		CALL    FMUL
041891 C3 BA 18 04 0895*           		JP      SIN3
041895             0896*   ;
041895 CD 41 1F 04 0897*   SIN2:			CALL    SQUARE          ;PUSH X*X
041899 CD 86 1F 04 0898*           		CALL    POLY
04189D 71 D5       0899*           		DW	0D571H          ;b(8)
04189F 78 4C       0900*           		DW	4C78H
0418A1 70          0901*           		DB	70H
0418A2 AF 94       0902*           		DW	94AFH           ;b(6)
0418A4 03 B6       0903*           		DW	0B603H
0418A6 76          0904*           		DB	76H
0418A7 C8 9C       0905*           		DW	9CC8H           ;b(4)
0418A9 AA 2A       0906*           		DW	2AAAH
0418AB 7B          0907*           		DB	7BH
0418AC DD FF       0908*           		DW	0FFDDH          ;b(2)
0418AE FF FF       0909*           		DW	0FFFFH
0418B0 7E          0910*           		DB	7EH
0418B1 00 00       0911*           		DW	0               ;b(0)
0418B3 00 00       0912*           		DW	0
0418B5 80          0913*           		DB	80H
0418B6 CD 52 1F 04 0914*           		CALL    POP5
0418BA F1          0915*   SIN3:			POP     AF
0418BB E6 04       0916*           		AND     4
0418BD C8          0917*           		RET     Z
0418BE 0D          0918*           		DEC     C
0418BF 0C          0919*           		INC     C
0418C0 C8          0920*           		RET     Z               ;ZERO
0418C1 CB FC       0921*           		SET     7,H             ;MAKE NEGATIVE
0418C3 C9          0922*           		RET
0418C4             0923*   ;
0418C4             0924*   ;Floating-point one:
0418C4             0925*   ;
0418C4 21 00 00 00 0926*   FONE_FP:			LD      HL,0
0418C8 D9          0927*           		EXX
0418C9 21 00 00 00 0928*           		LD      HL,0
0418CD D9          0929*           		EXX
0418CE 0E 80       0930*           		LD      C,80H
0418D0 C9          0931*           		RET
0418D1             0932*   ;
0418D1 11 00 00 00 0933*   DONE:			LD      DE,0
0418D5 D9          0934*           		EXX
0418D6 11 00 00 00 0935*           		LD      DE,0
0418DA D9          0936*           		EXX
0418DB 06 80       0937*           		LD      B,80H
0418DD C9          0938*           		RET
0418DE             0939*   ;
0418DE 11 0F 49 00 0940*   PIBY4:			LD      DE,490FH
0418E2 D9          0941*           		EXX
0418E3 11 A2 DA 00 0942*           		LD      DE,0DAA2H
0418E7 D9          0943*           		EXX
0418E8 06 7F       0944*           		LD      B,7FH
0418EA C9          0945*           		RET
0418EB             0946*   ;
0418EB             0947*   ;EXP - Exponential function
0418EB             0948*   ;Result is floating-point numeric.
0418EB             0949*   ;
0418EB CD 3C 1E 04 0950*   EXP_FP:			CALL    SFLOAT_FP
0418EF CD 7C 19 04 0951*   EXP0:			CALL    LN2             ;LN(2)
0418F3 D9          0952*           		EXX
0418F4 1D          0953*   	        	DEC     E
0418F5 01 CF D1 00 0954*   		        LD      BC,0D1CFH       ;0.6931471805599453
0418F9 D9          0955*           		EXX
0418FA E5          0956*           		PUSH    HL              ;H7=SIGN
0418FB CD AB 1D 04 0957*           		CALL    MOD48           ;"MODULUS"
0418FF F1          0958*           		POP     AF
041900 CB 7B       0959*           		BIT     7,E
041902 28 0B       0960*           		JR      Z,EXP1
041904 17          0961*           		RLA
041905 DA B9 1E 04 0962*           		JP      C,ZERO_FP
041909 3E 18       0963*           		LD      A,EXPRNG
04190B C3 13 13 04 0964*           		JP      ERROR_FP_           ;"Exp range"
04190F             0965*   ;
04190F E6 80       0966*   EXP1:			AND     80H
041911 B3          0967*           		OR      E
041912 F5          0968*           		PUSH    AF              ;INTEGER PART
041913 CB BC       0969*           		RES     7,H
041915 CD 49 1F 04 0970*           		CALL    PUSH5           ;PUSH X*LN(2)
041919 CD 86 1F 04 0971*           		CALL    POLY
04191D 72 40       0972*           		DW	4072H           ;a(7)
04191F 2E 94       0973*           		DW	942EH
041921 73          0974*           		DB	73H
041922 65 6F       0975*           		DW	6F65H           ;a(6)
041924 4F 2E       0976*           		DW	2E4FH
041926 76          0977*           		DB	76H
041927 37 6D       0978*           		DW	6D37H           ;a(5)
041929 02 88       0979*           		DW	8802H
04192B 79          0980*           		DB	79H
04192C 12 E5       0981*           		DW	0E512H          ;a(4)
04192E A0 2A       0982*           		DW	2AA0H
041930 7B          0983*           		DB	7BH
041931 14 4F       0984*           		DW	4F14H           ;a(3)
041933 AA AA       0985*           		DW	0AAAAH
041935 7D          0986*           		DB	7DH
041936 56 FD       0987*           		DW	0FD56H          ;a(2)
041938 FF 7F       0988*           		DW	7FFFH
04193A 7E          0989*           		DB	7EH
04193B FE FF       0990*           		DW	0FFFEH          ;a(1)
04193D FF FF       0991*           		DW	0FFFFH
04193F 7F          0992*           		DB	7FH
041940 00 00       0993*           		DW	0               ;a(0)
041942 00 00       0994*           		DW	0
041944 80          0995*           		DB	80H
041945 CD 52 1F 04 0996*           		CALL    POP5
041949 F1          0997*           		POP     AF
04194A F5          0998*           		PUSH    AF
04194B F4 70 19 04 0999*           		CALL    P,RECIP         ;X=1/X
04194F F1          1000*           		POP     AF
041950 F2 58 19 04 1001*           		JP      P,EXP4
041954 E6 7F       1002*           		AND     7FH
041956 ED 44       1003*           		NEG
041958 C6 80       1004*   EXP4:			ADD     A,80H
04195A 81          1005*           		ADD     A,C
04195B 38 06       1006*           		JR      C,EXP2
04195D F2 B9 1E 04 1007*           		JP      P,ZERO_FP          ;UNDERFLOW
041961 18 04       1008*           		JR      EXP3
041963 FA 84 1E 04 1009*   EXP2:			JP      M,OFLOW         ;OVERFLOW
041967 C6 80       1010*   EXP3:			ADD     A,80H
041969 CA B9 1E 04 1011*           		JP      Z,ZERO_FP
04196D 4F          1012*           		LD      C,A
04196E AF          1013*           		XOR     A               ;NUMERIC MARKER
04196F C9          1014*           		RET
041970             1015*   ;
041970 CD D1 18 04 1016*   RECIP:			CALL    DONE
041974 CD 6D 1E 04 1017*   RDIV:			CALL    SWAP_FP
041978 C3 FB 14 04 1018*           		JP      FDIV            ;RECIPROCAL
04197C             1019*   ;
04197C 11 72 31 00 1020*   LN2:			LD      DE,3172H        ;LN(2)
041980 D9          1021*           		EXX
041981 11 F8 17 00 1022*           		LD      DE,17F8H
041985 D9          1023*           		EXX
041986 06 7F       1024*           		LD      B,7FH
041988 C9          1025*           		RET
041989             1026*   ;
041989             1027*   ;LN - Natural log.
041989             1028*   ;Result is floating-point numeric.
041989             1029*   ;
041989 CD 3C 1E 04 1030*   LN_FP:			CALL    SFLOAT_FP
04198D 3E 16       1031*   LN0:			LD      A,LOGRNG
04198F CB 7C       1032*           		BIT     7,H
041991 C2 13 13 04 1033*           		JP      NZ,ERROR_FP_        ;"Log range"
041995 0C          1034*           		INC     C
041996 0D          1035*           		DEC     C
041997 CA 13 13 04 1036*           		JP      Z,ERROR_FP_
04199B 11 04 35 00 1037*           		LD      DE,3504H        ;SQR(2)
04199F D9          1038*           		EXX
0419A0 11 33 F3 00 1039*           		LD      DE,0F333H       ;1.41421356237
0419A4 D9          1040*           		EXX
0419A5 CD CC 1E 04 1041*           		CALL    ICP0            ;MANTISSA>SQR(2)?
0419A9 79          1042*           		LD      A,C             ;EXPONENT
0419AA 0E 80       1043*           		LD      C,80H           ;1 <= X < 2
0419AC 38 02       1044*           		JR      C,LN4
0419AE 0D          1045*           		DEC     C
0419AF 3C          1046*           		INC     A
0419B0 F5          1047*   LN4:			PUSH    AF              ;SAVE EXPONENT
0419B1 CD 5E 1F 04 1048*           		CALL    RATIO           ;X=(X-1)/(X+1)
0419B5 CD 49 1F 04 1049*           		CALL    PUSH5
0419B9 CD 41 1F 04 1050*   		        CALL    SQUARE          ;PUSH X*X
0419BD CD 86 1F 04 1051*           		CALL    POLY
0419C1 48 CC       1052*           		DW	0CC48H          ;a(9)
0419C3 FB 74       1053*           		DW	74FBH
0419C5 7D          1054*           		DB	7DH
0419C6 AF AE       1055*           		DW	0AEAFH          ;a(7)
0419C8 FF 11       1056*           		DW	11FFH
0419CA 7E          1057*           		DB	7EH
0419CB 8C D9       1058*           		DW	0D98CH          ;a(5)
0419CD CD 4C       1059*           		DW	4CCDH
0419CF 7E          1060*           		DB	7EH
0419D0 E3 A9       1061*           		DW	0A9E3H          ;a(3)
0419D2 AA 2A       1062*           		DW	2AAAH
0419D4 7F          1063*           		DB	7FH
0419D5 00 00       1064*           		DW	0               ;a(1)
0419D7 00 00       1065*           		DW	0
0419D9 81          1066*           		DB	81H
0419DA CD 52 1F 04 1067*           		CALL    POP5
0419DE CD 52 1F 04 1068*           		CALL    POP5
0419E2 CD A4 15 04 1069*           		CALL    FMUL
0419E6 F1          1070*           		POP     AF              ;EXPONENT
0419E7 CD 49 1F 04 1071*           		CALL    PUSH5
0419EB 08          1072*           		EX      AF,AF'
0419EC CD B9 1E 04 1073*           		CALL    ZERO_FP
0419F0 08          1074*           		EX      AF,AF'
0419F1 D6 80       1075*           		SUB     80H
0419F3 28 1F       1076*           		JR      Z,LN3
0419F5 30 02       1077*           		JR      NC,LN1
0419F7 2F          1078*           		CPL
0419F8 3C          1079*           		INC     A
0419F9 67          1080*   LN1:			LD      H,A
0419FA 0E 87       1081*           		LD      C,87H
0419FC F5          1082*           		PUSH    AF
0419FD CD 1C 1E 04 1083*           		CALL    FLOAT_
041A01 CB BC       1084*           		RES     7,H
041A03 CD 7C 19 04 1085*           		CALL    LN2
041A07 CD A4 15 04 1086*           		CALL    FMUL
041A0B F1          1087*           		POP     AF
041A0C 30 06       1088*           		JR      NC,LN3
041A0E FA 14 1A 04 1089*           		JP      M,LN3
041A12 CB FC       1090*           		SET     7,H
041A14 CD 52 1F 04 1091*   LN3:			CALL    POP5
041A18 CD 92 14 04 1092*           		CALL    FADD
041A1C AF          1093*           		XOR     A
041A1D C9          1094*           		RET
041A1E             1095*   ;
041A1E             1096*   ;LOG - base-10 logarithm.
041A1E             1097*   ;Result is floating-point numeric.
041A1E             1098*   ;
041A1E CD 89 19 04 1099*   LOG_FP:			CALL    LN_FP
041A22 11 5B 5E 00 1100*           		LD      DE,5E5BH        ;LOG(e)
041A26 D9          1101*           		EXX
041A27 11 A9 D8 00 1102*           		LD      DE,0D8A9H
041A2B D9          1103*           		EXX
041A2C 06 7E       1104*           		LD      B,7EH
041A2E CD A4 15 04 1105*           		CALL    FMUL
041A32 AF          1106*           		XOR     A
041A33 C9          1107*           		RET
041A34             1108*   ;
041A34             1109*   ;ASN - Arc-sine
041A34             1110*   ;Result is floating-point numeric.
041A34             1111*   ;
041A34 CD 3C 1E 04 1112*   ASN_FP:			CALL    SFLOAT_FP
041A38 CD 49 1F 04 1113*           		CALL    PUSH5
041A3C CD 39 1F 04 1114*           		CALL    COPY_
041A40 CD A4 15 04 1115*           		CALL    FMUL
041A44 CD D1 18 04 1116*           		CALL    DONE
041A48 CD 7F 14 04 1117*           		CALL    RSUB
041A4C CD AF 17 04 1118*           		CALL    SQR0
041A50 CD 52 1F 04 1119*           		CALL    POP5
041A54 0C          1120*           		INC     C
041A55 0D          1121*           		DEC     C
041A56 3E 02       1122*           		LD      A,2
041A58 D5          1123*           		PUSH    DE
041A59 CA DE 1A 04 1124*           		JP      Z,ACS1
041A5D D1          1125*           		POP     DE
041A5E CD 74 19 04 1126*           		CALL    RDIV
041A62 18 04       1127*           		JR      ATN0
041A64             1128*   ;
041A64             1129*   ;ATN - arc-tangent
041A64             1130*   ;Result is floating-point numeric.
041A64             1131*   ;
041A64 CD 3C 1E 04 1132*   ATN_FP:			CALL    SFLOAT_FP
041A68 E5          1133*   ATN0:			PUSH    HL              ;SAVE SIGN
041A69 CB BC       1134*           		RES     7,H
041A6B 11 13 54 00 1135*           		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
041A6F D9          1136*           		EXX
041A70 11 D0 CC 00 1137*           		LD      DE,0CCD0H
041A74 D9          1138*           		EXX
041A75 06 7E       1139*           		LD      B,7EH
041A77 CD C9 1E 04 1140*           		CALL    FCP0            ;COMPARE
041A7B 06 00       1141*           		LD      B,0
041A7D 38 22       1142*           		JR      C,ATN2
041A7F 11 82 1A 00 1143*           		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
041A83 D9          1144*           		EXX
041A84 11 9A 79 00 1145*           		LD      DE,799AH
041A88 D9          1146*           		EXX
041A89 06 81       1147*           		LD      B,81H
041A8B CD C9 1E 04 1148*           		CALL    FCP0            ;COMPARE
041A8F 38 0A       1149*           		JR      C,ATN1
041A91 CD 70 19 04 1150*           		CALL    RECIP           ;X=1/X
041A95 06 02       1151*           		LD      B,2
041A97 C3 A1 1A 04 1152*           		JP      ATN2
041A9B CD 5E 1F 04 1153*   ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
041A9F 06 01       1154*           		LD      B,1
041AA1 C5          1155*   ATN2:			PUSH    BC              ;SAVE FLAG
041AA2 CD 49 1F 04 1156*           		CALL    PUSH5
041AA6 CD 41 1F 04 1157*           		CALL    SQUARE          ;PUSH X*X
041AAA CD 86 1F 04 1158*           		CALL    POLY
041AAE 35 F3       1159*           		DW	0F335H          ;a(13)
041AB0 D8 37       1160*           		DW	37D8H
041AB2 7B          1161*           		DB	7BH
041AB3 91 6B       1162*           		DW	6B91H           ;a(11)
041AB5 B9 AA       1163*           		DW	0AAB9H
041AB7 7C          1164*           		DB	7CH
041AB8 DE 41       1165*           		DW	41DEH           ;a(9)
041ABA 97 61       1166*           		DW	6197H
041ABC 7C          1167*           		DB	7CH
041ABD 7B 9D       1168*           		DW	9D7BH           ;a(7)
041ABF 37 92       1169*           		DW	9237H
041AC1 7D          1170*           		DB	7DH
041AC2 5A 2A       1171*           		DW	2A5AH           ;a(5)
041AC4 CC 4C       1172*           		DW	4CCCH
041AC6 7D          1173*           		DB	7DH
041AC7 5C A9       1174*           		DW	0A95CH          ;a(3)
041AC9 AA AA       1175*           		DW	0AAAAH
041ACB 7E          1176*           		DB	7EH
041ACC 00 00       1177*           		DW	0               ;a(1)
041ACE 00 00       1178*           		DW	0
041AD0 80          1179*           		DB	80H
041AD1 CD 52 1F 04 1180*           		CALL    POP5
041AD5 CD 52 1F 04 1181*           		CALL    POP5
041AD9 CD A4 15 04 1182*           		CALL    FMUL
041ADD F1          1183*           		POP     AF
041ADE CD DE 18 04 1184*   ACS1:			CALL    PIBY4           ;PI/4
041AE2 1F          1185*           		RRA
041AE3 F5          1186*           		PUSH    AF
041AE4 DC 92 14 04 1187*           		CALL    C,FADD
041AE8 F1          1188*           		POP     AF
041AE9 04          1189*           		INC     B
041AEA 1F          1190*           		RRA
041AEB DC 7F 14 04 1191*           		CALL    C,RSUB
041AEF F1          1192*           		POP     AF
041AF0 B7          1193*           		OR      A
041AF1 F0          1194*           		RET     P
041AF2 CB FC       1195*           		SET     7,H             ;MAKE NEGATIVE
041AF4 AF          1196*           		XOR     A
041AF5 C9          1197*           		RET
041AF6             1198*   ;
041AF6             1199*   ;ACS - Arc cosine=PI/2-ASN.
041AF6             1200*   ;Result is floating point numeric.
041AF6             1201*   ;
041AF6 CD 34 1A 04 1202*   ACS_FP:			CALL    ASN_FP
041AFA 3E 02       1203*           		LD      A,2
041AFC F5          1204*           		PUSH    AF
041AFD 18 DF       1205*           		JR      ACS1
041AFF             1206*   ;
041AFF             1207*   ;Function STR - convert numeric value to ASCII string.
041AFF             1208*   ;   Inputs: HLH'L'C = integer or floating-point number
041AFF             1209*   ;           DE = address at which to store string
041AFF             1210*   ;           IX = address of @% format control
041AFF             1211*   ;  Outputs: String stored, with NUL terminator
041AFF             1212*   ;
041AFF             1213*   ;First normalise for decimal output:
041AFF             1214*   ;
041AFF CD 3C 1E 04 1215*   STR_FP:			CALL    SFLOAT_FP
041B03 06 00       1216*           		LD      B,0             ;DEFAULT PT. POSITION
041B05 CB 7C       1217*           		BIT     7,H             ;NEGATIVE?
041B07 28 06       1218*           		JR      Z,STR10
041B09 CB BC       1219*           		RES     7,H
041B0B 3E 2D       1220*           		LD      A,'-'
041B0D 12          1221*           		LD      (DE),A          ;STORE SIGN
041B0E 13          1222*           		INC     DE
041B0F AF          1223*   STR10:			XOR     A               ;CLEAR A
041B10 B9          1224*           		CP      C
041B11 28 4E       1225*           		JR      Z,STR02          ;ZERO
041B13 D5          1226*           		PUSH    DE              ;SAVE TEXT POINTER
041B14 78          1227*           		LD      A,B
041B15 F5          1228*   STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
041B16 79          1229*           		LD      A,C             ;BINARY EXPONENT
041B17 FE A1       1230*           		CP      161
041B19 30 1C       1231*           		JR      NC,STR14
041B1B FE 9B       1232*           		CP      155
041B1D 30 29       1233*           		JR      NC,STR15
041B1F 2F          1234*           		CPL
041B20 FE E1       1235*           		CP      225
041B22 38 02       1236*           		JR      C,STR13
041B24 3E F8       1237*           		LD      A,-8
041B26 C6 1C       1238*   STR13:			ADD     A,28
041B28 CD B5 1F 04 1239*           		CALL    POWR10
041B2C F5          1240*           		PUSH    AF
041B2D CD A4 15 04 1241*           		CALL    FMUL
041B31 F1          1242*           		POP     AF
041B32 47          1243*           		LD      B,A
041B33 F1          1244*           		POP     AF
041B34 90          1245*           		SUB     B
041B35 18 DE       1246*           		JR      STR11
041B37 D6 20       1247*   STR14:			SUB     32
041B39 CD B5 1F 04 1248*           		CALL    POWR10
041B3D F5          1249*           		PUSH    AF
041B3E CD FB 14 04 1250*           		CALL    FDIV
041B42 F1          1251*           		POP     AF
041B43 47          1252*           		LD      B,A
041B44 F1          1253*           		POP     AF
041B45 80          1254*           		ADD     A,B
041B46 18 CD       1255*           		JR      STR11
041B48 3E 09       1256*   STR15:			LD      A,9
041B4A CD B5 1F 04 1257*           		CALL    POWR10          ;10^9
041B4E CD C9 1E 04 1258*           		CALL    FCP0
041B52 79          1259*           		LD      A,C
041B53 C1          1260*           		POP     BC
041B54 4F          1261*           		LD      C,A
041B55 CB FC       1262*           		SET     7,H             ;IMPLIED 1
041B57 DC F1 1E 04 1263*           		CALL    C,X10B          ;X10, DEC B
041B5B D1          1264*           		POP     DE              ;RESTORE TEXT POINTER
041B5C CB B9       1265*           		RES     7,C
041B5E 3E 00       1266*           		LD      A,0
041B60 17          1267*           		RLA                     ;PUT CARRY IN LSB
041B61             1268*   ;
041B61             1269*   ;At this point decimal normalisation has been done,
041B61             1270*   ;now convert to decimal digits:
041B61             1271*   ;      AHLH'L' = number in normalised integer form
041B61             1272*   ;            B = decimal place adjustment
041B61             1273*   ;            C = binary place adjustment (29-33)
041B61             1274*   ;
041B61 0C          1275*   STR02:			INC     C
041B62 08          1276*           		EX      AF,AF'          ;SAVE A
041B63 78          1277*           		LD      A,B
041B64 DD CB 02 4E 1278*           		BIT     1,(IX+2)
041B68 20 08       1279*           		JR      NZ,STR20
041B6A AF          1280*           		XOR     A
041B6B DD BE 01    1281*           		CP      (IX+1)
041B6E 28 0B       1282*           		JR      Z,STR21
041B70 3E F6       1283*           		LD      A,-10
041B72 DD 86 01    1284*   STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
041B75 B7          1285*           		OR      A               ;CLEAR CARRY
041B76 FA 7B 1B 04 1286*           		JP      M,STR21
041B7A AF          1287*           		XOR     A
041B7B F5          1288*   STR21:			PUSH    AF
041B7C 08          1289*           		EX      AF,AF'          ;RESTORE A
041B7D CD 25 1F 04 1290*   STR22:			CALL    X2              ;RL AHLH'L'
041B81 8F          1291*           		ADC     A,A
041B82 FE 0A       1292*           		CP      10
041B84 38 05       1293*           		JR      C,STR23
041B86 D6 0A       1294*           		SUB     10
041B88 D9          1295*           		EXX
041B89 2C          1296*           		INC     L               ;SET RESULT BIT
041B8A D9          1297*           		EXX
041B8B 0D          1298*   STR23:			DEC     C
041B8C 20 EF       1299*           		JR      NZ,STR22        ;32 TIMES
041B8E 4F          1300*           		LD      C,A             ;REMAINDER
041B8F 7C          1301*           		LD      A,H
041B90 E6 3F       1302*           		AND     3FH             ;CLEAR OUT JUNK
041B92 67          1303*           		LD      H,A
041B93 F1          1304*           		POP     AF
041B94 F2 A2 1B 04 1305*           		JP      P,STR24
041B98 3C          1306*           		INC     A
041B99 20 1C       1307*           		JR      NZ,STR26
041B9B 3E 04       1308*           		LD      A,4
041B9D B9          1309*           		CP      C               ;ROUND UP?
041B9E 3E 00       1310*           		LD      A,0
041BA0 18 15       1311*           		JR      STR26
041BA2 F5          1312*   STR24:			PUSH    AF
041BA3 79          1313*           		LD      A,C
041BA4 CE 30       1314*           		ADC     A,'0'           ;ADD CARRY
041BA6 FE 30       1315*           		CP      '0'
041BA8 28 05       1316*           		JR      Z,STR25         ;SUPPRESS ZERO
041BAA FE 3A       1317*           		CP      '9'+1
041BAC 3F          1318*           		CCF
041BAD 30 08       1319*           		JR      NC,STR26
041BAF E3          1320*   STR25:			EX      (SP),HL
041BB0 CB 75       1321*           		BIT     6,L             ;ZERO FLAG
041BB2 E3          1322*   		        EX      (SP),HL
041BB3 20 05       1323*           		JR      NZ,STR27
041BB5 3E 30       1324*           		LD      A,'0'
041BB7 3C          1325*   STR26:			INC     A               ;SET +VE
041BB8 3D          1326*           		DEC     A
041BB9 F5          1327*           		PUSH    AF              ;PUT ON STACK + CARRY
041BBA 04          1328*   STR27:			INC     B
041BBB CD 95 1E 04 1329*           		CALL    TEST_FP            ;IS HLH'L' ZERO?
041BBF 0E 20       1330*           		LD      C,32
041BC1 3E 00       1331*           		LD      A,0
041BC3 20 B8       1332*           		JR      NZ,STR22
041BC5 F1          1333*           		POP     AF
041BC6 F5          1334*           		PUSH    AF
041BC7 3E 00       1335*           		LD      A,0
041BC9 38 B2       1336*           		JR      C,STR22
041BCB             1337*   ;
041BCB             1338*   ;At this point, the decimal character string is stored
041BCB             1339*   ; on the stack. Trailing zeroes are suppressed and may
041BCB             1340*   ; need to be replaced.
041BCB             1341*   ;B register holds decimal point position.
041BCB             1342*   ;Now format number and store as ASCII string:
041BCB             1343*   ;
041BCB EB          1344*   STR3:			EX      DE,HL           ;STRING POINTER
041BCC 0E FF       1345*           		LD      C,-1            ;FLAG "E"
041BCE 16 01       1346*           		LD      D,1
041BD0 DD 5E 01    1347*           		LD      E,(IX+1)        ;f2
041BD3 DD CB 02 46 1348*           		BIT     0,(IX+2)
041BD7 20 35       1349*           		JR      NZ,STR34        ;E MODE
041BD9 DD CB 02 4E 1350*           		BIT     1,(IX+2)
041BDD 28 12       1351*           		JR      Z,STR31
041BDF 78          1352*           		LD      A,B             ;F MODE
041BE0 B7          1353*           		OR      A
041BE1 28 05       1354*           		JR      Z,STR30
041BE3 FA E8 1B 04 1355*           		JP      M,STR30
041BE7 50          1356*           		LD      D,B
041BE8 7A          1357*   STR30:			LD      A,D
041BE9 DD 86 01    1358*           		ADD     A,(IX+1)
041BEC 5F          1359*           		LD      E,A
041BED FE 0B       1360*           		CP      11
041BEF 38 19       1361*           		JR      C,STR32
041BF1 78          1362*   STR31:			LD      A,B             ;G MODE
041BF2 11 01 01 00 1363*           		LD      DE,101H
041BF6 B7          1364*           		OR      A
041BF7 FA 0E 1C 04 1365*           		JP      M,STR34
041BFB 28 0D       1366*           		JR      Z,STR32
041BFD DD 7E 01    1367*           		LD      A,(IX+1)
041C00 B7          1368*           		OR      A
041C01 20 02       1369*           		JR      NZ,STR3A
041C03 3E 0A       1370*           		LD      A,10
041C05 B8          1371*   STR3A:			CP      B
041C06 38 06       1372*           		JR      C,STR34
041C08 50          1373*           		LD      D,B
041C09 58          1374*           		LD      E,B
041C0A 78          1375*   STR32:			LD      A,B
041C0B C6 81       1376*           		ADD     A,129
041C0D 4F          1377*           		LD      C,A
041C0E CB FA       1378*   STR34:			SET     7,D
041C10 1D          1379*           		DEC     E
041C11 7A          1380*   STR35:			LD      A,D
041C12 B9          1381*           		CP      C
041C13 30 0E       1382*           		JR      NC,STR33
041C15 F1          1383*   STR36:			POP     AF
041C16 28 04       1384*           		JR      Z,STR37
041C18 F2 25 1C 04 1385*           		JP      P,STR38
041C1C F5          1386*   STR37:			PUSH    AF
041C1D 1C          1387*           		INC     E
041C1E 1D          1388*           		DEC     E
041C1F FA 36 1C 04 1389*           		JP      M,STR4
041C23 3E 30       1390*   STR33:			LD      A,'0'
041C25 15          1391*   STR38:			DEC     D
041C26 E2 2D 1C 04 1392*           		JP      PO,STR39
041C2A 36 2E       1393*           		LD      (HL),'.'
041C2C 23          1394*           		INC     HL
041C2D 77          1395*   STR39:			LD      (HL),A
041C2E 23          1396*           		INC     HL
041C2F 1D          1397*           		DEC     E
041C30 F2 11 1C 04 1398*           		JP      P,STR35
041C34 18 DF       1399*           		JR      STR36
041C36             1400*   ;
041C36 F1          1401*   STR4:			POP     AF
041C37 0C          1402*   STR40:			INC     C
041C38 4D          1403*           		LD      C,L
041C39 20 28       1404*           		JR      NZ,STR44
041C3B 36 45       1405*           		LD      (HL),'E'        ;EXPONENT
041C3D 23          1406*           		INC     HL
041C3E 78          1407*           		LD      A,B
041C3F 3D          1408*           		DEC     A
041C40 F2 49 1C 04 1409*           		JP      P,STR41
041C44 36 2D       1410*           		LD      (HL),'-'
041C46 23          1411*           		INC     HL
041C47 ED 44       1412*           		NEG
041C49 36 30       1413*   STR41:			LD      (HL),'0'
041C4B 28 15       1414*           		JR      Z,STR47
041C4D FE 0A       1415*           		CP      10
041C4F 47          1416*           		LD      B,A
041C50 3E 3A       1417*           		LD      A,':'
041C52 38 03       1418*           		JR      C,STR42
041C54 23          1419*           		INC     HL
041C55 36 30       1420*           		LD      (HL),'0'
041C57 34          1421*   STR42:			INC     (HL)
041C58 BE          1422*           		CP      (HL)
041C59 20 05       1423*           		JR      NZ,STR43
041C5B 36 30       1424*           		LD      (HL),'0'
041C5D 2B          1425*           		DEC     HL
041C5E 34          1426*           		INC     (HL)
041C5F 23          1427*           		INC     HL
041C60 10 F5       1428*   STR43:			DJNZ    STR42
041C62 23          1429*   STR47:			INC     HL
041C63 EB          1430*   STR44:			EX      DE,HL
041C64 C9          1431*         			RET
041C65             1432*   ;
041C65             1433*   ;Support subroutines:
041C65             1434*   ;
041C65 DD 46 04    1435*   DLOAD5:			LD      B,(IX+4)
041C68 D9          1436*           		EXX
041C69 DD 5E 00    1437*           		LD      E,(IX+0)
041C6C DD 56 01    1438*           		LD      D,(IX+1)
041C6F D9          1439*           		EXX
041C70 DD 5E 02    1440*           		LD      E,(IX+2)
041C73 DD 56 03    1441*           		LD      D,(IX+3)
041C76 C9          1442*           		RET
041C77             1443*   ;
041C77 DD 46 06    1444*   DLOAD5_SPL:		LD      B,(IX+6)
041C7A D9          1445*   			EXX
041C7B DD 17 00    1446*   			LD	DE, (IX+0)
041C7E D9          1447*   			EXX
041C7F DD 17 03    1448*   			LD	DE, (IX+3)
041C82 C9          1449*   			RET
041C83             1450*   ;
041C83             1451*   ;CON_FP - Get unsigned numeric constant from ASCII string.
041C83             1452*   ;   Inputs: ASCII string at (IX).
041C83             1453*   ;  Outputs: Variable-type result in HLH'L'C
041C83             1454*   ;           IX updated (points to delimiter)
041C83             1455*   ;           A7 = 0 (numeric marker)
041C83             1456*   ;
041C83 CD B9 1E 04 1457*   CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
041C87 0E 00       1458*           		LD      C,0             ;TRUNCATION COUNTER
041C89 CD 17 1D 04 1459*           		CALL    UINT          ;GET INTEGER PART
041C8D FE 2E       1460*           		CP      '.'
041C8F 06 00       1461*           		LD      B,0             ;DECL. PLACE COUNTER
041C91 CC 15 1D 04 1462*           		CALL    Z,NUMBIX        ;GET FRACTION PART
041C95 FE 45       1463*           		CP      'E'
041C97 3E 00       1464*           		LD      A,0             ;INITIALISE EXPONENT
041C99 CC E3 1C 04 1465*           		CALL    Z,GETEXP        ;GET EXPONENT
041C9D CB 7C       1466*           		BIT     7,H
041C9F 20 08       1467*           		JR      NZ,CON0         ;INTEGER OVERFLOW
041CA1 B7          1468*           		OR      A
041CA2 20 05       1469*           		JR      NZ,CON0         ;EXPONENT NON-ZERO
041CA4 B8          1470*           		CP      B
041CA5 20 02       1471*           		JR      NZ,CON0         ;DECIMAL POINT
041CA7 B9          1472*           		CP      C
041CA8 C8          1473*           		RET     Z               ;INTEGER
041CA9 90          1474*   CON0:			SUB     B
041CAA 81          1475*           		ADD     A,C
041CAB 0E 9F       1476*           		LD      C,159
041CAD CD 1C 1E 04 1477*           		CALL    FLOAT_
041CB1 CB BC       1478*           		RES     7,H             ;DITCH IMPLIED 1
041CB3 B7          1479*           		OR      A
041CB4 C8          1480*           		RET     Z               ;DONE
041CB5 FA C3 1C 04 1481*           		JP      M,CON2          ;NEGATIVE EXPONENT
041CB9 CD B5 1F 04 1482*           		CALL    POWR10
041CBD CD A4 15 04 1483*           		CALL    FMUL            ;SCALE
041CC1 AF          1484*           		XOR     A
041CC2 C9          1485*           		RET
041CC3 FE DA       1486*   CON2:			CP      -38
041CC5 38 0C       1487*           		JR      C,CON3          ;CAN'T SCALE IN ONE GO
041CC7 ED 44       1488*           		NEG
041CC9 CD B5 1F 04 1489*           		CALL    POWR10
041CCD CD FB 14 04 1490*           		CALL    FDIV            ;SCALE
041CD1 AF          1491*           		XOR     A
041CD2 C9          1492*           		RET
041CD3 F5          1493*   CON3:			PUSH    AF
041CD4 3E 26       1494*           		LD      A,38
041CD6 CD B5 1F 04 1495*           		CALL    POWR10
041CDA CD FB 14 04 1496*           		CALL    FDIV
041CDE F1          1497*           		POP     AF
041CDF C6 26       1498*           		ADD     A,38
041CE1 18 E0       1499*           		JR      CON2
041CE3             1500*   ;
041CE3             1501*   ;GETEXP - Get decimal exponent from string
041CE3             1502*   ;     Inputs: ASCII string at (IX)
041CE3             1503*   ;             (IX points at 'E')
041CE3             1504*   ;             A = initial value
041CE3             1505*   ;    Outputs: A = new exponent
041CE3             1506*   ;             IX updated.
041CE3             1507*   ;   Destroys: A,A',IX,F,F'
041CE3             1508*   ;
041CE3 C5          1509*   GETEXP:			PUSH    BC              ;SAVE REGISTERS
041CE4 47          1510*           		LD      B,A             ;INITIAL VALUE
041CE5 0E 02       1511*           		LD      C,2             ;2 DIGITS MAX
041CE7 DD 23       1512*           		INC     IX              ;BUMP PAST 'E'
041CE9 CD D3 20 04 1513*           		CALL    SIGNQ
041CED 08          1514*           		EX      AF,AF'          ;SAVE EXPONENT SIGN
041CEE CD C9 20 04 1515*   GETEX1:			CALL    DIGITQ
041CF2 38 18       1516*           		JR      C,GETEX2
041CF4 78          1517*           		LD      A,B             ;B=B*10
041CF5 87          1518*           		ADD     A,A
041CF6 87          1519*           		ADD     A,A
041CF7 80          1520*           		ADD     A,B
041CF8 87          1521*           		ADD     A,A
041CF9 47          1522*           		LD      B,A
041CFA DD 7E 00    1523*           		LD      A,(IX)          ;GET BACK DIGIT
041CFD DD 23       1524*           		INC     IX
041CFF E6 0F       1525*           		AND     0FH             ;MASK UNWANTED BITS
041D01 80          1526*           		ADD     A,B             ;ADD IN DIGIT
041D02 47          1527*           		LD      B,A
041D03 0D          1528*           		DEC     C
041D04 F2 EE 1C 04 1529*           		JP      P,GETEX1
041D08 06 64       1530*           		LD      B,100           ;FORCE OVERFLOW
041D0A 18 E2       1531*           		JR      GETEX1
041D0C 08          1532*   GETEX2:			EX      AF,AF'          ;RESTORE SIGN
041D0D FE 2D       1533*           		CP      '-'
041D0F 78          1534*           		LD      A,B
041D10 C1          1535*           		POP     BC              ;RESTORE
041D11 C0          1536*           		RET     NZ
041D12 ED 44       1537*           		NEG                     ;NEGATE EXPONENT
041D14 C9          1538*           		RET
041D15             1539*   ;
041D15             1540*   ;UINT: Get unsigned integer from string.
041D15             1541*   ;    Inputs: string at (IX)
041D15             1542*   ;            C = truncated digit count
041D15             1543*   ;                (initially zero)
041D15             1544*   ;            B = total digit count
041D15             1545*   ;            HLH'L' = initial value
041D15             1546*   ;   Outputs: HLH'L' = number (binary integer)
041D15             1547*   ;            A = delimiter.
041D15             1548*   ;            B, C & IX updated
041D15             1549*   ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
041D15             1550*   ;
041D15 DD 23       1551*   NUMBIX:			INC     IX
041D17 CD C9 20 04 1552*   UINT:			CALL    DIGITQ
041D1B D8          1553*           		RET     C
041D1C 04          1554*           		INC     B               ;INCREMENT DIGIT COUNT
041D1D DD 23       1555*           		INC     IX
041D1F CD 12 1F 04 1556*           		CALL    X10             ;*10 & COPY OLD VALUE
041D23 38 15       1557*           		JR      C,NUMB1         ;OVERFLOW
041D25 0D          1558*           		DEC     C               ;SEE IF TRUNCATED
041D26 0C          1559*           		INC     C
041D27 20 11       1560*           		JR      NZ,NUMB1        ;IMPORTANT!
041D29 E6 0F       1561*           		AND     0FH
041D2B D9          1562*           		EXX
041D2C 06 00       1563*           		LD      B,0
041D2E 4F          1564*           		LD      C,A
041D2F 52 09       1565*           		ADD.S   HL,BC           ;ADD IN DIGIT
041D31 D9          1566*           		EXX
041D32 30 E3       1567*           		JR      NC,UINT
041D34 52 23       1568*           		INC.S   HL              ;CARRY
041D36 7C          1569*           		LD      A,H
041D37 B5          1570*           		OR      L
041D38 20 DD       1571*           		JR      NZ,UINT
041D3A 0C          1572*   NUMB1:			INC     C               ;TRUNCATION COUNTER
041D3B CD 70 1E 04 1573*           		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
041D3F 18 D6       1574*           		JR      UINT
041D41             1575*   ;
041D41             1576*   ;FIX - Fix number to specified exponent value.
041D41             1577*   ;    Inputs: HLH'L'C = +ve non-zero number (floated)
041D41             1578*   ;            A = desired exponent (A>C)
041D41             1579*   ;   Outputs: HLH'L'C = fixed number (unsigned)
041D41             1580*   ;            fraction shifted into B'C'
041D41             1581*   ;            A'F' positive if integer input
041D41             1582*   ;  Destroys: C,H,L,A',B',C',H',L',F,F'
041D41             1583*   ;
041D41 08          1584*   FIX:			EX      AF,AF'
041D42 AF          1585*           		XOR     A
041D43 08          1586*           		EX      AF,AF'
041D44 CB FC       1587*           		SET     7,H             ;IMPLIED 1
041D46 CD 75 1E 04 1588*   FIX1:			CALL    DIV2
041D4A B9          1589*           		CP      C
041D4B C8          1590*           		RET     Z
041D4C D2 46 1D 04 1591*           		JP      NC,FIX1
041D50 C3 84 1E 04 1592*           		JP      OFLOW
041D54             1593*   ;
041D54             1594*   ;SFIX - Convert to integer if necessary.
041D54             1595*   ;    Input: Variable-type number in HLH'L'C
041D54             1596*   ;   Output: Integer in HLH'L', C=0
041D54             1597*   ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
041D54             1598*   ;
041D54             1599*   ;NEGATE - Negate HLH'L'
041D54             1600*   ;    Destroys: H,L,H',L',F
041D54             1601*   ;
041D54 CD 6D 1E 04 1602*   FIX2:			CALL    SWAP_FP
041D58 CD 60 1D 04 1603*           		CALL    SFIX_FP
041D5C CD 6D 1E 04 1604*           		CALL    SWAP_FP
041D60 0D          1605*   SFIX_FP:			DEC     C
041D61 0C          1606*           		INC     C
041D62 C8          1607*           		RET     Z               ;INTEGER/ZERO
041D63 CB 7C       1608*           		BIT     7,H             ;SIGN
041D65 F5          1609*           		PUSH    AF
041D66 3E 9F       1610*           		LD      A,159
041D68 CD 41 1D 04 1611*           		CALL    FIX
041D6C F1          1612*           		POP     AF
041D6D 0E 00       1613*           		LD      C,0
041D6F C8          1614*           		RET     Z
041D70 B7          1615*   NEGATE:			OR      A               ;CLEAR CARRY
041D71 D9          1616*           		EXX
041D72 D5          1617*   NEG0:			PUSH    DE
041D73 EB          1618*           		EX      DE,HL
041D74 21 00 00 00 1619*           		LD      HL,0
041D78 52 ED 52    1620*           		SBC.S   HL,DE
041D7B D1          1621*           		POP     DE
041D7C D9          1622*           		EXX
041D7D D5          1623*           		PUSH    DE
041D7E EB          1624*           		EX      DE,HL
041D7F 21 00 00 00 1625*           		LD      HL,0
041D83 52 ED 52    1626*           		SBC.S   HL,DE
041D86 D1          1627*           		POP     DE
041D87 C9          1628*           		RET
041D88             1629*   ;
041D88             1630*   ;NEG - Negate HLH'L'B'C'
041D88             1631*   ;    Also complements A (used in FADD)
041D88             1632*   ;    Destroys: A,H,L,B',C',H',L',F
041D88             1633*   ;
041D88 D9          1634*   NEG_:			EXX
041D89 2F          1635*           		CPL
041D8A E5          1636*           		PUSH    HL
041D8B B7          1637*           		OR      A               ;CLEAR CARRY
041D8C 21 00 00 00 1638*           		LD      HL,0
041D90 52 ED 42    1639*           		SBC.S   HL,BC
041D93 44          1640*           		LD      B,H
041D94 4D          1641*           		LD      C,L
041D95 E1          1642*           		POP     HL
041D96 18 DA       1643*           		JR      NEG0
041D98             1644*   ;
041D98             1645*   ;SCALE - Trig scaling.
041D98             1646*   ;MOD48 - 48-bit floating-point "modulus" (remainder).
041D98             1647*   ;   Inputs: HLH'L'C unsigned floating-point dividend
041D98             1648*   ;           DED'E'B'C'B unsigned 48-bit FP divisor
041D98             1649*   ;  Outputs: HLH'L'C floating point remainder (H7=1)
041D98             1650*   ;           E = quotient (bit 7 is sticky)
041D98             1651*   ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
041D98             1652*   ;FLO48 - Float unsigned number (48 bits)
041D98             1653*   ;    Input/output in HLH'L'B'C'C
041D98             1654*   ;   Destroys: C,H,L,B',C',H',L',F
041D98             1655*   ;
041D98 3E 96       1656*   SCALE:			LD      A,150
041D9A B9          1657*           		CP      C
041D9B 3E 17       1658*           		LD      A,ACLOST
041D9D DA 13 13 04 1659*           		JP      C,ERROR_FP_         ;"Accuracy lost"
041DA1 CD DE 18 04 1660*           		CALL    PIBY4
041DA5 D9          1661*           		EXX
041DA6 01 69 21 00 1662*           		LD      BC,2169H        ;3.141592653589793238
041DAA D9          1663*           		EXX
041DAB CB FA       1664*   MOD48:			SET     7,D             ;IMPLIED 1
041DAD CB FC       1665*           		SET     7,H
041DAF 79          1666*           		LD      A,C
041DB0 0E 00       1667*           		LD      C,0             ;INIT QUOTIENT
041DB2 DD 21 00 00 1668*           		LD      IX,0
       00          
041DB7 DD E5       1669*           		PUSH    IX              ;PUT ZERO ON STACK
041DB9 B8          1670*           		CP      B
041DBA 38 46       1671*           		JR      C,MOD485        ;DIVIDEND<DIVISOR
041DBC D9          1672*   MOD481:			EXX                     ;CARRY=0 HERE
041DBD E3          1673*           		EX      (SP),HL
041DBE 52 ED 42    1674*           		SBC.S   HL,BC
041DC1 E3          1675*           		EX      (SP),HL
041DC2 52 ED 52    1676*           		SBC.S   HL,DE
041DC5 D9          1677*           		EXX
041DC6 52 ED 52    1678*           		SBC.S   HL,DE
041DC9 30 0C       1679*           		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
041DCB D9          1680*           		EXX
041DCC E3          1681*           		EX      (SP),HL
041DCD 52 09       1682*           		ADD.S   HL,BC
041DCF E3          1683*           		EX      (SP),HL
041DD0 52 ED 5A    1684*           		ADC.S   HL,DE
041DD3 D9          1685*           		EXX
041DD4 52 ED 5A    1686*           		ADC.S   HL,DE
041DD7 3F          1687*   MOD482:			CCF
041DD8 CB 11       1688*           		RL      C               ;QUOTIENT
041DDA 30 02       1689*           		JR      NC,MOD483
041DDC CB F9       1690*           		SET     7,C             ;STICKY BIT
041DDE 3D          1691*   MOD483:			DEC     A
041DDF B8          1692*           		CP      B
041DE0 38 1F       1693*           		JR      C,MOD484        ;DIVIDEND<DIVISOR
041DE2 E3          1694*           		EX      (SP),HL
041DE3 52 29       1695*           		ADD.S   HL,HL           ;DIVIDEND * 2
041DE5 E3          1696*           		EX      (SP),HL
041DE6 D9          1697*           		EXX
041DE7 52 ED 6A    1698*           		ADC.S   HL,HL
041DEA D9          1699*           		EXX
041DEB 52 ED 6A    1700*           		ADC.S   HL,HL
041DEE 30 CC       1701*           		JR      NC,MOD481       ;AGAIN
041DF0 B7          1702*           		OR      A
041DF1 D9          1703*           		EXX
041DF2 E3          1704*           		EX      (SP),HL
041DF3 52 ED 42    1705*           		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
041DF6 E3          1706*           		EX      (SP),HL
041DF7 52 ED 52    1707*           		SBC.S   HL,DE
041DFA D9          1708*           		EXX
041DFB 52 ED 52    1709*           		SBC.S   HL,DE
041DFE B7          1710*           		OR      A
041DFF 18 D6       1711*           		JR      MOD482
041E01             1712*   ;
041E01 3C          1713*   MOD484:			INC     A
041E02 59          1714*   MOD485:			LD      E,C             ;QUOTIENT
041E03 4F          1715*           		LD      C,A             ;REMAINDER EXPONENT
041E04 D9          1716*           		EXX
041E05 C1          1717*           		POP     BC
041E06 D9          1718*           		EXX
041E07 CB 7C       1719*   FLO48:			BIT     7,H
041E09 C0          1720*           		RET     NZ
041E0A D9          1721*           		EXX
041E0B CB 21       1722*           		SLA     C
041E0D CB 10       1723*           		RL      B
041E0F 52 ED 6A    1724*           		ADC.S   HL,HL
041E12 D9          1725*           		EXX
041E13 52 ED 6A    1726*           		ADC.S   HL,HL
041E16 0D          1727*           		DEC     C
041E17 C2 07 1E 04 1728*           		JP      NZ,FLO48
041E1B C9          1729*           		RET
041E1C             1730*   ;
041E1C             1731*   ;Float unsigned number
041E1C             1732*   ;    Input/output in HLH'L'C
041E1C             1733*   ;   Destroys: C,H,L,H',L',F
041E1C             1734*   ;
041E1C CB 7C       1735*   FLOAT_:			BIT     7,H
041E1E C0          1736*           		RET     NZ
041E1F D9          1737*           		EXX                     ;SAME AS "X2"
041E20 52 29       1738*           		ADD.S   HL,HL           ;TIME-CRITICAL
041E22 D9          1739*           		EXX                     ;REGION
041E23 52 ED 6A    1740*           		ADC.S   HL,HL           ;(BENCHMARKS)
041E26 0D          1741*           		DEC     C
041E27 C2 1C 1E 04 1742*           		JP      NZ,FLOAT_
041E2B C9          1743*           		RET
041E2C             1744*   ;
041E2C             1745*   ;SFLOAT - Convert to floating-point if necessary.
041E2C             1746*   ;    Input: Variable-type number in HLH'L'C
041E2C             1747*   ;    Output: Floating-point in HLH'L'C
041E2C             1748*   ;    Destroys: A,C,H,L,H',L',F
041E2C             1749*   ;
041E2C 08          1750*   FLOATA:			EX      AF,AF'
041E2D             1751*           		; ADD     A,(RTABLE-DTABLE)/3
041E2D C6 2A       1752*           		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
041E2F 08          1753*           		EX      AF,AF'
041E30 CD 6D 1E 04 1754*   FLOAT2:			CALL    SWAP_FP
041E34 CD 3C 1E 04 1755*           		CALL    SFLOAT_FP
041E38 CD 6D 1E 04 1756*           		CALL    SWAP_FP
041E3C 0D          1757*   SFLOAT_FP:			DEC     C
041E3D 0C          1758*           		INC     C
041E3E C0          1759*           		RET     NZ              ;ALREADY FLOATING-POINT
041E3F CD 95 1E 04 1760*           		CALL    TEST_FP
041E43 C8          1761*           		RET     Z               ;ZERO
041E44 7C          1762*           		LD      A,H
041E45 B7          1763*           		OR      A
041E46 FC 70 1D 04 1764*           		CALL    M,NEGATE
041E4A 0E 9F       1765*           		LD      C,159
041E4C CD 1C 1E 04 1766*           		CALL    FLOAT_
041E50 B7          1767*           		OR      A
041E51 F8          1768*           		RET     M               ;NEGATIVE
041E52 CB BC       1769*           		RES     7,H
041E54 C9          1770*           		RET
041E55             1771*   ;
041E55             1772*   ;ROUND UP
041E55             1773*   ;Return with carry set if 32-bit overflow
041E55             1774*   ;   Destroys: H,L,B',C',H',L',F
041E55             1775*   ;
041E55 D9          1776*   ADD1_FP:			EXX
041E56 01 01 00 00 1777*           		LD      BC,1
041E5A 52 09       1778*           		ADD.S   HL,BC
041E5C D9          1779*           		EXX
041E5D D0          1780*           		RET     NC
041E5E C5          1781*           		PUSH    BC
041E5F 01 01 00 00 1782*           		LD      BC,1
041E63 52 09       1783*           		ADD.S   HL,BC
041E65 C1          1784*           		POP     BC
041E66 C9          1785*           		RET
041E67             1786*   ;
041E67             1787*   ;ODD - Add one if even, leave alone if odd.
041E67             1788*   ; (Used to perform unbiassed rounding, i.e.
041E67             1789*   ;  number is rounded up half the time)
041E67             1790*   ;    Destroys: L',F (carry cleared)
041E67             1791*   ;
041E67 B7          1792*   ODD:			OR      A               ;CLEAR CARRY
041E68 D9          1793*           		EXX
041E69 CB C5       1794*           		SET     0,L             ;MAKE ODD
041E6B D9          1795*           		EXX
041E6C C9          1796*           		RET
041E6D             1797*   ;
041E6D             1798*   ;SWAP_FP - Swap arguments.
041E6D             1799*   ;    Exchanges DE,HL D'E',H'L' and B,C
041E6D             1800*   ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
041E6D             1801*   ;SWAP1 - Swap DEHL with D'E'H'L'
041E6D             1802*   ;    Destroys: D,E,H,L,D',E',H',L'
041E6D             1803*   ;
041E6D 79          1804*   SWAP_FP:			LD      A,C
041E6E 48          1805*           		LD      C,B
041E6F 47          1806*           		LD      B,A
041E70 EB          1807*   SWAP1:			EX      DE,HL
041E71 D9          1808*           		EXX
041E72 EB          1809*           		EX      DE,HL
041E73 D9          1810*           		EXX
041E74 C9          1811*           		RET
041E75             1812*   ;
041E75             1813*   ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
041E75             1814*   ; INCC - destroys C,F
041E75             1815*   ; OFLOW
041E75             1816*   ;
041E75 CD 2E 1F 04 1817*   DIV2:			CALL    D2
041E79 D9          1818*           		EXX
041E7A CB 18       1819*           		RR      B
041E7C CB 19       1820*           		RR      C
041E7E 08          1821*           		EX      AF,AF'
041E7F B0          1822*           		OR      B
041E80 08          1823*           		EX      AF,AF'
041E81 D9          1824*           		EXX
041E82 0C          1825*   INCC:			INC     C
041E83 C0          1826*           		RET     NZ
041E84 3E 14       1827*   OFLOW:			LD      A,TOOBIG_FP
041E86 C3 13 13 04 1828*           		JP      ERROR_FP_           ;"Too big"
041E8A             1829*   ;
041E8A             1830*   ; FTEST - Test for zero & sign
041E8A             1831*   ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
041E8A             1832*   ;
041E8A CD 95 1E 04 1833*   FTEST_FP:			CALL    TEST_FP
041E8E C8          1834*           		RET     Z
041E8F 7C          1835*           		LD      A,H
041E90 E6 80       1836*           		AND     10000000B
041E92 F6 40       1837*           		OR      01000000B
041E94 C9          1838*           		RET
041E95             1839*   ;
041E95             1840*   ; TEST_FP - Test HLH'L' for zero.
041E95             1841*   ;     Output: Z-flag set & A=0 if HLH'L'=0
041E95             1842*   ;     Destroys: A,F
041E95             1843*   ;
041E95 7C          1844*   TEST_FP:			LD      A,H
041E96 B5          1845*           		OR      L
041E97 D9          1846*           		EXX
041E98 B4          1847*           		OR      H
041E99 B5          1848*           		OR      L
041E9A D9          1849*           		EXX
041E9B C9          1850*           		RET
041E9C             1851*   ;
041E9C             1852*   ; FCOMP - Compare two numbers
041E9C             1853*   ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
041E9C             1854*   ;
041E9C 78          1855*   FCOMP_FP:			LD      A,B
041E9D B1          1856*           		OR      C               ;Both integer?
041E9E 20 0B       1857*           		JR      NZ,FCOMP1
041EA0 CD B5 1E 04 1858*           		CALL    ICP
041EA4 3E 00       1859*   FCOMP0:			LD      A,0
041EA6 C8          1860*           		RET     Z               ;Equal
041EA7 3E 80       1861*           		LD      A,80H
041EA9 1F          1862*           		RRA
041EAA C9          1863*           		RET
041EAB             1864*   ;
041EAB CD 30 1E 04 1865*   FCOMP1:			CALL    FLOAT2          ;Float both
041EAF CD C3 1E 04 1866*           		CALL    FCP
041EB3 18 EF       1867*           		JR      FCOMP0
041EB5             1868*   ;
041EB5             1869*   ; Integer and floating point compare.
041EB5             1870*   ; Sets carry & zero flags according to HLH'L'C-DED'E'B
041EB5             1871*   ; Result pre-set to FALSE
041EB5             1872*   ; ICP1, FCP1 destroy A,F
041EB5             1873*   ;
041EB5             1874*   ; ZERO - Return zero.
041EB5             1875*   ;  Destroys: A,C,H,L,H',L'
041EB5             1876*   ;
041EB5 CD E8 1E 04 1877*   ICP:			CALL    ICP1
041EB9 3E 00       1878*   ZERO_FP:			LD      A,0
041EBB D9          1879*           		EXX
041EBC 67          1880*           		LD      H,A
041EBD 6F          1881*   	       		LD      L,A
041EBE D9          1882*           		EXX
041EBF 67          1883*         			LD      H,A
041EC0 6F          1884*        			LD      L,A
041EC1 4F          1885*   	    		LD      C,A
041EC2 C9          1886*           		RET
041EC3             1887*   ;
041EC3 CD DA 1E 04 1888*   FCP:			CALL    FCP1
041EC7 18 F0       1889*           		JR      ZERO_FP            ;PRESET FALSE
041EC9             1890*   ;
041EC9 79          1891*   FCP0:			LD      A,C
041ECA B8          1892*           		CP      B               ;COMPARE EXPONENTS
041ECB C0          1893*           		RET     NZ
041ECC             1894*   ICP0:
041ECC 52 ED 52    1895*   			SBC.S   HL,DE           ;COMP MANTISSA MSB
041ECF 52 19       1896*           		ADD.S   HL,DE
041ED1 C0          1897*           		RET     NZ
041ED2 D9          1898*           		EXX
041ED3 52 ED 52    1899*           		SBC.S   HL,DE           ;COMP MANTISSA LSB
041ED6 52 19       1900*           		ADD.S   HL,DE
041ED8 D9          1901*           		EXX
041ED9 C9          1902*           		RET
041EDA             1903*   ;
041EDA 7C          1904*   FCP1:			LD      A,H
041EDB AA          1905*           		XOR     D
041EDC 7C          1906*           		LD      A,H
041EDD 17          1907*           		RLA
041EDE F8          1908*           		RET     M
041EDF 30 E8       1909*           		JR      NC,FCP0
041EE1 CD C9 1E 04 1910*           		CALL    FCP0
041EE5 C8          1911*           		RET     Z               ;** V0.1 BUG FIX
041EE6 3F          1912*           		CCF
041EE7 C9          1913*           		RET
041EE8             1914*   ;
041EE8 7C          1915*   ICP1:			LD      A,H
041EE9 AA          1916*           		XOR     D
041EEA F2 CC 1E 04 1917*           		JP      P,ICP0
041EEE 7C          1918*           		LD      A,H
041EEF 17          1919*           		RLA
041EF0 C9          1920*           		RET
041EF1             1921*   ;
041EF1             1922*   ; ADD - Integer add.
041EF1             1923*   ; Carry, sign & zero flags valid on exit
041EF1             1924*   ;     Destroys: H,L,H',L',F
041EF1             1925*   ;
041EF1 05          1926*   X10B:			DEC     B
041EF2 0C          1927*           		INC     C
041EF3 CD 3A 1F 04 1928*   X5:			CALL    COPY0
041EF7 CD 2D 1F 04 1929*           		CALL    D2C
041EFB CD 2D 1F 04 1930*           		CALL    D2C
041EFF 08          1931*           		EX      AF,AF'          ;SAVE CARRY
041F00 D9          1932*   ADD_:			EXX
041F01 52 19       1933*           		ADD.S   HL,DE
041F03 D9          1934*           		EXX
041F04 52 ED 5A    1935*           		ADC.S   HL,DE
041F07 C9          1936*           		RET
041F08             1937*   ;
041F08             1938*   ; SUB - Integer subtract.
041F08             1939*   ; Carry, sign & zero flags valid on exit
041F08             1940*   ;     Destroys: H,L,H',L',F
041F08             1941*   ;
041F08 D9          1942*   SUB_:			EXX
041F09 B7          1943*           		OR      A
041F0A 52 ED 52    1944*           		SBC.S   HL,DE
041F0D D9          1945*           		EXX
041F0E 52 ED 52    1946*           		SBC.S   HL,DE
041F11 C9          1947*           		RET
041F12             1948*   ;
041F12             1949*   ; X10 - unsigned integer * 10
041F12             1950*   ;    Inputs: HLH'L' initial value
041F12             1951*   ;   Outputs: DED'E' = initial HLH'L'
041F12             1952*   ;            Carry bit set if overflow
041F12             1953*   ;            If carry not set HLH'L'=result
041F12             1954*   ;  Destroys: D,E,H,L,D',E',H',L',F
041F12             1955*   ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
041F12             1956*   ;     Carry set if MSB=1 before shift.
041F12             1957*   ;     Sign set if MSB=1 after shift.
041F12             1958*   ;     Destroys: H,L,H',L',F
041F12             1959*   ;
041F12 CD 3A 1F 04 1960*   X10:			CALL    COPY0           ;DED'E'=HLH'L'
041F16 CD 25 1F 04 1961*           		CALL    X2
041F1A D8          1962*           		RET     C               ;TOO BIG
041F1B CD 25 1F 04 1963*           		CALL    X2
041F1F D8          1964*           		RET     C
041F20 CD 00 1F 04 1965*           		CALL    ADD_
041F24 D8          1966*           		RET     C
041F25 D9          1967*   X2:			EXX
041F26 52 29       1968*           		ADD.S   HL,HL
041F28 D9          1969*           		EXX
041F29 52 ED 6A    1970*           		ADC.S   HL,HL
041F2C C9          1971*           		RET
041F2D             1972*   ;
041F2D             1973*   ; D2 - Divide HLH'L' by 2 as 32-bit integer.
041F2D             1974*   ;     Carry set if LSB=1 before shift.
041F2D             1975*   ;     Destroys: H,L,H',L',F
041F2D             1976*   ;
041F2D 0C          1977*   D2C:			INC     C
041F2E CB 3C       1978*   D2:			SRL     H
041F30 CB 1D       1979*           		RR      L
041F32 D9          1980*           		EXX
041F33 CB 1C       1981*           		RR      H
041F35 CB 1D       1982*           		RR      L
041F37 D9          1983*           		EXX
041F38 C9          1984*           		RET
041F39             1985*   ;
041F39             1986*   ; COPY - COPY HLH'L'C INTO DED'E'B
041F39             1987*   ;   Destroys: B,C,D,E,H,L,D',E',H',L'
041F39             1988*   ;
041F39 41          1989*   COPY_:			LD      B,C
041F3A 54          1990*   COPY0:			LD      D,H
041F3B 5D          1991*           		LD      E,L
041F3C D9          1992*           		EXX
041F3D 54          1993*           		LD      D,H
041F3E 5D          1994*           		LD      E,L
041F3F D9          1995*           		EXX
041F40 C9          1996*           		RET
041F41             1997*   ;
041F41             1998*   ; SQUARE - PUSH X*X
041F41             1999*   ; PUSH5 - PUSH HLH'L'C ONTO STACK.
041F41             2000*   ;   Destroys: SP,IX
041F41             2001*   ;
041F41 CD 39 1F 04 2002*   SQUARE:			CALL    COPY_
041F45 CD A4 15 04 2003*           		CALL    FMUL
041F49 DD E1       2004*   PUSH5:			POP     IX              ;RETURN ADDRESS
041F4B C5          2005*           		PUSH    BC
041F4C E5          2006*           		PUSH    HL
041F4D D9          2007*           		EXX
041F4E E5          2008*           		PUSH    HL
041F4F D9          2009*           		EXX
041F50 DD E9       2010*           		JP      (IX)            ;"RETURN"
041F52             2011*   ;
041F52             2012*   ; POP5 - POP DED'E'B OFF STACK.
041F52             2013*   ;   Destroys: A,B,D,E,D',E',SP,IX
041F52             2014*   ;
041F52 DD E1       2015*   POP5:			POP     IX              ;RETURN ADDRESS
041F54 D9          2016*           		EXX
041F55 D1          2017*           		POP     DE
041F56 D9          2018*           		EXX
041F57 D1          2019*           		POP     DE
041F58 79          2020*           		LD      A,C
041F59 C1          2021*           		POP     BC
041F5A 41          2022*           		LD      B,C
041F5B 4F          2023*           		LD      C,A
041F5C DD E9       2024*           		JP      (IX)            ;"RETURN"
041F5E             2025*   ;
041F5E             2026*   ; RATIO - Calculate (X-1)/(X+1)
041F5E             2027*   ;     Inputs: X in HLH'L'C
041F5E             2028*   ;    Outputs: (X-1)/(X+1) in HLH'L'C
041F5E             2029*   ;   Destroys: Everything except IY,SP,I
041F5E             2030*   ;
041F5E CD 49 1F 04 2031*   RATIO:			CALL    PUSH5           ;SAVE X
041F62 CD D1 18 04 2032*           		CALL    DONE
041F66 CD 92 14 04 2033*           		CALL    FADD
041F6A CD 52 1F 04 2034*           		CALL    POP5            ;RESTORE X
041F6E CD 49 1F 04 2035*           		CALL    PUSH5           ;SAVE X+1
041F72 CD 6D 1E 04 2036*           		CALL    SWAP_FP
041F76 CD D1 18 04 2037*           		CALL    DONE
041F7A CD 79 14 04 2038*           		CALL    FSUB
041F7E CD 52 1F 04 2039*           		CALL    POP5            ;RESTORE X+1
041F82 C3 FB 14 04 2040*           		JP      FDIV
041F86             2041*   ;
041F86             2042*   ; POLY - Evaluate a polynomial.
041F86             2043*   ;     Inputs: X in HLH'L'C and also stored at (SP+2)
041F86             2044*   ;             Polynomial coefficients follow call.
041F86             2045*   ;    Outputs: Result in HLH'L'C
041F86             2046*   ;   Destroys: Everything except IY,SP,I
041F86             2047*   ; Routine terminates on finding a coefficient >=1.
041F86             2048*   ; Note: The last coefficient is EXECUTED on return
041F86             2049*   ;       so must contain only innocuous bytes!
041F86             2050*   ;
041F86 DD 21 03 00 2051*   POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
041F8B DD 39       2052*           		ADD     IX, SP
041F8D DD E3       2053*           		EX      (SP), IX			; IX: Points to the inline list of coefficients
041F8F             2054*   ;
041F8F CD 65 1C 04 2055*           		CALL    DLOAD5          		; Load the first coefficient from (IX)
041F93 CD A4 15 04 2056*   POLY1:			CALL    FMUL
041F97 11 05 00 00 2057*           		LD      DE, 5				; Skip to the next coefficient
041F9B DD 19       2058*           		ADD     IX, DE
041F9D CD 65 1C 04 2059*           		CALL    DLOAD5          		; Load the second coefficient from (IX)
041FA1 DD E3       2060*           		EX      (SP), IX			; Restore the SP just in case we need to return
041FA3 04          2061*           		INC     B
041FA4 05          2062*           		DEC     B               		; Test B for end byte (80h)
041FA5 FA 92 14 04 2063*           		JP      M,FADD				; Yes, so add and return
041FA9 CD 92 14 04 2064*           		CALL    FADD				; No, so add
041FAD CD 77 1C 04 2065*           		CALL    DLOAD5_SPL			; Load X from SP
041FB1 DD E3       2066*           		EX      (SP), IX			; IX: Points to the inline list of coefficients
041FB3 18 DE       2067*           		JR      POLY1				; And loop
041FB5             2068*   ;
041FB5             2069*   ; POWR10 - Calculate power of ten.
041FB5             2070*   ;     Inputs: A=power of 10 required (A<128)
041FB5             2071*   ;             A=binary exponent to be exceeded (A>=128)
041FB5             2072*   ;    Outputs: DED'E'B = result
041FB5             2073*   ;             A = actual power of ten returned
041FB5             2074*   ;   Destroys: A,B,D,E,A',D',E',F,F'
041FB5             2075*   ;
041FB5 3C          2076*   POWR10:			INC     A
041FB6 08          2077*           		EX      AF,AF'
041FB7 E5          2078*           		PUSH    HL
041FB8 D9          2079*           		EXX
041FB9 E5          2080*           		PUSH    HL
041FBA D9          2081*           		EXX
041FBB CD D1 18 04 2082*           		CALL    DONE
041FBF CD 6D 1E 04 2083*           		CALL    SWAP_FP
041FC3 AF          2084*           		XOR     A
041FC4 08          2085*   POWR11:			EX      AF,AF'
041FC5 3D          2086*           		DEC     A
041FC6 28 26       2087*           		JR      Z,POWR14        ;EXIT TYPE 1
041FC8 F2 D0 1F 04 2088*           		JP      P,POWR13
041FCC B9          2089*           		CP      C
041FCD 38 1F       2090*           		JR      C,POWR14        ;EXIT TYPE 2
041FCF 3C          2091*           		INC     A
041FD0 08          2092*   POWR13:			EX      AF,AF'
041FD1 3C          2093*           		INC     A
041FD2 CB FC       2094*           		SET     7,H
041FD4 CD F3 1E 04 2095*           		CALL    X5
041FD8 30 06       2096*           		JR      NC,POWR12
041FDA 08          2097*           		EX      AF,AF'
041FDB CD 2D 1F 04 2098*           		CALL    D2C
041FDF 08          2099*           		EX      AF,AF'
041FE0 08          2100*   POWR12:			EX      AF,AF'
041FE1 DC 55 1E 04 2101*           		CALL    C,ADD1_FP          ;ROUND UP
041FE5 0C          2102*           		INC     C
041FE6 FA C4 1F 04 2103*           		JP      M,POWR11
041FEA C3 84 1E 04 2104*           		JP      OFLOW
041FEE CD 6D 1E 04 2105*   POWR14:			CALL    SWAP_FP
041FF2 CB BA       2106*           		RES     7,D
041FF4 D9          2107*           		EXX
041FF5 E1          2108*           		POP     HL
041FF6 D9          2109*           		EXX
041FF7 E1          2110*           		POP     HL
041FF8 08          2111*           		EX      AF,AF'
041FF9 C9          2112*           		RET
041FFA             2113*   ;
041FFA             2114*   ; DIVA, DIVB - DIVISION PRIMITIVE.
041FFA             2115*   ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
041FFA             2116*   ;               Remainder in H'L'HL
041FFA             2117*   ;     Inputs: A = loop counter (normally -32)
041FFA             2118*   ;     Destroys: A,D,E,H,L,D',E',H',L',F
041FFA             2119*   ;
041FFA B7          2120*   DIVA:			OR      A               ;CLEAR CARRY
041FFB             2121*   DIV0:
041FFB 52 ED 42    2122*   			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
041FFE D9          2123*           		EXX
041FFF 52 ED 42    2124*           		SBC.S   HL,BC
042002 D9          2125*           		EXX
042003 30 07       2126*           		JR      NC,DIV1
042005 52 09       2127*           		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
042007 D9          2128*           		EXX
042008 52 ED 4A    2129*           		ADC.S   HL,BC
04200B D9          2130*           		EXX
04200C 3F          2131*   DIV1:			CCF
04200D CB 13       2132*   DIVC:			RL      E               ;SHIFT RESULT INTO DE
04200F CB 12       2133*           		RL      D
042011 D9          2134*           		EXX
042012 CB 13       2135*           		RL      E
042014 CB 12       2136*           		RL      D
042016 D9          2137*           		EXX
042017 3C          2138*           		INC     A
042018 F0          2139*           		RET     P
042019             2140*   DIVB:
042019 52 ED 6A    2141*   			ADC.S   HL,HL           ;DIVIDEND*2
04201C D9          2142*           		EXX
04201D 52 ED 6A    2143*           		ADC.S   HL,HL
042020 D9          2144*           		EXX
042021 30 D8       2145*           		JR      NC,DIV0
042023 B7          2146*           		OR      A
042024 52 ED 42    2147*           		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
042027 D9          2148*           		EXX
042028 52 ED 42    2149*           		SBC.S   HL,BC
04202B D9          2150*           		EXX
04202C 37          2151*           		SCF
04202D C3 0D 20 04 2152*           		JP      DIVC
042031             2153*   ;
042031             2154*   ;MULA, MULB - MULTIPLICATION PRIMITIVE.
042031             2155*   ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
042031             2156*   ;    Inputs: A = loop counter (usually -32)
042031             2157*   ;            H'L'HL = 0
042031             2158*   ;    Destroys: D,E,H,L,D',E',H',L',A,F
042031             2159*   ;
042031 B7          2160*   MULA:			OR      A               ;CLEAR CARRY
042032 D9          2161*   MUL0:			EXX
042033 CB 1A       2162*           		RR      D               ;MULTIPLIER/2
042035 CB 1B       2163*           		RR      E
042037 D9          2164*           		EXX
042038 CB 1A       2165*           		RR      D
04203A CB 1B       2166*           		RR      E
04203C 30 07       2167*           		JR      NC,MUL1
04203E 52 09       2168*           		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
042040 D9          2169*           		EXX
042041 52 ED 4A    2170*           		ADC.S   HL,BC
042044 D9          2171*           		EXX
042045 3C          2172*   MUL1:			INC     A
042046 F0          2173*           		RET     P
042047 D9          2174*   MULB:			EXX
042048 CB 1C       2175*           		RR      H               ;PRODUCT/2
04204A CB 1D       2176*           		RR      L
04204C D9          2177*           		EXX
04204D CB 1C       2178*           		RR      H
04204F CB 1D       2179*           		RR      L
042051 C3 32 20 04 2180*           		JP      MUL0
042055             2181*   ;
042055             2182*   ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
042055             2183*   ;     Function: B'C'BC = SQR (D'E'DE)
042055             2184*   ;     Inputs: A = loop counter (normally -31)
042055             2185*   ;             B'C'BCH'L'HL initialised to 0
042055             2186*   ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
042055             2187*   ;
042055             2188*   SQR1:
042055 52 ED 42    2189*   			SBC.S   HL,BC
042058 D9          2190*           		EXX
042059 52 ED 42    2191*           		SBC.S   HL,BC
04205C D9          2192*           		EXX
04205D 0C          2193*           		INC     C
04205E 30 09       2194*           		JR      NC,SQR2
042060 0D          2195*           		DEC     C
042061 52 09       2196*           		ADD.S   HL,BC
042063 D9          2197*           		EXX
042064 52 ED 4A    2198*           		ADC.S   HL,BC
042067 D9          2199*           		EXX
042068 0D          2200*           		DEC     C
042069 3C          2201*   SQR2:			INC     A
04206A F0          2202*           		RET     P
04206B CB 21       2203*   SQRA:			SLA     C
04206D CB 10       2204*           		RL      B
04206F D9          2205*           		EXX
042070 CB 11       2206*           		RL      C
042072 CB 10       2207*           		RL      B
042074 D9          2208*           		EXX
042075 0C          2209*           		INC     C
042076 CB 23       2210*           		SLA     E
042078 CB 12       2211*           		RL      D
04207A D9          2212*           		EXX
04207B CB 13       2213*           		RL      E
04207D CB 12       2214*           		RL      D
04207F D9          2215*           		EXX
042080 52 ED 6A    2216*           		ADC.S   HL,HL
042083 D9          2217*           		EXX
042084 52 ED 6A    2218*           		ADC.S   HL,HL
042087 D9          2219*           		EXX
042088 CB 23       2220*           		SLA     E
04208A CB 12       2221*           		RL      D
04208C D9          2222*           		EXX
04208D CB 13       2223*           		RL      E
04208F CB 12       2224*           		RL      D
042091 D9          2225*           		EXX
042092 52 ED 6A    2226*           		ADC.S   HL,HL
042095 D9          2227*           		EXX
042096 52 ED 6A    2228*           		ADC.S   HL,HL
042099 D9          2229*           		EXX
04209A D2 55 20 04 2230*           		JP      NC,SQR1
04209E B7          2231*   SQR3:			OR      A
04209F 52 ED 42    2232*           		SBC.S   HL,BC
0420A2 D9          2233*           		EXX
0420A3 52 ED 42    2234*           		SBC.S   HL,BC
0420A6 D9          2235*           		EXX
0420A7 0C          2236*           		INC     C
0420A8 C3 69 20 04 2237*           		JP      SQR2
0420AC             2238*   ;
0420AC             2239*   SQRB:
0420AC 52 29       2240*   			ADD.S   HL,HL
0420AE D9          2241*           		EXX
0420AF 52 ED 6A    2242*           		ADC.S   HL,HL
0420B2 D9          2243*           		EXX
0420B3 38 E9       2244*           		JR      C,SQR3
0420B5 3C          2245*           		INC     A
0420B6 0C          2246*           		INC     C
0420B7 52 ED 42    2247*           		SBC.S   HL,BC
0420BA D9          2248*           		EXX
0420BB 52 ED 42    2249*           		SBC.S   HL,BC
0420BE D9          2250*           		EXX
0420BF D0          2251*           		RET     NC
0420C0 52 09       2252*           		ADD.S   HL,BC
0420C2 D9          2253*           		EXX
0420C3 52 ED 4A    2254*           		ADC.S   HL,BC
0420C6 D9          2255*           		EXX
0420C7 0D          2256*           		DEC     C
0420C8 C9          2257*           		RET
0420C9             2258*   ;
0420C9 DD 7E 00    2259*   DIGITQ:			LD      A,(IX)
0420CC FE 3A       2260*           		CP      '9'+1
0420CE 3F          2261*           		CCF
0420CF D8          2262*           		RET     C
0420D0 FE 30       2263*           		CP      '0'
0420D2 C9          2264*           		RET
0420D3             2265*   ;
0420D3 DD 7E 00    2266*   SIGNQ:			LD      A,(IX)
0420D6 DD 23       2267*           		INC     IX
0420D8 FE 20       2268*           		CP      ' '
0420DA 28 F7       2269*           		JR      Z,SIGNQ
0420DC FE 2B       2270*           		CP      '+'
0420DE C8          2271*           		RET     Z
0420DF FE 2D       2272*           		CP      '-'
0420E1 C8          2273*           		RET     Z
0420E2 DD 2B       2274*           		DEC     IX
0420E4 C9          2275*           		RET
0420E5             0035        include "../agon/functions.inc"
0420E5             0001*   ; Print a zero-terminated string inline with code, e.g.:
0420E5             0002*   ;
0420E5             0003*   ;    call printInline
0420E5             0004*   ;    ASCIZ "Hello, world!\r\n"
0420E5             0005*   ;
0420E5             0006*   ; Destroys: HL,AF
0420E5             0007*   printInline:
0420E5 E1          0008*       pop hl ; get the return address = pointer to start of string
0420E6 CD EC 20 04 0009*       call printString ; HL advances to end of string
0420EA E5          0010*       push hl ; restore the return address = pointer to end of string
0420EB C9          0011*       ret
0420EC             0012*   
0420EC             0013*   ; Print a zero-terminated string
0420EC             0014*   ; IX: Pointer to string, A: signed offset from IX
0420EC             0015*   printStringIX:
0420EC             0016*   
0420EC             0017*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0420EC             0018*   ; Print a zero-terminated string
0420EC             0019*   ; HL: Pointer to string
0420EC             0020*   ; returns: hl pointed to character after string terminator
0420EC             0021*   ; destroys: af, hl
0420EC             0022*   printString:
0420EC C5          0023*       PUSH BC
0420ED 01 00 00 00 0024*       LD BC,0
0420F1 3E 00       0025*       LD A,0
0420F3 5B DF       0026*       RST.LIL 18h
0420F5 C1          0027*       POP BC
0420F6 C9          0028*       RET
0420F7             0029*   ; print a VDU sequence
0420F7             0030*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
0420F7             0031*   sendVDUsequence:
0420F7 C5          0032*       PUSH BC
0420F8 01 00 00 00 0033*       LD BC, 0
0420FC 4E          0034*       LD C, (HL)
0420FD 5B DF       0035*       RST.LIL 18h
0420FF C1          0036*       POP BC
042100 C9          0037*       RET
042101             0038*   ; Print Newline sequence to VDP
042101             0039*   ; destroys: nothing
042101             0040*   printNewLine:
042101 F5          0041*       push af ; for some reason rst.lil 10h sets carry flag
042102 3E 0D       0042*       LD A, '\r'
042104 5B D7       0043*       RST.LIL 10h
042106 3E 0A       0044*       LD A, '\n'
042108 5B D7       0045*       RST.LIL 10h
04210A F1          0046*       pop af
04210B C9          0047*       RET
04210C             0048*   
04210C             0049*   ; print a zero-terminated string at a graphics coordinate
04210C             0050*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
04210C             0051*   printStringGfx:
04210C E5          0052*       push hl ; preserve string pointer
04210D             0053*   ; move graphics cursor to x,y location
04210D 3E 44       0054*       ld a,plot_pt+mv_abs
04210F CD F4 2B 04 0055*       call vdu_plot
042113             0056*   ; print string
042113 E1          0057*       pop hl ; restore string pointer
042114             0058*   @print_loop:
042114 7E          0059*       ld a,(hl)
042115 B7          0060*       or a ; check for end of string
042116 C8          0061*       ret z ; if zero, we're done
042117 08          0062*       ex af,af' ; preserve character
042118 3E 05       0063*       ld a,5 ; VDU 5 char to gfx cursor
04211A 5B D7       0064*       rst.lil 10h ; send it
04211C 08          0065*       ex af,af' ; restore character
04211D 5B D7       0066*       rst.lil 10h ; print character
04211F 23          0067*       inc hl
042120 C3 14 21 04 0068*       jp @print_loop
042124 C9          0069*       ret
042125             0070*   ; end printStringGfx
042125             0071*   
042125             0072*   ; Print a 24-bit HEX number
042125             0073*   ; HLU: Number to print
042125             0074*   printHex24:
042125             0075*       HLU_TO_A
                       M1 Args: none
042125 3B          0001*M1     dec sp ; 1 cycle
042126 E5          0002*M1     push hl ; 4 cycles
042127 33          0003*M1     inc sp ; 1 cycle
042128 F1          0004*M1     pop af ; 4 cycles
042129             0005*M1     ; 10 cycles total
042129 CD 33 21 04 0076*       CALL printHex8
04212D             0077*   ; Print a 16-bit HEX number
04212D             0078*   ; HL: Number to print
04212D             0079*   printHex16:
04212D 7C          0080*       LD A,H
04212E CD 33 21 04 0081*       CALL printHex8
042132 7D          0082*       LD A,L
042133             0083*   ; Print an 8-bit HEX number
042133             0084*   ; A: Number to print
042133             0085*   printHex8:
042133 4F          0086*       LD C,A
042134 1F          0087*       RRA
042135 1F          0088*       RRA
042136 1F          0089*       RRA
042137 1F          0090*       RRA
042138 CD 3D 21 04 0091*       CALL @F
04213C 79          0092*       LD A,C
04213D             0093*   @@:
04213D E6 0F       0094*       AND 0Fh
04213F C6 90       0095*       ADD A,90h
042141 27          0096*       DAA
042142 CE 40       0097*       ADC A,40h
042144 27          0098*       DAA
042145 5B D7       0099*       RST.LIL 10h
042147 C9          0100*       RET
042148             0101*   
042148             0102*   ; Print a 0x HEX prefix
042148             0103*   DisplayHexPrefix:
042148 3E 30       0104*       LD A, '0'
04214A 5B D7       0105*       RST.LIL 10h
04214C 3E 78       0106*       LD A, 'x'
04214E 5B D7       0107*       RST.LIL 10h
042150 C9          0108*       RET
042151             0109*   
042151             0110*       MACRO printDecBC
042151             0111*       push hl
042151             0112*       push bc
042151             0113*       pop hl
042151             0114*       call printDec
042151             0115*       pop hl
042151             0116*       ENDMACRO
042151             0117*   
042151             0118*       MACRO printDecDE
042151             0119*       push hl
042151             0120*       push de
042151             0121*       pop hl
042151             0122*       call printDec
042151             0123*       pop hl
042151             0124*       ENDMACRO
042151             0125*   
042151             0126*       MACRO printDecHL
042151             0127*       call printDec
042151             0128*       ENDMACRO
042151             0129*   
042151             0130*       MACRO printDecIX
042151             0131*       push hl
042151             0132*       push ix
042151             0133*       pop hl
042151             0134*       call printDec
042151             0135*       pop hl
042151             0136*       ENDMACRO
042151             0137*   
042151             0138*       MACRO printDecIY
042151             0139*       push hl
042151             0140*       push iy
042151             0141*       pop hl
042151             0142*       call printDec
042151             0143*       pop hl
042151             0144*       ENDMACRO
042151             0145*   
042151             0146*   
042151             0147*   ; Prints the right justified decimal value in UHL without leading zeroes
042151             0148*   ; UHL : Value to print
042151             0149*   ; preserves all registers and flags
042151             0150*   printDec:
042151             0151*   ; back up all the things
042151 F5          0152*       push af
042152 C5          0153*       push bc
042153 D5          0154*       push de
042154 E5          0155*       push hl
042155 11 7D 21 04 0156*       LD DE, _printDecBuffer
042159 CD 29 22 04 0157*       CALL u24_to_ascii
04215D             0158*   ; replace leading zeroes with spaces
04215D 21 7D 21 04 0159*       LD HL, _printDecBuffer
042161 06 07       0160*       ld B, 7 ; if HL was 0, we want to keep the final zero
042163             0161*   @loop:
042163 7E          0162*       LD A, (HL)
042164 FE 30       0163*       CP '0'
042166 C2 70 21 04 0164*       JP NZ, @done
04216A 3E 20       0165*       LD A, ' '
04216C 77          0166*       LD (HL), A
04216D 23          0167*       INC HL
04216E 10 F3       0168*       DJNZ @loop
042170             0169*   @done:
042170 21 7D 21 04 0170*       LD HL, _printDecBuffer
042174 CD EC 20 04 0171*       CALL printString
042178             0172*   ; restore all the things
042178 E1          0173*       pop hl
042179 D1          0174*       pop de
04217A C1          0175*       pop bc
04217B F1          0176*       pop af
04217C C9          0177*       RET
04217D 00 00 00 00 0178*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04218D 00 00 00 00 0179*   _printDec168Buffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04219D             0180*   
04219D             0181*   ; same as printDec but signed
04219D             0182*   printDecS:
04219D             0183*   ; back up all the things
04219D F5          0184*       push af
04219E C5          0185*       push bc
04219F D5          0186*       push de
0421A0 E5          0187*       push hl
0421A1 CD 08 25 04 0188*       call hlu_abs ; abs(hl), sign flag set if negative
0421A5 F5          0189*       push af ; save sign flag
0421A6 11 7D 21 04 0190*       LD DE, _printDecBuffer
0421AA CD 29 22 04 0191*       CALL u24_to_ascii
0421AE             0192*   ; replace leading zeroes with spaces
0421AE 21 7D 21 04 0193*       LD HL, _printDecBuffer
0421B2 06 07       0194*       ld B, 7 ; if HL was 0, we want to keep the final zero
0421B4 F1          0195*       pop af ; restore sign flag
0421B5 3E 20       0196*       ld a,' ' ; assume positive
0421B7 F2 BD 21 04 0197*       jp p,@print
0421BB 3E 2D       0198*       ld a,'-'
0421BD             0199*   @print:
0421BD 5B D7       0200*       rst.lil 10h
0421BF             0201*   @loop:
0421BF 7E          0202*       LD A, (HL)
0421C0 FE 30       0203*       CP '0'
0421C2 C2 CC 21 04 0204*       JP NZ, @done
0421C6 3E 20       0205*       LD A, ' '
0421C8 77          0206*       LD (HL), A
0421C9 23          0207*       INC HL
0421CA 10 F3       0208*       DJNZ @loop
0421CC             0209*   @done:
0421CC 21 7D 21 04 0210*       LD HL, _printDecBuffer
0421D0 CD EC 20 04 0211*       CALL printString
0421D4             0212*   ; restore all the things
0421D4 E1          0213*       pop hl
0421D5 D1          0214*       pop de
0421D6 C1          0215*       pop bc
0421D7 F1          0216*       pop af
0421D8 C9          0217*       RET
0421D9             0218*   
0421D9             0219*   printDec8:
0421D9             0220*   ; back up all the things
0421D9 F5          0221*       push af
0421DA C5          0222*       push bc
0421DB D5          0223*       push de
0421DC E5          0224*       push hl
0421DD             0225*   ; initialize hl to 0 and load it with a
0421DD 21 00 00 00 0226*       ld hl,0
0421E1 6F          0227*       ld l,a
0421E2             0228*   ; convert l to ascii
0421E2 11 7D 21 04 0229*       LD DE, _printDecBuffer
0421E6 CD 49 22 04 0230*       CALL u8_to_ascii
0421EA             0231*   ; replace leading zeroes with spaces
0421EA 21 7D 21 04 0232*       LD HL, _printDecBuffer
0421EE 06 03       0233*       ld B, 3 ; if A was 0, we want to keep the final zero
0421F0             0234*   @loop:
0421F0 7E          0235*       LD A, (HL)
0421F1 FE 30       0236*       CP '0'
0421F3 C2 FD 21 04 0237*       JP NZ, @done
0421F7 3E 20       0238*       LD A, ' '
0421F9 77          0239*       LD (HL), A
0421FA 23          0240*       INC HL
0421FB 10 F3       0241*       DJNZ @loop
0421FD             0242*   @done:
0421FD 21 7E 21 04 0243*       LD HL, _printDecBuffer+1
042201 CD EC 20 04 0244*       CALL printString
042205             0245*   ; restore all the things
042205 E1          0246*       pop hl
042206 D1          0247*       pop de
042207 C1          0248*       pop bc
042208 F1          0249*       pop af
042209 C9          0250*       RET
04220A             0251*   ; end printDec8
04220A             0252*   
04220A             0253*   printDecS8:
04220A F5          0254*       push af
04220B CB 7F       0255*       bit 7,a
04220D 28 0E       0256*       jr z,@F
04220F ED 44       0257*       neg
042211 F5          0258*       push af
042212 3E 2D       0259*       ld a,'-'
042214 5B D7       0260*       rst.lil 10h
042216 F1          0261*       pop af
042217 CD D9 21 04 0262*       call printDec8
04221B F1          0263*       pop af
04221C C9          0264*       ret
04221D             0265*   @@:
04221D F5          0266*       push af
04221E 3E 2B       0267*       ld a,'+'
042220 5B D7       0268*       rst.lil 10h
042222 F1          0269*       pop af
042223 CD D9 21 04 0270*       call printDec8
042227 F1          0271*       pop af
042228 C9          0272*       ret
042229             0273*   
042229             0274*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
042229             0275*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
042229             0276*   ; so it will allways be 8 characters length
042229             0277*   ; HL : Value to convert to string
042229             0278*   ; DE : pointer to buffer, at least 8 byte + 0
042229             0279*   u24_to_ascii:
042229 01 80 69 67 0280*       LD BC,-10000000
04222D CD 60 22 04 0281*       CALL one_digit
042231 01 C0 BD F0 0282*       LD BC,-1000000
042235 CD 60 22 04 0283*       CALL one_digit
042239 01 60 79 FE 0284*       LD BC,-100000
04223D CD 60 22 04 0285*       CALL one_digit
042241 01 F0 D8 FF 0286*       LD BC,-10000
042245 CD 60 22 04 0287*       CALL one_digit
042249             0288*   u8_to_ascii: ; same arguments but hl <= 255, uhl and h = 0
042249 01 18 FC FF 0289*       LD BC,-1000
04224D CD 60 22 04 0290*       CALL one_digit
042251 01 9C FF FF 0291*       LD BC,-100
042255 CD 60 22 04 0292*       CALL one_digit
042259 0E F6       0293*       LD C,-10
04225B CD 60 22 04 0294*       CALL one_digit
04225F 48          0295*       LD C,B
042260             0296*   one_digit:
042260 3E 2F       0297*       LD A,'0'-1
042262             0298*   @divide_me:
042262 3C          0299*       INC A
042263 09          0300*       ADD HL,BC
042264 38 FC       0301*       JR C,@divide_me
042266 ED 42       0302*       SBC HL,BC
042268 12          0303*       LD (DE),A
042269 13          0304*       INC DE
04226A C9          0305*       RET
04226B             0306*   
04226B             0307*   print_u24:
04226B D5          0308*       push de
04226C E5          0309*       push hl
04226D 11 7D 21 04 0310*       ld de,_printDecBuffer
042271 CD 29 22 04 0311*       call u24_to_ascii
042275 21 7D 21 04 0312*       ld hl,_printDecBuffer
042279 CD EC 20 04 0313*       call printString
04227D 3E 20       0314*       ld a,' '
04227F 5B D7       0315*       rst.lil 10h
042281 E1          0316*       pop hl
042282 D1          0317*       pop de
042283 C9          0318*       ret
042284             0319*   
042284             0320*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
042284             0321*   ; HL : Value to convert to string (integer part in H, fractional part in L)
042284             0322*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
042284             0323*   u168_to_ascii:
042284             0324*   ; add a leading space to make room for sign flag if needed
042284 3E 20       0325*       ld a,' '
042286 12          0326*       ld (de),a
042287 13          0327*       inc de
042288             0328*   ; Convert integer part
042288 E5          0329*       push hl ; Save HL (well need the fractional part later)
042289             0330*       ; call hlu_udiv256 ; Shift to get integer portion in HL
042289             0331*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
042289 3B          0001*M1     dec sp ; 1 cycle
04228A E5          0002*M1     push hl ; 4 cycles
04228B 33          0003*M1     inc sp ; 1 cycle
04228C E1          0004*M1     pop hl ; 4 cycles
04228D 23          0005*M1     inc hl ; 1 cycle
04228E 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
042290             0007*M1     ; 13 cycles total
042290 01 F0 D8 FF 0332*       ld bc, -10000
042294 CD B7 22 04 0333*       call @one_int
042298 01 18 FC FF 0334*       ld bc, -1000
04229C CD B7 22 04 0335*       call @one_int
0422A0 01 9C FF FF 0336*       ld bc, -100
0422A4 CD B7 22 04 0337*       call @one_int
0422A8 0E F6       0338*       ld c, -10
0422AA CD B7 22 04 0339*       call @one_int
0422AE 48          0340*       ld c, b
0422AF CD B7 22 04 0341*       call @one_int
0422B3 C3 C2 22 04 0342*       jp @frac ; Jump to fractional part conversion
0422B7             0343*   @one_int:
0422B7 3E 2F       0344*       ld a, '0' - 1 ; Start ASCII character at '0'
0422B9             0345*   @divide_me:
0422B9 3C          0346*       inc a
0422BA 09          0347*       add hl, bc ; Accumulate until overflow
0422BB 38 FC       0348*       jr c, @divide_me
0422BD ED 42       0349*       sbc hl, bc ; Remove excess after overflow
0422BF 12          0350*       ld (de), a ; Store ASCII digit
0422C0 13          0351*       inc de
0422C1 C9          0352*       ret
0422C2             0353*   ; Convert fractional part
0422C2             0354*   @frac:
0422C2 3E 2E       0355*       ld a, '.' ; Decimal point
0422C4 12          0356*       ld (de), a
0422C5 13          0357*       inc de
0422C6 E1          0358*       pop hl ; Restore HL with original fraction
0422C7 06 03       0359*       ld b, 3 ; Loop counter for 3 fractional digits
0422C9             0360*   @frac_loop:
0422C9 26 0A       0361*       ld h, 10 ; Load multiplier for fractional part
0422CB ED 6C       0362*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0422CD 3E 30       0363*       ld a, '0'
0422CF 84          0364*       add a, h ; Convert integer part to ASCII
0422D0 12          0365*       ld (de), a
0422D1 13          0366*       inc de
0422D2 10 F5       0367*       djnz @frac_loop ; Repeat for each fractional digit
0422D4             0368*   ; Add null terminator
0422D4 AF          0369*       xor a ; Null terminator
0422D5 12          0370*       ld (de), a
0422D6 C9          0371*       ret
0422D7             0372*   
0422D7             0373*   print_u168:
0422D7 D5          0374*       push de
0422D8 E5          0375*       push hl
0422D9 11 7D 21 04 0376*       ld de,_printDecBuffer
0422DD CD 84 22 04 0377*       call u168_to_ascii
0422E1 21 7D 21 04 0378*       ld hl,_printDecBuffer
0422E5 CD EC 20 04 0379*       call printString
0422E9 E1          0380*       pop hl
0422EA D1          0381*       pop de
0422EB C9          0382*       ret
0422EC             0383*   
0422EC             0384*   ; signed version of u168_to_ascii
0422EC             0385*   s168_to_ascii:
0422EC D5          0386*       push de ; save starting address of buffer
0422ED CD 08 25 04 0387*       call hlu_abs
0422F1 F5          0388*       push af ; save sign flag
0422F2 CD 84 22 04 0389*       call u168_to_ascii
0422F6 F1          0390*       pop af ; restore sign flag
0422F7 D1          0391*       pop de ; restore starting address of buffer
0422F8 F0          0392*       ret p ; hlu was positive so nothing to do
0422F9 3E 2D       0393*       ld a,'-'
0422FB 12          0394*       ld (de),a
0422FC C9          0395*       ret
0422FD             0396*   
0422FD             0397*   print_s168:
0422FD D5          0398*       push de
0422FE E5          0399*       push hl
0422FF 11 8D 21 04 0400*       ld de,_printDec168Buffer
042303 CD EC 22 04 0401*       call s168_to_ascii
042307 21 8D 21 04 0402*       ld hl,_printDec168Buffer
04230B CD EC 20 04 0403*       call printString
04230F E1          0404*       pop hl
042310 D1          0405*       pop de
042311 C9          0406*       ret
042312             0407*   
042312             0408*   print_s168_hl:
042312 F5          0409*       push af
042313 E5          0410*       push hl
042314 CD FD 22 04 0411*       call print_s168
042318 3E 20       0412*       ld a,' '
04231A 5B D7       0413*       rst.lil 10h
04231C E1          0414*       pop hl
04231D F1          0415*       pop af
04231E C9          0416*       ret
04231F             0417*   
04231F             0418*   print_s168_bc:
04231F F5          0419*       push af
042320 C5          0420*       push bc
042321 E5          0421*       push hl
042322 C5          0422*       push bc
042323 E1          0423*       pop hl
042324 CD FD 22 04 0424*       call print_s168
042328 3E 20       0425*       ld a,' '
04232A 5B D7       0426*       rst.lil 10h
04232C E1          0427*       pop hl
04232D C1          0428*       pop bc
04232E F1          0429*       pop af
04232F C9          0430*       ret
042330             0431*   
042330             0432*   print_s168_de:
042330 F5          0433*       push af
042331 D5          0434*       push de
042332 E5          0435*       push hl
042333 EB          0436*       ex de,hl
042334 CD FD 22 04 0437*       call print_s168
042338 3E 20       0438*       ld a,' '
04233A 5B D7       0439*       rst.lil 10h
04233C E1          0440*       pop hl
04233D D1          0441*       pop de
04233E F1          0442*       pop af
04233F C9          0443*       ret
042340             0444*   
042340             0445*   print_s168_hl_bc_de:
042340 F5          0446*       push af
042341 C5          0447*       push bc
042342 D5          0448*       push de
042343 E5          0449*       push hl
042344 CD FD 22 04 0450*       call print_s168
042348 3E 20       0451*       ld a,' '
04234A 5B D7       0452*       rst.lil 10h
04234C C5          0453*       push bc
04234D E1          0454*       pop hl
04234E CD FD 22 04 0455*       call print_s168
042352 3E 20       0456*       ld a,' '
042354 5B D7       0457*       rst.lil 10h
042356 EB          0458*       ex de,hl
042357 CD FD 22 04 0459*       call print_s168
04235B 3E 20       0460*       ld a,' '
04235D 5B D7       0461*       rst.lil 10h
04235F E1          0462*       pop hl
042360 D1          0463*       pop de
042361 C1          0464*       pop bc
042362 F1          0465*       pop af
042363 C9          0466*       ret
042364             0467*   
042364             0468*   print_s168_bc_de:
042364 F5          0469*       push af
042365 C5          0470*       push bc
042366 D5          0471*       push de
042367 C5          0472*       push bc
042368 E1          0473*       pop hl
042369 CD FD 22 04 0474*       call print_s168
04236D 3E 20       0475*       ld a,' '
04236F 5B D7       0476*       rst.lil 10h
042371 EB          0477*       ex de,hl
042372 CD FD 22 04 0478*       call print_s168
042376 3E 20       0479*       ld a,' '
042378 5B D7       0480*       rst.lil 10h
04237A E1          0481*       pop hl
04237B D1          0482*       pop de
04237C C1          0483*       pop bc
04237D F1          0484*       pop af
04237E C9          0485*       ret
04237F             0486*   
04237F             0487*   print_s168_a:
04237F F5          0488*       push af
042380 C5          0489*       push bc
042381 E5          0490*       push hl
042382 21 00 00 00 0491*       ld hl,0
042386 6F          0492*       ld l,a
042387 CD 12 23 04 0493*       call print_s168_hl
04238B E1          0494*       pop hl
04238C C1          0495*       pop bc
04238D F1          0496*       pop af
04238E C9          0497*       ret
04238F             0498*   
04238F             0499*   ; #### new functions added by Brandon R. Gates ####
04238F             0500*   
04238F             0501*   ; print the binary representation of the 8-bit value in a
04238F             0502*   printBin8:
04238F F5          0503*       push af
042390 E5          0504*       push hl
042391 C5          0505*       push bc
042392 D5          0506*       push de ; TOD0: WHY?
042393 06 08       0507*       ld b,8 ; loop counter for 8 bits
042395 21 B4 23 04 0508*       ld hl,@cmd ; set hl to the low byte of the output string
042399             0509*       ; (which will be the high bit of the value in a)
042399             0510*   @loop:
042399 07          0511*       rlca ; put the next highest bit into carry
04239A 38 04       0512*       jr c,@one
04239C 36 30       0513*       ld (hl),'0'
04239E 18 02       0514*       jr @next_bit
0423A0             0515*   @one:
0423A0 36 31       0516*       ld (hl),'1'
0423A2             0517*   @next_bit:
0423A2 23          0518*       inc hl
0423A3 10 F4       0519*       djnz @loop
0423A5             0520*   ; print it
0423A5 21 B4 23 04 0521*       ld hl,@cmd
0423A9 01 08 00 00 0522*       ld bc,@end-@cmd
0423AD 5B DF       0523*       rst.lil $18
0423AF D1          0524*       pop de
0423B0 C1          0525*       pop bc
0423B1 E1          0526*       pop hl
0423B2 F1          0527*       pop af
0423B3 C9          0528*       ret
0423B4             0529*   @cmd: ds 8 ; eight bytes for eight bits
0423BC             0530*   @end:
0423BC             0531*   
0423BC             0532*   printBinUHL:
0423BC             0533*       PUSH_ALL
                       M1 Args: none
       FF FF FF FF 
       FF FF FF FF 
0423BC 08          0001*M1     ex af,af'
0423BD D9          0002*M1     exx
0423BE F5          0003*M1     push af
0423BF E5          0004*M1     push hl
0423C0 C5          0005*M1     push bc
0423C1 D5          0006*M1     push de
0423C2             0007*M1 
0423C2 08          0008*M1     ex af,af'
0423C3 D9          0009*M1     exx
0423C4 F5          0010*M1     push af
0423C5 E5          0011*M1     push hl
0423C6 C5          0012*M1     push bc
0423C7 D5          0013*M1     push de
0423C8 DD E5       0014*M1     push ix
0423CA FD E5       0015*M1     push iy
0423CC             0534*       HLU_TO_A
                       M1 Args: none
0423CC 3B          0001*M1     dec sp ; 1 cycle
0423CD E5          0002*M1     push hl ; 4 cycles
0423CE 33          0003*M1     inc sp ; 1 cycle
0423CF F1          0004*M1     pop af ; 4 cycles
0423D0             0005*M1     ; 10 cycles total
0423D0 CD 8F 23 04 0535*       call printBin8
0423D4 3E 20       0536*       ld a,' '
0423D6 5B D7       0537*       rst.lil 10h
0423D8 7C          0538*       ld a,h
0423D9 CD 8F 23 04 0539*       call printBin8
0423DD 3E 20       0540*       ld a,' '
0423DF 5B D7       0541*       rst.lil 10h
0423E1 7D          0542*       ld a,l
0423E2 CD 8F 23 04 0543*       call printBin8
0423E6 3E 20       0544*       ld a,' '
0423E8 5B D7       0545*       rst.lil 10h
0423EA             0546*       POP_ALL
                       M1 Args: none
0423EA FD E1       0001*M1     pop iy
0423EC DD E1       0002*M1     pop ix
0423EE D1          0003*M1     pop de
0423EF C1          0004*M1     pop bc
0423F0 E1          0005*M1     pop hl
0423F1 F1          0006*M1     pop af
0423F2 08          0007*M1     ex af,af'
0423F3 D9          0008*M1     exx
0423F4             0009*M1 
0423F4 D1          0010*M1     pop de
0423F5 C1          0011*M1     pop bc
0423F6 E1          0012*M1     pop hl
0423F7 F1          0013*M1     pop af
0423F8 08          0014*M1     ex af,af'
0423F9 D9          0015*M1     exx
0423FA C9          0547*       ret
0423FB             0548*   
0423FB             0549*   printBinHL:
0423FB             0550*       PUSH_ALL
                       M1 Args: none
0423FB 08          0001*M1     ex af,af'
0423FC D9          0002*M1     exx
0423FD F5          0003*M1     push af
0423FE E5          0004*M1     push hl
0423FF C5          0005*M1     push bc
042400 D5          0006*M1     push de
042401             0007*M1 
042401 08          0008*M1     ex af,af'
042402 D9          0009*M1     exx
042403 F5          0010*M1     push af
042404 E5          0011*M1     push hl
042405 C5          0012*M1     push bc
042406 D5          0013*M1     push de
042407 DD E5       0014*M1     push ix
042409 FD E5       0015*M1     push iy
04240B 7C          0551*       ld a,h
04240C CD 8F 23 04 0552*       call printBin8
042410 3E 20       0553*       ld a,' '
042412 5B D7       0554*       rst.lil 10h
042414 7D          0555*       ld a,l
042415 CD 8F 23 04 0556*       call printBin8
042419 3E 20       0557*       ld a,' '
04241B 5B D7       0558*       rst.lil 10h
04241D             0559*       POP_ALL
                       M1 Args: none
04241D FD E1       0001*M1     pop iy
04241F DD E1       0002*M1     pop ix
042421 D1          0003*M1     pop de
042422 C1          0004*M1     pop bc
042423 E1          0005*M1     pop hl
042424 F1          0006*M1     pop af
042425 08          0007*M1     ex af,af'
042426 D9          0008*M1     exx
042427             0009*M1 
042427 D1          0010*M1     pop de
042428 C1          0011*M1     pop bc
042429 E1          0012*M1     pop hl
04242A F1          0013*M1     pop af
04242B 08          0014*M1     ex af,af'
04242C D9          0015*M1     exx
04242D C9          0560*       ret
04242E             0561*   
04242E             0562*   ; print the binary representation of the 8-bit value in a
04242E             0563*   ; in reverse order (lsb first)
04242E             0564*   ; destroys a, hl, bc
04242E             0565*   printBin8Rev:
04242E 06 08       0566*       ld b,8 ; loop counter for 8 bits
042430 21 4B 24 04 0567*       ld hl,@cmd ; set hl to the low byte of the output string
042434             0568*       ; (which will be the high bit of the value in a)
042434             0569*   @loop:
042434 0F          0570*       rrca ; put the next lowest bit into carry
042435 38 04       0571*       jr c,@one
042437 36 30       0572*       ld (hl),'0'
042439 18 02       0573*       jr @next_bit
04243B             0574*   @one:
04243B 36 31       0575*       ld (hl),'1'
04243D             0576*   @next_bit:
04243D 23          0577*       inc hl
04243E 10 F4       0578*       djnz @loop
042440             0579*   ; print it
042440 21 4B 24 04 0580*       ld hl,@cmd
042444 01 08 00 00 0581*       ld bc,@end-@cmd
042448 5B DF       0582*       rst.lil $18
04244A C9          0583*       ret
04244B             0584*   @cmd: ds 8 ; eight bytes for eight bits
042453             0585*   @end:
042453             0586*   
       FF FF FF FF 
       FF FF FF FF 
042453 20 61 66 3D 0587*   str_afu: db " af=",0
       00          
042458 20 68 6C 3D 0588*   str_hlu: db " hl=",0
       00          
04245D 20 62 63 3D 0589*   str_bcu: db " bc=",0
       00          
042462 20 64 65 3D 0590*   str_deu: db " de=",0
       00          
042467 20 69 78 3D 0591*   str_ixu: db " ix=",0
       00          
04246C 20 69 79 3D 0592*   str_iyu: db " iy=",0
       00          
042471             0593*   
042471             0594*   ; print udeuhl to screen in hexidecimal format
042471             0595*   ; inputs: none
042471             0596*   ; outputs: concatenated hexidecimal udeuhl
042471             0597*   ; destroys: nothing
042471             0598*   dumpUDEUHLHex:
042471             0599*   ; store everything in scratch
042471 22 D0 24 04 0600*       ld (uhl),hl
042475 ED 43 D3 24 0601*       ld (ubc),bc
       04          
04247A ED 53 D6 24 0602*       ld (ude),de
       04          
04247F DD 22 D9 24 0603*       ld (uix),ix
       04          
042484 FD 22 DC 24 0604*       ld (uiy),iy
       04          
042489 F5          0605*       push af
04248A             0606*   
04248A             0607*   ; print each register
04248A             0608*   
04248A 21 C4 24 04 0609*       ld hl,str_udeuhl
04248E CD EC 20 04 0610*       call printString
042492 2A D6 24 04 0611*       ld hl,(ude)
042496 CD 25 21 04 0612*       call printHex24
04249A 3E 2E       0613*       ld a,'.' ; print a dot to separate the values
04249C 5B D7       0614*       rst.lil 10h
04249E 2A D0 24 04 0615*       ld hl,(uhl)
0424A2 CD 25 21 04 0616*       call printHex24
0424A6 CD 01 21 04 0617*       call printNewLine
0424AA             0618*   
0424AA             0619*   ; restore everything
0424AA 2A D0 24 04 0620*       ld hl, (uhl)
0424AE ED 4B D3 24 0621*       ld bc, (ubc)
       04          
0424B3 ED 5B D6 24 0622*       ld de, (ude)
       04          
0424B8 DD 2A D9 24 0623*       ld ix, (uix)
       04          
0424BD FD 2A DC 24 0624*       ld iy, (uiy)
       04          
0424C2 F1          0625*       pop af
0424C3             0626*   ; all done
0424C3 C9          0627*       ret
0424C4             0628*   
0424C4 75 64 65 2E 0629*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0424CD             0630*   
0424CD             0631*   ; global scratch memory for registers
0424CD 00 00 00    0632*   uaf: dl 0
0424D0 00 00 00    0633*   uhl: dl 0
0424D3 00 00 00    0634*   ubc: dl 0
0424D6 00 00 00    0635*   ude: dl 0
0424D9 00 00 00    0636*   uix: dl 0
0424DC 00 00 00    0637*   uiy: dl 0
0424DF 00 00 00    0638*   usp: dl 0
0424E2 00 00 00    0639*   upc: dl 0
0424E5             0640*   
0424E5             0641*   
0424E5             0642*   ; set all the bits in the flag register
0424E5             0643*   ; more of an academic exercise than anything useful
0424E5             0644*   ; inputs; none
0424E5             0645*   ; outputs; a=0,f=255
0424E5             0646*   ; destroys: flags, hl
0424E5             0647*   ; preserves: a, because why not
0424E5             0648*   setAllFlags:
0424E5 21 FF 00 00 0649*       ld hl,255
0424E9 67          0650*       ld h,a ; four cycles to preserve a is cheap
0424EA E5          0651*       push hl
0424EB F1          0652*       pop af
0424EC C9          0653*       ret
0424ED             0654*   
0424ED             0655*   ; reset all the bits in the flag register
0424ED             0656*   ; unlike its inverse counterpart, this may actually be useful
0424ED             0657*   ; inputs; none
0424ED             0658*   ; outputs; a=0,f=0
0424ED             0659*   ; destroys: flags, hl
0424ED             0660*   ; preserves: a, because why not
0424ED             0661*   resetAllFlags:
0424ED 21 00 00 00 0662*       ld hl,0
0424F1 67          0663*       ld h,a ; four cycles to preserve a is cheap
0424F2 E5          0664*       push hl
0424F3 F1          0665*       pop af
0424F4 C9          0666*       ret
0424F5             0667*   
0424F5             0668*   ; wait until user presses a key
0424F5             0669*   ; inputs: none
0424F5             0670*   ; outputs: ascii code of key pressed in a
0424F5             0671*   ; destroys: af,ix
0424F5             0672*   waitKeypress:
0424F5             0673*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
0424F5 3E 00       0001*M1 			LD	A, function
0424F7 5B CF       0002*M1 			RST.LIL	08h
0424F9 C9          0674*       ret
0424FA             0675*   
0424FA             0676*   ; clear a block of memory by writing a prescribed value to each byte in the range
0424FA             0677*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
0424FA             0678*   ; outputs: memory block is cleared
0424FA             0679*   ; destroys: hl, bc, de
0424FA             0680*   clear_mem:
0424FA 0B          0681*       dec bc ; we do this because we will increment de before writing the first byte
0424FB 77          0682*       ld (hl),a
0424FC E5          0683*       push hl
0424FD D1          0684*       pop de
0424FE 13          0685*       inc de ; target address
0424FF ED B0       0686*       ldir
042501 C9          0687*       ret
042502             0036        include "../agon/maths.inc"
042502             0001*   ;------------------------------------------------------------------------
042502             0002*   ; Scratch area for calculations
042502             0003*   ;------------------------------------------------------------------------
042502 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
042505 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
042508             0006*   
042508             0007*   ; absolute value of hlu
042508             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
042508             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
042508             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
042508             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
042508             0012*   ; destroys: a
042508             0013*   hlu_abs:
042508 19          0014*       add hl,de
042509 B7          0015*       or a
04250A ED 52       0016*       sbc hl,de
04250C FA 11 25 04 0017*       jp m,@is_neg
042510 C9          0018*       ret ; hlu is positive or zero so we're done
042511             0019*   @is_neg:
042511 F5          0020*       push af ; otherwise, save current flags for return
042512 CD 18 25 04 0021*       call neg_hlu ; negate hlu
042516 F1          0022*       pop af ; get back flags
042517 C9          0023*       ret
042518             0024*   
042518             0025*   ; flip the sign of hlu
042518             0026*   ; inputs: hlu
042518             0027*   ; returns: 0-hlu, flags set appropriately for the result:
042518             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
042518             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
042518             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
042518             0031*   ; destroys a
042518             0032*   neg_hlu:
042518 D5          0033*       push de ; save de
042519 EB          0034*       ex de,hl ; put hl into de
04251A 21 00 00 00 0035*       ld hl,0 ; clear hl
04251E AF          0036*       xor a ; clear carry
04251F ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
042521 D1          0038*       pop de ; get de back
042522 C9          0039*       ret ; easy peasy
042523             0040*   
042523             0041*   ;------------------------------------------------------------------------
042523             0042*   ; divide hlu by 2, inspired by above
042523             0043*   ;------------------------------------------------------------------------
042523             0044*   hlu_div2:
042523 22 02 25 04 0045*       ld (scratch1),hl
042527 21 04 25 04 0046*       ld hl,scratch1+2
04252B CB 1E       0047*       rr (hl)
04252D 2B          0048*       dec hl
04252E CB 1E       0049*       rr (hl)
042530 2B          0050*       dec hl
042531 CB 1E       0051*       rr (hl)
042533 23          0052*       inc hl
042534 23          0053*       inc hl
042535 2A 02 25 04 0054*       ld hl,(scratch1)
042539 C9          0055*       ret
04253A             0056*   
04253A             0057*   ; this is my little hack to divide by 16
04253A             0058*   hlu_div16:
04253A AF          0059*       xor a
04253B 29          0060*       add hl,hl
04253C 17          0061*       rla
04253D 29          0062*       add hl,hl
04253E 17          0063*       rla
04253F 29          0064*       add hl,hl
042540 17          0065*       rla
042541 29          0066*       add hl,hl
042542 17          0067*       rla
042543 22 50 25 04 0068*       ld (@scratch),hl
042547 32 53 25 04 0069*       ld (@scratch+3),a
04254B 2A 51 25 04 0070*       ld hl,(@scratch+1)
04254F C9          0071*       ret
042550             0072*   @scratch: ds 4
042554             0073*   
042554             0074*   ; hlu signed division by 256
042554             0075*   ; returns: hlu / 256
042554             0076*   ; destroys: af
042554             0077*   hlu_sdiv256:
       FF FF FF FF 
042554 AF          0078*       xor a ; assume hl is positive
042555 22 6B 25 04 0079*       ld (@buffer),hl
042559             0080*       SIGN_UHL
                       M1 Args: none
042559 19          0001*M1     add hl,de ; 1 cycle
04255A B7          0002*M1     or a ; clear flags ; 1 cycle
04255B ED 52       0003*M1     sbc hl,de ; 2 cycles
04255D             0004*M1     ; 4 cycles total
04255D F2 62 25 04 0081*       jp p,@hl_pos
042561 3D          0082*       dec a
042562             0083*   @hl_pos:
042562 32 6E 25 04 0084*       ld (@buffer+3),a
042566 2A 6C 25 04 0085*       ld hl,(@buffer+1)
04256A C9          0086*       ret
04256B             0087*   @buffer: ds 4
04256F             0088*   
04256F             0089*   ; hlu 1 byte right shift, unsigned
04256F             0090*   ; returns: hlu / 256, fractional portion in a
04256F             0091*   ; destroys: af
04256F             0092*   hlu_udiv256:
       FF FF FF FF 
04256F AF          0093*       xor a
042570 32 81 25 04 0094*       ld (@buffer+3),a
042574 7D          0095*       ld a,l ; save the fractional portion
042575 22 7E 25 04 0096*       ld (@buffer),hl
042579 2A 7F 25 04 0097*       ld hl,(@buffer+1)
04257D C9          0098*       ret
04257E             0099*   @buffer: ds 4
042582             0100*   
042582             0101*   ; floor(value,n)
042582             0102*   ; inputs: hl = value to floor, de = n
042582             0103*   ; outputs: hl = value floored to n
042582             0104*   ; destroys: af, hl, bc, de
042582             0105*   hlu_floor:
       FF FF FF FF 
042582 D5          0106*       push de ; save n
042583 CD 24 04 04 0107*       call udiv24 ; de = quotient, hl = remainder
042587 E1          0108*       pop hl ; get n back (was de)
042588 CD 0B 04 04 0109*       call umul24 ; hl = n * quotient
04258C C9          0110*       ret
04258D             0111*   ; end hlu_floor
04258D             0112*   
04258D             0113*   ; ceil(value,n)
04258D             0114*   ; inputs: hl = value to ceil, de = n
04258D             0115*   ; outputs: hl = value ceiled to n
04258D             0116*   ; destroys: af, hl, bc, de
04258D             0117*   hlu_ceiling:
04258D D5          0118*       push de ; save n
04258E CD 24 04 04 0119*       call udiv24 ; de = quotient, hl = remainder
042592             0120*       SIGN_UHL ; test remaider for zero
                       M1 Args: none
042592 19          0001*M1     add hl,de ; 1 cycle
042593 B7          0002*M1     or a ; clear flags ; 1 cycle
042594 ED 52       0003*M1     sbc hl,de ; 2 cycles
042596             0004*M1     ; 4 cycles total
042596 CA 9B 25 04 0121*       jp z,@F ; if zero, nothing to add
04259A 13          0122*       inc de ; add 1 to quotient for the ceiling
04259B             0123*   @@:
04259B E1          0124*       pop hl ; get n back (was de)
04259C CD 0B 04 04 0125*       call umul24 ; hl = n * quotient
0425A0 C9          0126*       ret
0425A1             0127*   ; end hlu_ceiling
0425A1             0128*   
0425A1 C9          0129*       ret
0425A2             0130*   
0425A2 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
0425A6 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
0425AA             0133*   
0425AA             0134*   ; set bcd values in a scratch memory address from registers bcde
0425AA             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
0425AA             0136*   ; destroys ; hl
0425AA             0137*   set_bcd:
0425AA 73          0138*       ld (hl),e
0425AB 23          0139*       inc hl
0425AC 72          0140*       ld (hl),d
0425AD 23          0141*       inc hl
0425AE 71          0142*       ld (hl),c
0425AF 23          0143*       inc hl
0425B0 70          0144*       ld (hl),b
0425B1 C9          0145*       ret
0425B2             0146*   
0425B2             0147*   ; load bcd values from a scratch memory address to bcde
0425B2             0148*   ; input: hl; scratch address
0425B2             0149*   ; output: bcde; 8-place bcd number
0425B2             0150*   ; destroys: hl
0425B2             0151*   get_bcd:
0425B2 5E          0152*       ld e,(hl)
0425B3 23          0153*       inc hl
0425B4 56          0154*       ld d,(hl)
0425B5 23          0155*       inc hl
0425B6 4E          0156*       ld c,(hl)
0425B7 23          0157*       inc hl
0425B8 46          0158*       ld b,(hl)
0425B9 C9          0159*       ret
0425BA             0160*   
0425BA             0161*   ; BCD addition
0425BA             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0425BA             0163*   ;       a is the number of bytes holding each number (number of places/2)
0425BA             0164*   ; outputs: (hl) + (de) --> (hl)
0425BA             0165*   ; destroys: a,b,de,hl
0425BA             0166*   add_bcd:
0425BA 47          0167*       ld b,a ; loop counter
0425BB AF          0168*       xor a ; reset a, clear carry flag
0425BC             0169*   adcec:
0425BC 1A          0170*       ld a,(de) ; addend to acc
0425BD 8E          0171*       adc a,(hl) ; add (hl) to acc
0425BE 27          0172*       daa ; adjust result to bcd
0425BF 77          0173*       ld (hl),a ; store result
0425C0 23          0174*       inc hl ; advance memory pointers
0425C1 13          0175*       inc de
0425C2 10 F8       0176*       djnz adcec ; loop until b == 0
0425C4 C9          0177*       ret
0425C5             0178*   
0425C5             0179*   ; BCD subtraction
0425C5             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0425C5             0181*   ;       a is the number of bytes holding each number (number of places/2)
0425C5             0182*   ; outputs: (hl) - (de) --> (hl)
0425C5             0183*   ; destroys: a,b,de,hl
0425C5             0184*   sub_bcd:
0425C5 47          0185*       ld b,a ; loop counter
0425C6 AF          0186*       xor a ; reset a,clear carry flag
0425C7             0187*   subdec:
0425C7 1A          0188*       ld a,(de) ; subtrahend to acc
0425C8 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
0425C9 27          0190*       daa ; adjust result to bcd
0425CA 77          0191*       ld (hl),a ; store result
0425CB 23          0192*       inc hl ; advance memory pointers
0425CC 13          0193*       inc de
0425CD 10 F8       0194*       djnz subdec ; loop until b == 0
0425CF C9          0195*       ret
0425D0             0196*   
0425D0             0197*   ; http://www.z80.info/pseudo-random.txt
0425D0             0198*   rand_8:
0425D0 C5          0199*       push bc
0425D1 3A E4 25 04 0200*       ld a,(r_seed)
0425D5 4F          0201*       ld c,a
0425D6             0202*   
0425D6 0F          0203*       rrca ; multiply by 32
0425D7 0F          0204*       rrca
0425D8 0F          0205*       rrca
0425D9 EE 1F       0206*       xor 0x1f
0425DB             0207*   
0425DB 81          0208*       add a,c
0425DC DE FF       0209*       sbc a,255 ; carry
0425DE             0210*   
0425DE 32 E4 25 04 0211*       ld (r_seed),a
0425E2 C1          0212*       pop bc
0425E3 C9          0213*       ret
0425E4 50          0214*   r_seed: defb $50
0425E5             0215*   
0425E5             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
0425E5             0217*   prng24:
0425E5             0218*   ;;Expects ADL mode.
0425E5             0219*   ;;Output: HL
0425E5             0220*   ;;50cc
0425E5             0221*   ;;33 bytes
0425E5             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
0425E5 ED 5B 06 26 0223*       ld de,(seed1)
       04          
0425EA B7          0224*       or a
0425EB ED 62       0225*       sbc hl,hl
0425ED 19          0226*       add hl,de
0425EE 29          0227*       add hl,hl
0425EF 29          0228*       add hl,hl
0425F0 2C          0229*       inc l
0425F1 19          0230*       add hl,de
0425F2 22 06 26 04 0231*       ld (seed1),hl
0425F6 2A 09 26 04 0232*       ld hl,(seed2)
0425FA 29          0233*       add hl,hl
0425FB 9F          0234*       sbc a,a
0425FC E6 1B       0235*       and %00011011
0425FE AD          0236*       xor l
0425FF 6F          0237*       ld l,a
042600 22 09 26 04 0238*       ld (seed2),hl
042604 19          0239*       add hl,de
042605 C9          0240*       ret
042606 00 00 00    0241*   seed1: dl 0
042609 00 00 00    0242*   seed2: dl 0
04260C             0243*   
04260C             0244*   
04260C             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
04260C             0246*   ; h / l -> h, remain a
04260C             0247*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
04260C             0248*   ; Input: H = Dividend, L = Divisor, A = 0
04260C             0249*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
04260C             0250*   udiv8:
04260C AF          0251*       xor a
04260D 06 08       0252*       ld b,8
04260F             0253*   @loop:
04260F CB 24       0254*       sla h
042611 17          0255*       rla
042612 BD          0256*       cp l
042613 38 02       0257*       jr c,$+4
042615 95          0258*       sub l
042616 24          0259*       inc h
042617 10 F6       0260*       djnz @loop
042619 C9          0261*       ret
04261A             0262*   
04261A             0263*   ; https://www.omnimaga.org/asm-language/(z80)-32-bit-by-16-bits-division-and-32-bit-square-root/msg406903/#msg406903
04261A             0264*   ; This divides HLIX by BC
04261A             0265*   ; The result is stored in HLIX, the remainder in DE
04261A             0266*   ; BC is unmodified
04261A             0267*   ; A is 0
04261A             0268*   udiv3216:
04261A 11 00 00 00 0269*       ld de,0		; 10
04261E 3E 20       0270*       ld a,32		; 7
042620             0271*   @loop:
042620 52 DD 29    0272*       add.s ix,ix		; 15
042623 52 ED 6A    0273*       adc.s hl,hl		; 15
042626 EB          0274*       ex de,hl		; 4
042627 52 ED 6A    0275*       adc.s hl,hl		; 15
04262A B7          0276*       or a			; 4
04262B 52 ED 42    0277*       sbc.s hl,bc		; 15
04262E 52 DD 23    0278*       inc.s ix		; 10
042631 30 05       0279*       jr nc,@cansub		; 12/7
042633 52 09       0280*       add.s hl,bc		; 11
042635 52 DD 2B    0281*       dec.s ix		; 10
042638             0282*   @cansub:
042638 EB          0283*       ex de,hl		; 4
042639 3D          0284*       dec a		; 4
04263A 20 E4       0285*       jr nz,@loop	; 12/7
04263C C9          0286*       ret			; 10
04263D             0287*   ; end udiv3216
04263D             0288*   
04263D             0289*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1329274504022720512
04263D             0290*   ; calc84maniac's 32-bit by 23-bit division routine
04263D             0291*   ; This divides AUIX by UDE (maximum 23 bits)
04263D             0292*   ; The result is stored in AUIX, the remainder in UHL
04263D             0293*   ; UDE, C are unmodified
04263D             0294*   ; B is 0
04263D             0295*   udiv3223:
04263D B7          0296*       or a,a         ; 1
04263E ED 62       0297*       sbc hl,hl      ; 2
042640 06 20       0298*       ld b,32        ; 2
042642             0299*   @loop:
042642 DD 29       0300*       add ix,ix      ; 2
042644 8F          0301*       adc a,a        ; 1
042645 ED 6A       0302*       adc hl,hl      ; 2
042647 ED 52       0303*       sbc hl,de      ; 2
042649 DD 23       0304*       inc ix         ; 2
04264B 30 03       0305*       jr nc,@cansub  ; 2/4
04264D 19          0306*       add hl,de      ; 1
04264E DD 2B       0307*       dec ix         ; 2
042650             0308*   @cansub:
042650 10 F0       0309*       djnz @loop     ; 2/4
042652 C9          0310*       ret            ; 10
042653             0311*   ; end udiv3223
042653             0312*   
042653             0313*   ; calc84maniac https://discord.com/channels/1158535358624039014/1282290921815408681/1330991583369101322
042653             0314*   ; add uhl to signed integer a
042653             0315*   add_uhl_a_signed:
042653 D5          0316*       push de    ; 4 cycles
042654 EB          0317*       ex de, hl  ; 1 cycle  UDE = UHL
042655 07          0318*       rlca       ; 1 cycle  CF = signbit(A)
042656 ED 62       0319*       sbc hl, hl ; 2 cycles UHL = -signbit(A)
042658 0F          0320*       rrca       ; 1 cycle  Restore A
042659 6F          0321*       ld l, a    ; 1 cycle  UHL = signext(A)
04265A 19          0322*       add hl, de ; 1 cycle  UHL = UDE + signext(A)
04265B D1          0323*       pop de     ; 4 cycles
04265C             0324*                  ; 15 cycles total
04265C C9          0325*       ret
04265D             0326*   ; end hlu_add_a_signed
04265D             0327*   
04265D             0328*   
04265D             0329*   div_16x16_xeda:
04265D             0330*   ;;Inputs: DE is the numerator, BC is the divisor
04265D             0331*   ;;Outputs: DE is the result, HL is the remainder
04265D             0332*   ;;         A is a copy of E
04265D             0333*   ;;         BC is not changed
04265D             0334*   ;140 bytes
04265D             0335*   ;145cc
04265D AF          0336*       xor a
04265E 52 ED 62    0337*       sbc.s hl,hl
042661 7A          0338*       ld a,d
042662 17          0339*       rla
042663 52 ED 6A    0340*       adc.s hl,hl
042666 52 ED 42    0341*       sbc.s hl,bc
042669 30 02       0342*       jr nc,$+4
04266B 52 09       0343*       add.s hl,bc
04266D 17          0344*       rla
04266E 52 ED 6A    0345*       adc.s hl,hl
042671 52 ED 42    0346*       sbc.s hl,bc
042674 30 02       0347*       jr nc,$+4
042676 52 09       0348*       add.s hl,bc
042678 17          0349*       rla
042679 52 ED 6A    0350*       adc.s hl,hl
04267C 52 ED 42    0351*       sbc.s hl,bc
04267F 30 02       0352*       jr nc,$+4
042681 52 09       0353*       add.s hl,bc
042683 17          0354*       rla
042684 52 ED 6A    0355*       adc.s hl,hl
042687 52 ED 42    0356*       sbc.s hl,bc
04268A 30 02       0357*       jr nc,$+4
04268C 52 09       0358*       add.s hl,bc
04268E 17          0359*       rla
04268F 52 ED 6A    0360*       adc.s hl,hl
042692 52 ED 42    0361*       sbc.s hl,bc
042695 30 02       0362*       jr nc,$+4
042697 52 09       0363*       add.s hl,bc
042699 17          0364*       rla
04269A 52 ED 6A    0365*       adc.s hl,hl
04269D 52 ED 42    0366*       sbc.s hl,bc
0426A0 30 02       0367*       jr nc,$+4
0426A2 52 09       0368*       add.s hl,bc
0426A4 17          0369*       rla
0426A5 52 ED 6A    0370*       adc.s hl,hl
0426A8 52 ED 42    0371*       sbc.s hl,bc
0426AB 30 02       0372*       jr nc,$+4
0426AD 52 09       0373*       add.s hl,bc
0426AF 17          0374*       rla
0426B0 52 ED 6A    0375*       adc.s hl,hl
0426B3 52 ED 42    0376*       sbc.s hl,bc
0426B6 30 02       0377*       jr nc,$+4
0426B8 52 09       0378*       add.s hl,bc
0426BA 17          0379*       rla
0426BB 2F          0380*       cpl
0426BC 57          0381*       ld d,a
0426BD             0382*   
0426BD 7B          0383*       ld a,e
0426BE 17          0384*       rla
0426BF 52 ED 6A    0385*       adc.s hl,hl
0426C2 52 ED 42    0386*       sbc.s hl,bc
0426C5 30 02       0387*       jr nc,$+4
0426C7 52 09       0388*       add.s hl,bc
0426C9 17          0389*       rla
0426CA 52 ED 6A    0390*       adc.s hl,hl
0426CD 52 ED 42    0391*       sbc.s hl,bc
0426D0 30 02       0392*       jr nc,$+4
0426D2 52 09       0393*       add.s hl,bc
0426D4 17          0394*       rla
0426D5 52 ED 6A    0395*       adc.s hl,hl
0426D8 52 ED 42    0396*       sbc.s hl,bc
0426DB 30 02       0397*       jr nc,$+4
0426DD 52 09       0398*       add.s hl,bc
0426DF 17          0399*       rla
0426E0 52 ED 6A    0400*       adc.s hl,hl
0426E3 52 ED 42    0401*       sbc.s hl,bc
0426E6 30 02       0402*       jr nc,$+4
0426E8 52 09       0403*       add.s hl,bc
0426EA 17          0404*       rla
0426EB 52 ED 6A    0405*       adc.s hl,hl
0426EE 52 ED 42    0406*       sbc.s hl,bc
0426F1 30 02       0407*       jr nc,$+4
0426F3 52 09       0408*       add.s hl,bc
0426F5 17          0409*       rla
0426F6 52 ED 6A    0410*       adc.s hl,hl
0426F9 52 ED 42    0411*       sbc.s hl,bc
0426FC 30 02       0412*       jr nc,$+4
0426FE 52 09       0413*       add.s hl,bc
042700 17          0414*       rla
042701 52 ED 6A    0415*       adc.s hl,hl
042704 52 ED 42    0416*       sbc.s hl,bc
042707 30 02       0417*       jr nc,$+4
042709 52 09       0418*       add.s hl,bc
04270B 17          0419*       rla
04270C 52 ED 6A    0420*       adc.s hl,hl
04270F 52 ED 42    0421*       sbc.s hl,bc
042712 30 02       0422*       jr nc,$+4
042714 52 09       0423*       add.s hl,bc
042716 17          0424*       rla
042717 2F          0425*       cpl
042718 5F          0426*       ld e,a
042719 C9          0427*       ret
04271A             0428*   
04271A             0429*   ;;End of div16
04271A             0037        include "../agon/timer_prt_stopwatch.inc"
04271A             0001*   prt_stopwatch_reload: equ 72000/1000 ; 1 millisecond with clock divider 256
04271A             0002*   
04271A             0003*   ; set PRT timer
04271A             0004*   prt_stopwatch_set:
04271A 21 00 00 00 0005*       ld hl,0
04271E 22 73 27 04 0006*       ld (prt_stopwatch_irq_counter),hl
042722             0007*   
042722 21 48 00 00 0008*       ld hl,prt_stopwatch_reload
042726 ED 29 84    0009*       out0 (TMR1_CTL+TMR_RES_LOW),l
042729 ED 21 85    0010*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04272C             0011*   ; disable timer (in effect, reset it)
04272C 3E 0E       0012*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
04272E ED 39 83    0013*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042731             0014*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 256
042731 3E 5F       0015*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_256 | RST_EN_1 | PRT_EN_1
042733 ED 39 83    0016*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042736 C9          0017*       ret
042737             0018*   
042737             0019*   ; get PRT stopwatch elapsed time in milliseconds
042737             0020*   prt_stopwatch_get:
042737 2A 73 27 04 0021*       ld hl,(prt_stopwatch_irq_counter)
04273B C9          0022*       ret
04273C             0023*   
04273C             0024*   ; stop PRT timer
04273C             0025*   prt_stopwatch_stop:
04273C 3E 0E       0026*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_256 | RST_EN_1 | PRT_EN_0
04273E ED 39 83    0027*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042741 C9          0028*       ret
042742             0029*   
042742             0030*   ; ===============================================
042742             0031*   ; PRT Timer Interrupt Handling
042742             0032*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
042742             0033*   ; -----------------------------------------------
042742             0034*   prt_stopwatch_irq_init:
042742             0035*       ; set up interrupt vector table 2
042742 21 00 00 00 0036*   	ld hl,0
042746 3A 0C 01 00 0037*   	ld a,($10c)
04274A 6F          0038*   	ld l,a
04274B 3A 0D 01 00 0039*   	ld a,($10d)
04274F 67          0040*   	ld h,a
042750             0041*   
042750             0042*   	; skip over CALL ($c3)
042750 23          0043*   	inc hl
042751             0044*   	; load address of jump into vector table 2 (in ram)
042751 ED 27       0045*   	ld hl,(hl)
042753             0046*   
042753             0047*   	; write CALL prt_irq_handler to vector table 2
042753 3E C3       0048*   	ld a,$c3
042755 77          0049*   	ld (hl),a
042756 23          0050*   	inc hl
042757 11 5E 27 04 0051*   	ld de,prt_stopwatch_irq_handler
04275B ED 1F       0052*   	ld (hl),de
04275D             0053*   
04275D C9          0054*       ret
04275E             0055*   
04275E             0056*   prt_stopwatch_irq_handler:
04275E F3          0057*   	di
04275F F5          0058*   	push af
042760 E5          0059*       push hl
042761 ED 38 83    0060*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
042764 2A 73 27 04 0061*   	ld hl,(prt_stopwatch_irq_counter)
042768 23          0062*   	inc hl
042769 22 73 27 04 0063*   	ld (prt_stopwatch_irq_counter),hl
04276D E1          0064*       pop hl
04276E F1          0065*   	pop af
04276F FB          0066*   	ei
042770 5B ED 4D    0067*   	reti.l
042773             0068*   
042773             0069*   prt_stopwatch_irq_counter:
042773 00 00 00    0070*   	.dl 0
042776             0038        include "../agon/timer.inc"
042776             0001*   ; Table 32. Timer Control Registers
042776             0002*   TMR0_CTL: equ 80h
042776             0003*   TMR1_CTL: equ 83h
042776             0004*   TMR2_CTL: equ 86h
042776             0005*   TMR3_CTL: equ 89h
042776             0006*   TMR4_CTL: equ 8Ch
042776             0007*   TMR5_CTL: equ 8Fh
042776             0008*   
042776             0009*   ; each timer register takes three bytes:
042776             0010*   ;   0: control register
042776             0011*   ;   1: low byte of timer reset value
042776             0012*   ;   2: high byte of timer reset value
042776             0013*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
042776             0014*   ; which correctly force the high and upper bytes of the address bus to zero
042776             0015*   
042776             0016*   TMR_REG_CTL: equ 0
042776             0017*   TMR_RES_LOW: equ 1
042776             0018*   TMR_RES_HIGH: equ 2
042776             0019*   
042776             0020*   ; Timer Control Register Bit Definitions
042776             0021*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
042776             0022*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
042776             0023*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
042776             0024*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
042776             0025*                               ; the TMRx_CTL register is read.
042776             0026*   
042776             0027*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
042776             0028*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
042776             0029*   
042776             0030*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
042776             0031*                               ;  0,and counting stops when the end-of-count value is reached.
042776             0032*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
042776             0033*                               ; written to the counter when the end-of-count value is reached.
042776             0034*   
042776             0035*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
042776             0036*   CLK_DIV_256:  equ %00001100 ;
042776             0037*   CLK_DIV_64:   equ %00001000 ;
042776             0038*   CLK_DIV_16:   equ %00000100 ;
042776             0039*   CLK_DIV_4:    equ %00000000 ;
042776             0040*   
042776             0041*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
042776             0042*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
042776             0043*                               ; When a 1 is written to this bit,the values in the reload registers
042776             0044*                               ;  are loaded into the downcounter when the timer restarts. The
042776             0045*                               ; programmer must ensure that this bit is set to 1 each time
042776             0046*                               ; SINGLE-PASS mode is used.
042776             0047*   
042776             0048*   ; disable/enable the programmable reload timer
042776             0049*   PRT_EN_0:     equ %00000000 ;
042776             0050*   PRT_EN_1:     equ %00000001 ;
042776             0051*   
042776             0052*   ; Table 37. Timer Input Source Select Register
042776             0053*   ; Each of the 4 timers are allocated two bits of the 8-bit register
042776             0054*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
042776             0055*   ;   00: System clock / CLK_DIV
042776             0056*   ;   01: RTC / CLK_DIV
042776             0057*   ;   NOTE: these are the values given in the manual,but it may be a typo
042776             0058*   ;   10: GPIO port B pin 1.
042776             0059*   ;   11: GPIO port B pin 1.
042776             0060*   TMR_ISS:   equ 92h ; register address
042776             0061*   
042776             0062*   ; Table 51. Real-Time Clock Control Register
042776             0063*   RTC_CTRL: equ EDh ; register address
042776             0064*   
042776             0065*   ; alarm interrupt disable/enable
042776             0066*   RTC_ALARM_0:    equ %00000000
042776             0067*   RTC_ALARM_1:    equ %10000000
042776             0068*   
042776             0069*   ; interrupt on alarm disable/enable
042776             0070*   RTC_INT_ENT_0:  equ %00000000
042776             0071*   RTC_INT_ENT_1:  equ %01000000
042776             0072*   
042776             0073*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
042776             0074*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
042776             0075*   
042776             0076*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
042776             0077*                                   ; On-chip 32768 Hz oscillator is enabled.
042776             0078*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
042776             0079*                                   ; On-chip 32768 Hz oscillator is disabled.
042776             0080*   
042776             0081*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
042776             0082*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
042776             0083*   
042776             0084*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
042776             0085*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
042776             0086*   
042776             0087*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
042776             0088*                                   ; RTC counter is enabled.
042776             0089*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
042776             0090*                                   ; RTC counter is disabled.
042776             0091*   
042776             0092*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
042776             0093*   
042776             0094*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
042776             0095*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
042776 00 00 00    0096*   prt_reload: dl 0x000000
042779             0097*   
042779             0098*   ; returns: a = 0 if running on hardware,1 if running on emulator
042779             0099*   ;          de = number PRT interrupts during test interval
042779             0100*   prt_calibrate:
042779 CD A2 2F 04 0101*       call vdu_vblank
04277D             0102*   ; set a MOS timer
04277D 21 78 00 00 0103*       ld hl,120*1 ; 1 second
042781 FD 21 01 29 0104*       ld iy,tmr_test
       04          
042786 CD DF 28 04 0105*       call tmr_set
04278A             0106*   ; set a PRT timer
04278A             0107*       ; ld hl,prt_reload_hardware
04278A             0108*       ; ld hl,prt_reload_emulator
04278A 21 05 2D 00 0109*       ld hl,prt_reload_emulator + prt_reload_hardware / 2
04278E 22 76 27 04 0110*       ld (prt_reload),hl
042792 CD 1A 28 04 0111*       call prt_set
042796             0112*   @loop:
042796             0113*   ; check time remaining on MOS timer
042796 CD ED 28 04 0114*       call tmr_get
04279A CA A4 27 04 0115*       jp z,@done ; time expired,so quit
04279E FA A4 27 04 0116*       jp m,@done ; time past expiration (negative),so quit
0427A2 18 F2       0117*       jr @loop
0427A4             0118*   @done:
0427A4 ED 5B 68 28 0119*       ld de,(prt_irq_counter)
       04          
0427A9 01 0C 2D 00 0120*       ld bc,prt_reload_hardware ; default value for running on hardware
0427AD ED 43 76 27 0121*       ld (prt_reload),bc
       04          
0427B2 21 64 00 00 0122*       ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0427B6 AF          0123*       xor a ; clear carry,zero is default value for running on hardware
0427B7 32 D9 27 04 0124*       ld (is_emulator),a
0427BB ED 52       0125*       sbc hl,de
0427BD 21 DA 27 04 0126*       ld hl,on_hardware ; default message for running on hardware
0427C1 CA 79 27 04 0127*       jp z,prt_calibrate ; zero result is indeterminate so we try again
0427C5 F8          0128*       ret m ; negative result means we're on hardware
0427C6 3C          0129*       inc a ; we're on emulator
0427C7 32 D9 27 04 0130*       ld (is_emulator),a
0427CB 01 FF 2C 00 0131*       ld bc,prt_reload_emulator
0427CF ED 43 76 27 0132*       ld (prt_reload),bc
       04          
0427D4 21 F0 27 04 0133*       ld hl,on_emulator
0427D8 C9          0134*       ret
0427D9 00          0135*   is_emulator: db 0
0427DA 52 75 6E 6E 0136*   on_hardware: defb "Running on hardware\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 0D 
       0A 00       
0427F0 52 75 6E 6E 0137*   on_emulator: defb "Running on emulator\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 0D 
       0A 00       
042806             0138*   
042806 43 61 6C 69 0139*   calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
04281A             0140*   
04281A             0141*   ; set PRT timer
04281A             0142*   prt_set:
04281A 21 00 00 00 0143*       ld hl,0
04281E 22 68 28 04 0144*       ld (prt_irq_counter),hl
042822 2A 76 27 04 0145*       ld hl,(prt_reload)
042826 ED 29 84    0146*       out0 (TMR1_CTL+TMR_RES_LOW),l
042829 ED 21 85    0147*   	out0 (TMR1_CTL+TMR_RES_HIGH),h
04282C             0148*   ; disable timer
04282C 3E 06       0149*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04282E ED 39 83    0150*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042831             0151*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
042831 3E 57       0152*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
042833 ED 39 83    0153*   	out0 (TMR1_CTL+TMR_REG_CTL),a
042836 C9          0154*       ret
042837             0155*   
042837             0156*   ; ===============================================
042837             0157*   ; PRT Timer Interrupt Handling
042837             0158*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.asm
042837             0159*   ; -----------------------------------------------
042837             0160*   prt_irq_init:
042837             0161*       ; set up interrupt vector table 2
042837 21 00 00 00 0162*   	ld hl,0
04283B 3A 0C 01 00 0163*   	ld a,($10c)
04283F 6F          0164*   	ld l,a
042840 3A 0D 01 00 0165*   	ld a,($10d)
042844 67          0166*   	ld h,a
042845             0167*   
042845             0168*   	; skip over CALL ($c3)
042845 23          0169*   	inc hl
042846             0170*   	; load address of jump into vector table 2 (in ram)
042846 ED 27       0171*   	ld hl,(hl)
042848             0172*   
042848             0173*   	; write CALL prt_irq_handler to vector table 2
042848 3E C3       0174*   	ld a,$c3
04284A 77          0175*   	ld (hl),a
04284B 23          0176*   	inc hl
04284C 11 53 28 04 0177*   	ld de,prt_irq_handler
042850 ED 1F       0178*   	ld (hl),de
042852             0179*   
042852 C9          0180*       ret
042853             0181*   
042853             0182*   prt_irq_handler:
042853 F3          0183*   	di
042854 F5          0184*   	push af
042855 E5          0185*       push hl
042856 ED 38 83    0186*   	in0 a,(TMR1_CTL+TMR_REG_CTL)
042859 2A 68 28 04 0187*   	ld hl,(prt_irq_counter)
04285D 23          0188*   	inc hl
04285E 22 68 28 04 0189*   	ld (prt_irq_counter),hl
042862 E1          0190*       pop hl
042863 F1          0191*   	pop af
042864 FB          0192*   	ei
042865 5B ED 4D    0193*   	reti.l
042868             0194*   
042868             0195*   prt_irq_counter:
042868 00 00 00    0196*   	.dl 0
04286B             0197*   prt_irq_counter_saved:
04286B 00 00 00    0198*       .dl 0
04286E             0199*   
04286E             0200*   prt_loop_reset:
04286E E5          0201*       push hl
04286F 21 00 00 00 0202*   	ld hl,0
042873 22 68 28 04 0203*   	ld (prt_irq_counter),hl
042877 22 D9 28 04 0204*       ld (prt_loop_counter),hl
04287B 22 DC 28 04 0205*       ld (prt_loops),hl
04287F CD 1A 28 04 0206*       call prt_set
042883 E1          0207*       pop hl
042884 C9          0208*       ret
042885             0209*   
042885             0210*   prt_loop_start:
042885 E5          0211*       push hl
042886 21 00 00 00 0212*   	ld hl,0
04288A 22 68 28 04 0213*   	ld (prt_irq_counter),hl
04288E E1          0214*       pop hl
04288F C9          0215*       ret
042890             0216*   
042890             0217*   prt_loop_stop:
042890 E5          0218*       push hl
042891 D5          0219*       push de
042892 2A 68 28 04 0220*       ld hl,(prt_irq_counter)
042896 ED 5B D9 28 0221*       ld de,(prt_loop_counter)
       04          
04289B 19          0222*       add hl,de
04289C 22 D9 28 04 0223*       ld (prt_loop_counter),hl
0428A0 21 00 00 00 0224*       ld hl,0
0428A4 22 68 28 04 0225*       ld (prt_irq_counter),hl
0428A8 2A DC 28 04 0226*       ld hl,(prt_loops)
0428AC 23          0227*       inc hl
0428AD 22 DC 28 04 0228*       ld (prt_loops),hl
0428B1 D1          0229*       pop de
0428B2 E1          0230*       pop hl
0428B3 C9          0231*       ret
0428B4             0232*   
0428B4             0233*   ; inputs: bc = y,x text coordinates to print
0428B4             0234*   prt_loop_print:
0428B4 F5          0235*       push af
0428B5 E5          0236*       push hl
0428B6 C5          0237*       push bc
0428B7 D5          0238*       push de
0428B8 DD E5       0239*       push ix
0428BA FD E5       0240*       push iy
0428BC CD 06 2F 04 0241*       call vdu_move_cursor
0428C0             0242*   
0428C0 2A D9 28 04 0243*       ld hl,(prt_loop_counter)
0428C4 CD 51 21 04 0244*       call printDec
0428C8             0245*   
0428C8 2A DC 28 04 0246*       ld hl,(prt_loops)
0428CC CD 51 21 04 0247*       call printDec
0428D0             0248*   
0428D0 FD E1       0249*       pop iy
0428D2 DD E1       0250*       pop ix
0428D4 D1          0251*       pop de
0428D5 C1          0252*       pop bc
0428D6 E1          0253*       pop hl
0428D7 F1          0254*       pop af
0428D8 C9          0255*       ret
0428D9             0256*   
0428D9             0257*   prt_loop_counter:
0428D9 00 00 00    0258*       .dl 0
0428DC             0259*   prt_loops:
0428DC 00 00 00    0260*       .dl 0
0428DF             0261*   
0428DF             0262*   ; ===============================================
0428DF             0263*   ; Timer functions
0428DF             0264*   ; -----------------------------------------------
0428DF             0265*   ; set a countdown timer
0428DF             0266*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0428DF             0267*   ; returns: hl = current time
0428DF             0268*   tmr_set:
0428DF FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
0428E2             0270*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0428E2 3E 08       0001*M1 			LD	A, function
0428E4 5B CF       0002*M1 			RST.LIL	08h
0428E6 DD 27 00    0271*       ld hl,(ix+sysvar_time)  ; get current time
0428E9 FD 2F 00    0272*       ld (iy+0),hl            ; set start time
0428EC C9          0273*       ret
0428ED             0274*   
0428ED             0275*   ; gets time remaining on a countdown timer
0428ED             0276*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0428ED             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0428ED             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
0428ED             0279*   tmr_get:
0428ED             0280*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
0428ED 3E 08       0001*M1 			LD	A, function
0428EF 5B CF       0002*M1 			RST.LIL	08h
0428F1 DD 17 00    0281*       ld de,(ix+sysvar_time)  ; get current time
0428F4 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
0428F7 AF          0283*       xor a                   ; clear carry
0428F8 ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0428FA FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
0428FD AF          0286*       xor a                   ; clear carry
0428FE ED 5A       0287*       adc hl,de               ; hl = time remaining
042900             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
042900 C9          0289*       ret
042901             0290*   
042901             0291*   tmr_test: ds 6 ; example of a buffer to hold timer data
042907             0292*   
       FF FF FF FF 
       FF FF 
042907 00 00 00    0293*   timestamp_now: dl 0
04290A 00 00 00    0294*   timestamp_old: dl 0
04290D 00 00 00    0295*   timestamp_chg: dl 0
042910             0296*   
042910             0297*   ; update the global timestamp from the system clock
042910             0298*   ; inputs: none
042910             0299*   ; returns: hl = time elapsed in 1/120ths of a second
042910             0300*   ;          de = current time
042910             0301*   ;          ix = pointer to syvars table
042910             0302*   ; destroys: af,hl,de,ix
042910             0303*   timestamp_tick:
042910 ED 5B 07 29 0304*       ld de,(timestamp_now)   ; get previous time
       04          
042915 ED 53 0A 29 0305*       ld (timestamp_old),de   ; save previous time
       04          
04291A             0306*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04291A 3E 08       0001*M1 			LD	A, function
04291C 5B CF       0002*M1 			RST.LIL	08h
04291E DD 27 00    0307*       ld hl,(ix+sysvar_time)  ; get current time
042921 22 07 29 04 0308*       ld (timestamp_now),hl   ; save current time
042925 AF          0309*       xor a                   ; clear carry
042926 ED 52       0310*       sbc hl,de               ; hl = time elapsed
042928 22 0D 29 04 0311*       ld (timestamp_chg),hl   ; save elapsed time
04292C C9          0312*       ret
04292D             0313*   
04292D             0314*   ; set a countdown timer
04292D             0315*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04292D             0316*   ; requires: timestamp_tick to be called at least once before this function
04292D             0317*   ; returns: hl = current time
04292D             0318*   ; destroys: hl
04292D             0319*   timestamp_tmr_set:
04292D FD 2F 03    0320*       ld (iy+3),hl            ; set time remaining
042930 2A 07 29 04 0321*       ld hl,(timestamp_now)   ; get current timestamp
042934 FD 2F 00    0322*       ld (iy+0),hl            ; set start time
042937 C9          0323*       ret
042938             0324*   
042938             0325*   ; gets time remaining on a countdown timer following the global timestamp
042938             0326*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
042938             0327*   ; requires: timestamp_tick to be called at least once before this function
042938             0328*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
042938             0329*   ;          sign flags: pos = time not expired,zero or neg = time expired
042938             0330*   ; destroys: af,hl,de
042938             0331*   timestamp_tmr_get:
042938 ED 5B 07 29 0332*       ld de,(timestamp_now)   ; get current timestamp
       04          
04293D FD 27 00    0333*       ld hl,(iy+0)            ; get start time
042940 AF          0334*       xor a                   ; clear carry
042941 ED 52       0335*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
042943 FD 17 03    0336*       ld de,(iy+3)            ; get timer set value
042946 AF          0337*       xor a                   ; clear carry
042947 ED 5A       0338*       adc hl,de               ; hl = time remaining
042949             0339*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
042949 C9          0340*       ret
04294A             0341*   
04294A             0342*   ; set a stopwatch
04294A             0343*   ; returns: hl = start time
04294A             0344*   ; destroys: hl,ix
04294A             0345*   stopwatch_set:
04294A             0346*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
04294A 3E 08       0001*M1 			LD	A, function
04294C 5B CF       0002*M1 			RST.LIL	08h
04294E DD 27 00    0347*       ld hl,(ix+sysvar_time)  ; get current time
042951 22 66 29 04 0348*       ld (stopwatch_started),hl            ; set start time
042955 C9          0349*       ret
042956             0350*   
042956             0351*   ; gets time elapsed on a stopwatch
042956             0352*   ; returns: hl = time elapsed in 1/120ths of a second
042956             0353*   ; destroys: af,hl,de,ix
042956             0354*   stopwatch_get:
042956             0355*       MOSCALL mos_sysvars     ; ix points to syvars table
                       M1 Args: function=mos_sysvars 
042956 3E 08       0001*M1 			LD	A, function
042958 5B CF       0002*M1 			RST.LIL	08h
04295A DD 27 00    0356*       ld hl,(ix+sysvar_time)  ; get current time
04295D ED 5B 66 29 0357*       ld de,(stopwatch_started)            ; get start time
       04          
042962 AF          0358*       xor a                   ; clear carry
042963 ED 52       0359*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
042965 C9          0360*       ret
042966             0361*   
042966             0362*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
042969             0363*   
042969             0364*   ; ------------------
042969             0365*   ; delay routine
042969             0366*   ; Author: Richard Turrnidge
042969             0367*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.asm
042969             0368*   ; routine waits a fixed time,then returns
042969             0369*   ; arrive with A =  the delay byte. One bit to be set only.
042969             0370*   ; eg. ld A,00000100b
042969             0371*   
042969             0372*   multiPurposeDelay:
       FF FF FF 
042969 F5          0373*       push af
04296A C5          0374*       push bc
04296B DD E5       0375*       push ix
04296D 47          0376*       ld b,a
04296E 3E 08       0377*       ld a,$08
042970 5B CF       0378*       RST.LIL	08h                 ; get IX pointer to sysvars
042972             0379*   
042972             0380*   waitLoop:
042972             0381*   
042972 DD 7E 00    0382*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
042975             0383*   
042975             0384*                                   ;   we check if bit set is same as last time we checked.
042975             0385*                                   ;   bit 0 - don't use
042975             0386*                                   ;   bit 1 - changes 64 times per second
042975             0387*                                   ;   bit 2 - changes 32 times per second
042975             0388*                                   ;   bit 3 - changes 16 times per second
042975             0389*   
042975             0390*                                   ;   bit 4 - changes 8 times per second
042975             0391*                                   ;   bit 5 - changes 4 times per second
042975             0392*                                   ;   bit 6 - changes 2 times per second
042975             0393*                                   ;   bit 7 - changes 1 times per second
042975 A0          0394*       and b
042976 4F          0395*       ld c,a
042977 3A 88 29 04 0396*       ld a,(oldTimeStamp)
04297B B9          0397*       cp c                        ; is A same as last value?
04297C 28 F4       0398*       jr z,waitLoop              ; loop here if it is
04297E 79          0399*       ld a,c
04297F 32 88 29 04 0400*       ld (oldTimeStamp),a        ; set new value
042983             0401*   
042983 DD E1       0402*       pop ix
042985 C1          0403*       pop bc
042986 F1          0404*       pop af
042987 C9          0405*       ret
042988             0406*   
042988 00          0407*   oldTimeStamp:   .db 00h
042989             0039        include "../agon/vdu_buffered_api.inc"
042989             0001*   ; https://agonconsole8.github.io/agon-docs/vdp/Buffered-Commands-API/
042989             0002*   
042989             0003*   ; Command 0: Write block to a buffer
042989             0004*   ; VDU 23, 0, &A0, bufferId; 0, length; <buffer-data>
042989             0005*   ; inputs: hl = bufferId, bc = length of data, de = pointer to data
042989             0006*   vdu_write_block_to_buffer:
042989             0007*   ; back up input parameters
042989 D5          0008*       push de ; pointer to data
04298A C5          0009*       push bc ; length of data
04298B             0010*   ; set up the vdu command string
04298B 22 AB 29 04 0011*       ld (@bufferId),hl
04298F ED 43 AE 29 0012*       ld (@length),bc
       04          
042994 AF          0013*       xor a ; load buffer
042995 32 AD 29 04 0014*       ld (@bufferId+2),a
042999 21 A8 29 04 0015*       ld hl,@cmd0
04299D 01 08 00 00 0016*       ld bc,@end0-@cmd0
0429A1 5B DF       0017*       rst.lil $18
0429A3             0018*   ; send the buffer data
0429A3 C1          0019*       pop bc ; length of data
0429A4 E1          0020*       pop hl ; pointer to data (was de)
0429A5 5B DF       0021*       rst.lil $18 ; send it
0429A7 C9          0022*       ret
0429A8             0023*   ; command string data
0429A8 17 00 A0    0024*   @cmd0:      db 23,0,0xA0
0429AB 00 00       0025*   @bufferId:	dw 0x0000
0429AD 00          0026*               db 0 ; load buffer
0429AE 00 00       0027*   @length:	dw 0x0000
0429B0 00          0028*   @end0:      db 0x00 ; padding
0429B1             0029*   ; end vdu_write_block_to_buffer
0429B1             0030*   
0429B1             0031*   ; Command 1: Call a buffer
0429B1             0032*   ; VDU 23, 0, &A0, bufferId; 1
0429B1             0033*   ; inputs: hl = bufferId
0429B1             0034*   vdu_call_buffer:
0429B1 22 C9 29 04 0035*       ld (@bufferId),hl
0429B5 3E 01       0036*       ld a,1 ; call buffer
0429B7 32 CB 29 04 0037*       ld (@bufferId+2),a
0429BB 21 C6 29 04 0038*       ld hl,@cmd
0429BF 01 06 00 00 0039*       ld bc,@end-@cmd
0429C3 5B DF       0040*       rst.lil $18
0429C5 C9          0041*       ret
0429C6 17 00 A0    0042*   @cmd:     db 23,0,0xA0
0429C9 00 00       0043*   @bufferId: dw 0x0000
0429CB 01          0044*              db 1 ; call buffer
0429CC             0045*   @end:
0429CC             0046*   ; end vdu_call_buffer
0429CC             0047*   
0429CC             0048*   ; Command 2: Clear a buffer
0429CC             0049*   ; VDU 23, 0 &A0, bufferId; 2
0429CC             0050*   ; inputs: hl = bufferId
0429CC             0051*   vdu_clear_buffer:
0429CC 22 E4 29 04 0052*       ld (@bufferId),hl
0429D0 3E 02       0053*       ld a,2 ; clear buffer
0429D2 32 E6 29 04 0054*       ld (@bufferId+2),a
0429D6 21 E1 29 04 0055*       ld hl,@cmd
0429DA 01 06 00 00 0056*       ld bc,@end-@cmd
0429DE 5B DF       0057*       rst.lil $18
0429E0 C9          0058*       ret
0429E1 17 00 A0    0059*   @cmd:     db 23,0,0xA0
0429E4 00 00       0060*   @bufferId: dw 0x0000
0429E6 02          0061*              db 2 ; clear buffer
0429E7             0062*   @end:
0429E7             0063*   ; end vdu_clear_buffer
0429E7             0064*   
0429E7             0065*   ; Clear all buffers
0429E7             0066*   ; inputs: none
0429E7             0067*   vdu_clear_all_buffers:
0429E7             0068*   ; clear all buffers
0429E7 21 F2 29 04 0069*       ld hl,@beg
0429EB 01 06 00 00 0070*       ld bc,@end-@beg
0429EF 5B DF       0071*       rst.lil $18
0429F1 C9          0072*       ret
0429F2 17 00 A0    0073*   @beg: db 23,0,$A0
0429F5 FF FF       0074*         dw -1 ; bufferId -1 (65535) means clear all buffers
0429F7 02          0075*         db 2  ; command 2: clear a buffer
0429F8             0076*   @end:
0429F8             0077*   ; end vdu_clear_all_buffers
0429F8             0078*   
0429F8             0079*   ; Command 3: Create a writeable buffer
0429F8             0080*   ; VDU 23, 0 &A0, bufferId; 3, length;
0429F8             0081*   ; inputs: hl = bufferId, bc = length
0429F8             0082*   vdu_create_writeable_buffer:
0429F8 22 15 2A 04 0083*       ld (@bufferId),hl
0429FC ED 43 18 2A 0084*       ld (@length),bc
       04          
042A01 3E 03       0085*       ld a,3 ; create writeable buffer
042A03 32 17 2A 04 0086*       ld (@bufferId+2),a
042A07 21 12 2A 04 0087*       ld hl,@cmd
042A0B 01 08 00 00 0088*       ld bc,@end-@cmd
042A0F 5B DF       0089*       rst.lil $18
042A11 C9          0090*       ret
042A12 17 00 A0    0091*   @cmd:     db 23,0,0xA0
042A15 00 00       0092*   @bufferId: dw 0x0000
042A17 03          0093*              db 3 ; create writeable buffer
042A18 00 00       0094*   @length: dw 0x0000
042A1A 00          0095*   @end:     db 0x00 ; padding
042A1B             0096*   ; end vdu_create_writeable_buffer
042A1B             0097*   
042A1B             0098*   ; Command 4: Set output stream to a buffer
042A1B             0099*   ; VDU 23, 0 &A0, bufferId; 4
042A1B             0100*   ; inputs: hl = bufferId
042A1B             0101*   vdu_set_output_stream_buffer:
042A1B 22 33 2A 04 0102*       ld (@bufferId),hl
042A1F 3E 04       0103*       ld a,4 ; set output stream to buffer
042A21 32 35 2A 04 0104*       ld (@bufferId+2),a
042A25 21 30 2A 04 0105*       ld hl,@cmd
042A29 01 06 00 00 0106*       ld bc,@end-@cmd
042A2D 5B DF       0107*       rst.lil $18
042A2F C9          0108*       ret
042A30 17 00 A0    0109*   @cmd:     db 23,0,0xA0
042A33 00 00       0110*   @bufferId: dw 0x0000
042A35 04          0111*              db 4 ; set output stream to buffer
042A36 00          0112*   @end:     db 0x00 ; padding
042A37             0113*   ; end vdu_set_output_stream_buffer
042A37             0114*   
042A37             0115*   ; Command 5: Adjust buffer contents
042A37             0116*   ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
042A37             0117*   vdu_adjust_buffer:
042A37 C9          0118*       ret ; TODO: implement
042A38             0119*   ; end vdu_adjust_buffer
042A38             0120*   
042A38             0121*   ; Command 6: Conditionally call a buffer
042A38             0122*   ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
042A38             0123*   vdu_call_buffer_conditional:
042A38 C9          0124*       ret ; TODO: implement
042A39             0125*   ; end vdu_call_buffer_conditional
042A39             0126*   
042A39             0127*   ; Command 7: Jump to a buffer
042A39             0128*   ; VDU 23, 0, &A0, bufferId; 7
042A39             0129*   ; inputs: hl = bufferId
042A39             0130*   vdu_jump_to_buffer:
042A39 22 51 2A 04 0131*       ld (@bufferId),hl
042A3D 3E 07       0132*       ld a,7 ; jump to buffer
042A3F 32 53 2A 04 0133*       ld (@bufferId+2),a
042A43 21 4E 2A 04 0134*       ld hl,@cmd
042A47 01 06 00 00 0135*       ld bc,@end-@cmd
042A4B 5B DF       0136*       rst.lil $18
042A4D C9          0137*       ret
042A4E 17 00 A0    0138*   @cmd:     db 23,0,0xA0
042A51 00 00       0139*   @bufferId: dw 0x0000
042A53 07          0140*              db 7 ; jump to buffer
042A54 00          0141*   @end:     db 0x00 ; padding
042A55             0142*   ; end vdu_jump_to_buffer
042A55             0143*   
042A55             0144*   ; Command 8: Conditional Jump to a buffer
042A55             0145*   ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
042A55             0146*   vdu_jump_to_buffer_conditional:
042A55 C9          0147*       ret ; TODO: implement
042A56             0148*   ; end vdu_jump_to_buffer_conditional
042A56             0149*   
042A56             0150*   ; Command 9: Jump to an offset in a buffer
042A56             0151*   ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
042A56             0152*   vdu_jump_to_buffer_offset:
042A56 C9          0153*       ret ; TODO: implement
042A57             0154*   ; end vdu_jump_to_buffer_offset
042A57             0155*   
042A57             0156*   ; Command 10: Conditional jump to an offset in a buffer
042A57             0157*   ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
042A57             0158*   vdu_jump_to_buffer_offset_conditional:
042A57 C9          0159*       ret ; TODO: implement
042A58             0160*   ; end vdu_jump_to_buffer_offset_conditional
042A58             0161*   
042A58             0162*   ; Command 11: Call buffer with an offset
042A58             0163*   ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
042A58             0164*   vdu_call_buffer_offset:
042A58 C9          0165*       ret ; TODO: implement
042A59             0166*   ; end vdu_call_buffer_offset
042A59             0167*   
042A59             0168*   ; Command 23: Set affine transforms test flag
042A59             0169*   ; VDU 23, 0, &F8, 1; 1;
042A59             0170*   ; inputs: none
042A59             0171*   vdu_enable_transforms:
042A59 21 64 2A 04 0172*       ld hl,@cmd
042A5D 01 07 00 00 0173*       ld bc,@end-@cmd
042A61 5B DF       0174*       rst.lil $18
042A63 C9          0175*       ret
042A64 17 00 F8    0176*   @cmd:   db 23,0,0xF8
042A67 01 00       0177*           dw 1 ; magic number
042A69 01 00       0178*           dw 1 ; ditto
042A6B             0179*   @end:
042A6B             0180*   ; end vdu_enable_transforms
042A6B             0181*   
042A6B             0182*   ; Command 32: Create or manipulate a 2D affine transformation matrix
042A6B             0183*   ; VDU 23, 0, &A0, bufferId; 32, operation, [<format>, <arguments...>]
042A6B             0184*   ; inputs: a = operation, hl = bufferId, de = pointer to arguments, bc = length of arguments, ixl = format
042A6B             0185*   vdu_do_2d_matrix_transform:
042A6B F5          0186*       push af ; save operation
042A6C C5          0187*       push bc ; length of arguments
042A6D D5          0188*       push de ; pointer to arguments
042A6E 32 9B 2A 04 0189*       ld (@operation),a
042A72 7D          0190*       ld a,l
042A73 32 98 2A 04 0191*       ld (@bufferId+0),a
042A77 7C          0192*       ld a,h
042A78 32 99 2A 04 0193*       ld (@bufferId+1),a
042A7C DD 7D       0194*       ld a,ixl
042A7E 32 9C 2A 04 0195*       ld (@format),a
042A82 21 95 2A 04 0196*       ld hl,@cmd
042A86 01 08 00 00 0197*       ld bc,@end-@cmd
042A8A 5B DF       0198*       rst.lil $18
042A8C E1          0199*       pop hl ; pointer to arguments (was de)
042A8D C1          0200*       pop bc ; length of arguments
042A8E F1          0201*       pop af ; restore operation
042A8F FE 01       0202*       cp 1 ; if > 1, send the arguments
042A91 D8          0203*       ret c ; no arguments
042A92 5B DF       0204*       rst.lil $18 ; send the arguments
042A94 C9          0205*       ret
042A95 17 00 A0    0206*   @cmd:       db 23,0,0xA0
042A98 00 00       0207*   @bufferId:  dw 0x0000
042A9A 20          0208*               db 32 ; create transform matrix
042A9B 00          0209*   @operation: db 0x00
042A9C 00          0210*   @format:    db 0x00
042A9D             0211*   @end:
042A9D             0212*   ; end vdu_do_2d_matrix_transform
042A9D             0213*   
042A9D             0214*   ; Command 33: Create or manipulate a 3D affine transformation matrix
042A9D             0215*   ; VDU 23, 0, &A0, bufferId; 33, operation, [<format>, <arguments...>]
042A9D             0216*   ; inputs: a = operation, hl = bufferId, de = pointer to arguments, bc = length of arguments, ixl = format
042A9D             0217*   vdu_do_3d_matrix_transform:
042A9D F5          0218*       push af ; save operation
042A9E C5          0219*       push bc ; length of arguments
042A9F D5          0220*       push de ; pointer to arguments
042AA0 32 CD 2A 04 0221*       ld (@operation),a
042AA4 7D          0222*       ld a,l
042AA5 32 CA 2A 04 0223*       ld (@bufferId+0),a
042AA9 7C          0224*       ld a,h
042AAA 32 CB 2A 04 0225*       ld (@bufferId+1),a
042AAE DD 7D       0226*       ld a,ixl
042AB0 32 CE 2A 04 0227*       ld (@format),a
042AB4 21 C7 2A 04 0228*       ld hl,@cmd
042AB8 01 08 00 00 0229*       ld bc,@end-@cmd
042ABC 5B DF       0230*       rst.lil $18
042ABE E1          0231*       pop hl ; pointer to arguments (was de)
042ABF C1          0232*       pop bc ; length of arguments
042AC0 F1          0233*       pop af ; restore operation
042AC1 FE 01       0234*       cp 1 ; if > 1, send the arguments
042AC3 D8          0235*       ret c ; no arguments
042AC4 5B DF       0236*       rst.lil $18 ; send the arguments
042AC6 C9          0237*       ret
042AC7 17 00 A0    0238*   @cmd:       db 23,0,0xA0
042ACA 00 00       0239*   @bufferId:  dw 0x0000
042ACC 21          0240*               db 33 ; manipulate transform matrix
042ACD 00          0241*   @operation: db 0x00
042ACE 00          0242*   @format:    db 0x00
042ACF             0243*   @end:
042ACF             0244*   ; end vdu_do_3d_matrix_transform
042ACF             0245*   
042ACF             0246*   ; Command 40: Create a transformed bitmap
042ACF             0247*   ; VDU 23, 0, &A0, bufferId; 40, options, transformBufferId; sourceBitmapId; [width; height;]
042ACF             0248*   ; inputs a = options, de = bufferId, bc = transformBufferId, hl = sourceBitmapId, ix = width, iy = height
042ACF             0249*   ; options:
042ACF             0250*   ; Bit value Arguments       Description
042ACF             0251*   ; 1 		                Target bitmap should be resized. When not set, target will be same dimensions as the original bitmap.
042ACF             0252*   ; 2 	    width; height; 	Target bitmap will be resized to explicitly given dimensions
042ACF             0253*   ; 4 Automatically translate target bitmap position. When set the calculated transformed minimum x,y coordinates will be placed at the top left of the target
042ACF             0254*   vdu_transform_bitmap:
042ACF F5          0255*       push af ; save options
042AD0 32 10 2B 04 0256*       ld (@options),a
042AD4 7B          0257*       ld a,e
042AD5 32 0D 2B 04 0258*       ld (@bufferId+0),a
042AD9 7A          0259*       ld a,d
042ADA 32 0E 2B 04 0260*       ld (@bufferId+1),a
042ADE ED 43 11 2B 0261*       ld (@transformBufferId),bc
       04          
042AE3 22 13 2B 04 0262*       ld (@sourceBitmapId),hl
042AE7 21 0A 2B 04 0263*       ld hl,@cmd
042AEB 01 0B 00 00 0264*       ld bc,@end-@cmd
042AEF 5B DF       0265*       rst.lil $18
042AF1 F1          0266*       pop af ; restore options
042AF2 CB 57       0267*       bit 2,a ; check resize bit
042AF4 C8          0268*       ret z
042AF5 DD 22 16 2B 0269*       ld (@width),ix
       04          
042AFA FD 22 18 2B 0270*       ld (@height),iy
       04          
042AFF 21 16 2B 04 0271*       ld hl,@width
042B03 01 04 00 00 0272*       ld bc,4
042B07 5B DF       0273*       rst.lil $18
042B09 C9          0274*       ret
042B0A 17 00 A0    0275*   @cmd:       db 23,0,0xA0
042B0D 00 00       0276*   @bufferId:  dw 0x0000
042B0F 28          0277*               db 40 ; create transformed bitmap
042B10 00          0278*   @options:   db 0x00
042B11 00 00       0279*   @transformBufferId: dw 0x0000
042B13 00 00       0280*   @sourceBitmapId:    dw 0x0000
042B15 00          0281*   @end:       db 0x00 ; padding
042B16             0282*   ; these are only included when bit 2 of options (resize) is set
042B16 00 00       0283*   @width:     dw 0x0000
042B18 00 00       0284*   @height:    dw 0x0000
042B1A 00          0285*               db 0x00 ; padding
042B1B             0286*   ; end vdu_transform_bitmap
042B1B             0287*   
042B1B             0288*   ; Command 64: Compress a buffer
042B1B             0289*   ; VDU 23, 0, &A0, targetBufferId; 64, sourceBufferId;
042B1B             0290*   ; inputs: hl = sourceBufferId, de = targetBufferId
042B1B             0291*   vdu_compress_buffer:
042B1B 22 3B 2B 04 0292*       ld (@sourceBufferId),hl
042B1F ED 53 38 2B 0293*       ld (@targetBufferId),de
       04          
042B24 3E 40       0294*       ld a,64 ; compress buffer
042B26 32 3A 2B 04 0295*       ld (@sourceBufferId-1),a
042B2A 21 35 2B 04 0296*       ld hl,@cmd
042B2E 01 08 00 00 0297*       ld bc,@end-@cmd
042B32 5B DF       0298*       rst.lil $18
042B34 C9          0299*       ret
042B35 17 00 A0    0300*   @cmd:     db 23,0,0xA0
042B38 00 00       0301*   @targetBufferId: dw 0x0000
042B3A 40          0302*              db 64 ; compress buffer
042B3B 00 00       0303*   @sourceBufferId: dw 0x0000
042B3D 00          0304*   @end:     db 0x00 ; padding
042B3E             0305*   
042B3E             0306*   
042B3E             0307*   ; Command 65: Decompress a buffer
042B3E             0308*   ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
042B3E             0309*   ; inputs: hl = sourceBufferId, de = targetBufferId
042B3E             0310*   vdu_decompress_buffer:
042B3E 22 5E 2B 04 0311*       ld (@sourceBufferId),hl
042B42 ED 53 5B 2B 0312*       ld (@targetBufferId),de
       04          
042B47 3E 41       0313*       ld a,65 ; decompress buffer
042B49 32 5D 2B 04 0314*       ld (@sourceBufferId-1),a
042B4D 21 58 2B 04 0315*       ld hl,@cmd
042B51 01 08 00 00 0316*       ld bc,@end-@cmd
042B55 5B DF       0317*       rst.lil $18
042B57 C9          0318*       ret
042B58 17 00 A0    0319*   @cmd:     db 23,0,0xA0
042B5B 00 00       0320*   @targetBufferId: dw 0x0000
042B5D 41          0321*              db 65 ; decompress buffer
042B5E 00 00       0322*   @sourceBufferId: dw 0x0000
042B60 00          0323*   @end:     db 0x00 ; padding
042B61             0040        include "../agon/vdu_fonts.inc"
042B61             0001*   ; select font
042B61             0002*   ; inputs: hl = bufferId, a = font flags
042B61             0003*   ; Flags:
042B61             0004*   ; Bit	Description
042B61             0005*   ; 0	Adjust cursor position to ensure text baseline is aligned
042B61             0006*   ;   0: Do not adjust cursor position (best for changing font on a new line)
042B61             0007*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
042B61             0008*   ; 1-7	Reserved for future use
042B61             0009*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
042B61             0010*   vdu_font_select:
042B61 22 78 2B 04 0011*       ld (@bufferId),hl
042B65 32 7A 2B 04 0012*       ld (@flags),a
042B69 21 74 2B 04 0013*       ld hl,@cmd
042B6D 01 07 00 00 0014*       ld bc,@end-@cmd
042B71 5B DF       0015*       rst.lil $18
042B73 C9          0016*       ret
042B74 17 00 95 00 0017*   @cmd: db 23, 0, 0x95, 0
042B78 00 00       0018*   @bufferId: dw 0x0000
042B7A 00          0019*   @flags: db 0x00
042B7B             0020*   @end:
042B7B             0021*   
042B7B             0022*   ; create font from buffer
042B7B             0023*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
042B7B             0024*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
042B7B             0025*   vdu_font_create:
042B7B 22 A0 2B 04 0026*       ld (@bufferId),hl
042B7F ED 53 A2 2B 0027*       ld (@width),de ; also loads height
       04          
042B84 32 A5 2B 04 0028*       ld (@flags),a
042B88 7A          0029*       ld a,d ; height
042B89 32 A4 2B 04 0030*       ld (@ascent),a ; ascent = height
042B8D             0031*   ; consolidate buffer
042B8D CD FF 30 04 0032*       call vdu_consolidate_buffer
042B91             0033*   ; create font
042B91 21 9C 2B 04 0034*       ld hl,@cmd
042B95 01 0A 00 00 0035*       ld bc,@end-@cmd
042B99 5B DF       0036*       rst.lil $18
042B9B C9          0037*       ret
042B9C 17 00 95 01 0038*   @cmd: db 23, 0, 0x95, 1
042BA0 00 00       0039*   @bufferId: dw 0x0000
042BA2 00          0040*   @width: db 0x00
042BA3 00          0041*   @height: db 0x00
042BA4 00          0042*   @ascent: db 0x00
042BA5 00          0043*   @flags: db 0x00
042BA6             0044*   @end:
042BA6             0045*   
042BA6             0046*   ; set or adjust font property
042BA6             0047*   ; inputs: hl = bufferId, a = field, de = value
042BA6             0048*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
042BA6             0049*   vdu_font_property:
042BA6 22 C2 2B 04 0050*       ld (@bufferId),hl
042BAA 32 C4 2B 04 0051*       ld (@field),a
042BAE ED 53 C5 2B 0052*       ld (@value),de
       04          
042BB3 21 BE 2B 04 0053*       ld hl,@cmd
042BB7 01 09 00 00 0054*       ld bc,@end-@cmd
042BBB 5B DF       0055*       rst.lil $18
042BBD C9          0056*       ret
042BBE 17 00 95 02 0057*   @cmd: db 23, 0, 0x95, 2
042BC2 00 00       0058*   @bufferId: dw 0x0000
042BC4 00          0059*   @field: db 0x00
042BC5 00 00       0060*   @value: dw 0x0000
042BC7 00          0061*   @end: db 0x00 ; padding
042BC8             0062*   
042BC8             0063*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
042BC8             0064*   
042BC8             0065*   ; Clear/Delete font
042BC8             0066*   ; inputs: hl = bufferId
042BC8             0067*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
042BC8             0068*   vdu_font_clear:
042BC8 22 DB 2B 04 0069*       ld (@bufferId),hl
042BCC 21 D7 2B 04 0070*       ld hl,@cmd
042BD0 01 06 00 00 0071*       ld bc,@end-@cmd
042BD4 5B DF       0072*       rst.lil $18
042BD6 C9          0073*       ret
042BD7 17 00 95 04 0074*   @cmd: db 23, 0, 0x95, 4
042BDB 00 00       0075*   @bufferId: dw 0x0000
042BDD 00          0076*   @end: db 0x00 ; padding
042BDE             0077*   
042BDE             0078*   ; Copy system font to buffer
042BDE             0079*   ; inputs: hl = bufferId
042BDE             0080*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
042BDE             0081*   vdu_font_copy_system:
042BDE 22 F1 2B 04 0082*       ld (@bufferId),hl
042BE2 21 ED 2B 04 0083*       ld hl,@cmd
042BE6 01 06 00 00 0084*       ld bc,@end-@cmd
042BEA 5B DF       0085*       rst.lil $18
042BEC C9          0086*       ret
042BED 17 00 95 05 0087*   @cmd: db 23, 0, 0x95, 5
042BF1 00 00       0088*   @bufferId: dw 0x0000
042BF3 00          0089*   @end: db 0x00 ; padding
042BF4             0041        include "../agon/vdu_plot.inc"
042BF4             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042BF4             0002*   ; PLOT code 	(Decimal) 	Effect
042BF4             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
042BF4             0004*   plot_sl_both: equ 0x00
042BF4             0005*   
042BF4             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
042BF4             0007*   plot_sl_first: equ 0x08
042BF4             0008*   
042BF4             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
042BF4             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
042BF4             0011*   
042BF4             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
042BF4             0013*   plot_sl_last: equ 0x20
042BF4             0014*   
042BF4             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
042BF4             0016*   plot_sl_none: equ 0x28
042BF4             0017*   
042BF4             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
042BF4             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
042BF4             0020*   
042BF4             0021*   ; &40-&47 	64-71 	Point plot
042BF4             0022*   plot_pt: equ 0x40
042BF4             0023*   
042BF4             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background 
042BF4             0025*   plot_lf_lr_non_bg: equ 0x48
042BF4             0026*   
042BF4             0027*   ; &50-&57 	80-87 	Triangle fill
042BF4             0028*   plot_tf: equ 0x50
042BF4             0029*   
042BF4             0030*   ; &58-&5F 	88-95 	Line fill right to background 
042BF4             0031*   plot_lf_r_bg: equ 0x58
042BF4             0032*   
042BF4             0033*   ; &60-&67 	96-103 	Rectangle fill
042BF4             0034*   plot_rf: equ 0x60
042BF4             0035*   
042BF4             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground 
042BF4             0037*   plot_lf_lr_fg: equ 0x60
042BF4             0038*   
042BF4             0039*   ; &70-&77 	112-119 	Parallelogram fill
042BF4             0040*   plot_pf: equ 0x70
042BF4             0041*   
042BF4             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground 
042BF4             0043*   plot_lf_r_non_fg: equ 0x78
042BF4             0044*   
042BF4             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
042BF4             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
042BF4             0047*   
042BF4             0048*   ; &90-&97 	144-151 	Circle outline
042BF4             0049*   plot_co: equ 0x90
042BF4             0050*   
042BF4             0051*   ; &98-&9F 	152-159 	Circle fill
042BF4             0052*   plot_cf: equ 0x98
042BF4             0053*   
042BF4             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
042BF4             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
042BF4             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
042BF4             0057*   
042BF4             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
042BF4             0059*   plot_rcm: equ 0xB8
042BF4             0060*   
042BF4             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
042BF4             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
042BF4             0063*   ; &D0-&D7 	208-215 	Not defined
042BF4             0064*   ; &D8-&DF 	216-223 	Not defined
042BF4             0065*   ; &E0-&E7 	224-231 	Not defined
042BF4             0066*   
042BF4             0067*   ; &E8-&EF 	232-239 	Bitmap plot 
042BF4             0068*   plot_bmp: equ 0xE8
042BF4             0069*   
042BF4             0070*   ; &F0-&F7 	240-247 	Not defined
042BF4             0071*   ; &F8-&FF 	248-255 	Not defined
042BF4             0072*   
042BF4             0073*   ;  Support added in Agon Console8 VDP 2.1.0  Support added in
042BF4             0074*   ; Agon Console8 VDP 2.2.0
042BF4             0075*   
042BF4             0076*   ; Within each group of eight plot codes, the effects are as follows:
042BF4             0077*   ; Plot code 	Effect
042BF4             0078*   ; 0 	Move relative
042BF4             0079*   mv_rel: equ 0
042BF4             0080*   
042BF4             0081*   ; 1 	Plot relative in current foreground colour
042BF4             0082*   dr_rel_fg: equ 1
042BF4             0083*   
042BF4             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
042BF4             0085*   ; 3 	Plot relative in current background colour
042BF4             0086*   dr_rel_bg: equ 3
042BF4             0087*   
042BF4             0088*   ; 4 	Move absolute
042BF4             0089*   mv_abs: equ 4
042BF4             0090*   
042BF4             0091*   ; 5 	Plot absolute in current foreground colour
042BF4             0092*   dr_abs_fg: equ 5
042BF4             0093*   
042BF4             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
042BF4             0095*   ; 7 	Plot absolute in current background colour
042BF4             0096*   dr_abs_bg: equ 7
042BF4             0097*   
042BF4             0098*   ; Codes 0-3 use the position data provided as part of the command
042BF4             0099*   ; as a relative position, adding the position given to the current
042BF4             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
042BF4             0101*   ; as part of the command as an absolute position, setting the current
042BF4             0102*   ; graphical cursor position to the position given.
042BF4             0103*   
042BF4             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
042BF4             0105*   ; current pixel colour. These operations cannot currently be supported
042BF4             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
042BF4             0107*   ; supported. Support for these codes may be added in a future version
042BF4             0108*   ; of the VDP firmware.
042BF4             0109*   
042BF4             0110*   ; 16 colour palette constants
042BF4             0111*   c_black: equ 0
042BF4             0112*   c_red_dk: equ 1
042BF4             0113*   c_green_dk: equ 2
042BF4             0114*   c_yellow_dk: equ 3
042BF4             0115*   c_blue_dk: equ 4
042BF4             0116*   c_magenta_dk: equ 5
042BF4             0117*   c_cyan_dk: equ 6
042BF4             0118*   c_grey: equ 7
042BF4             0119*   c_grey_dk: equ 8
042BF4             0120*   c_red: equ 9
042BF4             0121*   c_green: equ 10
042BF4             0122*   c_yellow: equ 11
042BF4             0123*   c_blue: equ 12
042BF4             0124*   c_magenta: equ 13
042BF4             0125*   c_cyan: equ 14
042BF4             0126*   c_white: equ 15
042BF4             0127*   
042BF4             0128*   ; GCOL paint modes
042BF4             0129*   ; The GCOL command (VDU 18, mode, colour) is used to set the paint mode for the PLOT
042BF4             0130*   ; command. The paint mode is used to control how the PLOT command interacts with the
042BF4             0131*   ; existing pixels on the screen.
042BF4             0132*   gcol_mode_col: equ %000000000 ; Set on-screen pixel to target colour value
042BF4             0133*   gcol_mode_or: equ %000000001 ; OR value with the on-screen pixel
042BF4             0134*   gcol_mode_and: equ %000000010 ; AND value with the on-screen pixel
042BF4             0135*   gcol_mode_xor: equ %000000011 ; EOR value with the on-screen pixel
042BF4             0136*   gcol_mode_inv: equ %000000100 ; Invert the on-screen pixel
042BF4             0137*   gcol_mode_non: equ %000000101 ; No operation
042BF4             0138*   gcol_mode_and_inv: equ %000000110 ; AND the inverse of the specified colour with the on-screen pixel
042BF4             0139*   gcol_mode_or_inv: equ %000000111 ; OR the inverse of the specified colour with the on-screen pixel
042BF4             0140*   
042BF4             0141*   ; VDU 25, mode, x; y;: PLOT command
042BF4             0142*   ; inputs: a=mode, bc=x0, de=y0
042BF4             0143*   vdu_plot:
042BF4 32 0E 2C 04 0144*       ld (@mode),a
042BF8 ED 43 0F 2C 0145*       ld (@x0),bc
       04          
042BFD ED 53 11 2C 0146*       ld (@y0),de
       04          
042C02 21 0D 2C 04 0147*   	ld hl,@cmd
042C06 01 06 00 00 0148*   	ld bc,@end-@cmd
042C0A 5B DF       0149*   	rst.lil $18
042C0C C9          0150*   	ret
042C0D 19          0151*   @cmd:   db 25
042C0E 00          0152*   @mode:  db 0
042C0F 00 00       0153*   @x0: 	dw 0
042C11 00 00       0154*   @y0: 	dw 0
042C13 00          0155*   @end:   db 0 ; extra byte to soak up deu
042C14             0156*   
042C14             0157*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042C14             0158*   ; &E8-&EF 	232-239 	Bitmap plot 
042C14             0159*   ; VDU 25, mode, x; y;: PLOT command
042C14             0160*   ; inputs: bc=x0, de=y0
042C14             0161*   ; prerequisites: vdu_buff_select
042C14             0162*   vdu_plot_bmp:
042C14 ED 43 2B 2C 0163*       ld (@x0),bc
       04          
042C19 ED 53 2D 2C 0164*       ld (@y0),de
       04          
042C1E 21 29 2C 04 0165*   	ld hl,@cmd
042C22 01 06 00 00 0166*   	ld bc,@end-@cmd
042C26 5B DF       0167*   	rst.lil $18
042C28 C9          0168*   	ret
042C29 19          0169*   @cmd:   db 25
042C2A ED          0170*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
042C2B 00 00       0171*   @x0: 	dw 0x0000
042C2D 00 00       0172*   @y0: 	dw 0x0000
042C2F 00          0173*   @end:   db 0x00 ; padding
042C30             0174*   
042C30             0175*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
042C30             0176*   ; &E8-&EF 	232-239 	Bitmap plot 
042C30             0177*   ; VDU 25, mode, x; y;: PLOT command
042C30             0178*   ; inputs: bc=x0, de=y0
042C30             0179*   ; USING 16.8 FIXED POINT COORDINATES
042C30             0180*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
042C30             0181*   ;   the fractional portiion of the inputs are truncated
042C30             0182*   ;   leaving only the 16-bit integer portion
042C30             0183*   ; prerequisites: vdu_buff_select
042C30             0184*   vdu_plot_bmp168:
042C30             0185*   ; populate in the reverse of normal to keep the
042C30             0186*   ; inputs from stomping on each other
042C30 ED 53 4E 2C 0187*       ld (@y0-1),de
       04          
042C35 ED 43 4C 2C 0188*       ld (@x0-1),bc
       04          
042C3A 3E ED       0189*       ld a,plot_bmp+dr_abs_fg ; 0xED
042C3C 32 4C 2C 04 0190*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
042C40 21 4B 2C 04 0191*   	ld hl,@cmd
042C44 01 06 00 00 0192*   	ld bc,@end-@cmd
042C48 5B DF       0193*   	rst.lil $18
042C4A C9          0194*   	ret
042C4B 19          0195*   @cmd:   db 25
042C4C ED          0196*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
042C4D 00 00       0197*   @x0: 	dw 0x0000
042C4F 00 00       0198*   @y0: 	dw 0x0000
042C51             0199*   @end:  ; no padding required b/c we shifted de right
042C51             0200*   
042C51             0201*   ; draw a filled rectangle
042C51             0202*   vdu_plot_rf:
042C51 ED 43 78 2C 0203*       ld (@x0),bc
       04          
042C56 ED 53 7A 2C 0204*       ld (@y0),de
       04          
042C5B DD 22 7E 2C 0205*       ld (@x1),ix
       04          
042C60 FD 22 80 2C 0206*       ld (@y1),iy
       04          
042C65 3E 19       0207*       ld a,25 ; we have to reload the 2nd plot command
042C67 32 7C 2C 04 0208*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
042C6B 21 76 2C 04 0209*   	ld hl,@cmd0
042C6F 01 0C 00 00 0210*   	ld bc,@end-@cmd0
042C73 5B DF       0211*   	rst.lil $18
042C75 C9          0212*       ret
042C76 19          0213*   @cmd0:  db 25 ; plot
042C77 04          0214*   @arg0:  db plot_sl_both+mv_abs
042C78 00 00       0215*   @x0:    dw 0x0000
042C7A 00 00       0216*   @y0:    dw 0x0000
042C7C 19          0217*   @cmd1:  db 25 ; plot
042C7D 65          0218*   @arg1:  db plot_rf+dr_abs_fg
042C7E 00 00       0219*   @x1:    dw 0x0000
042C80 00 00       0220*   @y1:    dw 0x0000
042C82 00          0221*   @end:   db 0x00 ; padding
042C83             0222*   
042C83             0223*   ; draw a filled circle
042C83             0224*   vdu_plot_cf:
042C83 ED 43 AA 2C 0225*       ld (@x0),bc
       04          
042C88 ED 53 AC 2C 0226*       ld (@y0),de
       04          
042C8D DD 22 B0 2C 0227*       ld (@x1),ix
       04          
042C92 FD 22 B2 2C 0228*       ld (@y1),iy
       04          
042C97 3E 19       0229*       ld a,25 ; we have to reload the 2nd plot command
042C99 32 AE 2C 04 0230*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
042C9D 21 A8 2C 04 0231*   	ld hl,@cmd0
042CA1 01 0C 00 00 0232*   	ld bc,@end-@cmd0
042CA5 5B DF       0233*   	rst.lil $18
042CA7 C9          0234*       ret
042CA8 19          0235*   @cmd0:  db 25 ; plot
042CA9 04          0236*   @arg0:  db plot_sl_both+mv_abs
042CAA 00 00       0237*   @x0:    dw 0x0000
042CAC 00 00       0238*   @y0:    dw 0x0000
042CAE 19          0239*   @cmd1:  db 25 ; plot
042CAF 9D          0240*   @arg1:  db plot_cf+dr_abs_fg
042CB0 00 00       0241*   @x1:    dw 0x0000
042CB2 00 00       0242*   @y1:    dw 0x0000
042CB4 00          0243*   @end:   db 0x00 ; padding
042CB5             0244*   
042CB5             0245*   ; draw an unfilled rectangle
042CB5             0246*   vdu_plot_rect:
042CB5 21 C0 2C 04 0247*       ld hl,@cmd
042CB9 01 1E 00 00 0248*       ld bc,@end-@cmd
042CBD 5B DF       0249*       rst.lil $18
042CBF C9          0250*       ret
042CC0             0251*   @cmd:
042CC0 19 04       0252*       db 25,mv_abs
042CC2 00 00       0253*       dw 0 ; x upper left
042CC4 00 00       0254*       dw 0 ; y upper left
042CC6 19 05       0255*       db 25,plot_sl_both+dr_abs_fg
042CC8 40 01       0256*       dw 320 ; x upper right
042CCA 00 00       0257*       dw 0 ; y upper right
042CCC 19 05       0258*       db 25,plot_sl_both+dr_abs_fg
042CCE 40 01       0259*       dw 320 ; x lower right
042CD0 F0 00       0260*       dw 240 ; y lower right
042CD2 19 05       0261*       db 25,plot_sl_both+dr_abs_fg
042CD4 00 00       0262*       dw 0 ; x lower left
042CD6 F0 00       0263*       dw 240 ; y lower left
042CD8 19 05       0264*       db 25,plot_sl_both+dr_abs_fg
042CDA 00 00       0265*       dw 0 ; x upper left
042CDC 00 00       0266*       dw 0 ; y upper left
042CDE             0267*   @end:
042CDE             0268*   ; end vdu_plot_rect
042CDE             0042        include "../agon/vdu_sound.inc"
042CDE             0001*   ; enable sound channels
042CDE             0002*   ; inputs: a = total num channels to be enabled
042CDE             0003*   ; returns: nothing
042CDE             0004*   ; destroys: af, bc, hl
042CDE             0005*   vdu_enable_channels:
042CDE 3D          0006*       dec a ; channels are zero-based
042CDF             0007*   @loop:
042CDF 32 F8 2C 04 0008*       ld (@channel),a
042CE3 21 F5 2C 04 0009*       ld hl,@beg
042CE7 01 05 00 00 0010*       ld bc,@end-@beg
042CEB F5          0011*       push af
042CEC 5B DF       0012*       rst.lil $18
042CEE F1          0013*       pop af
042CEF 3D          0014*       dec a
042CF0 C2 DF 2C 04 0015*       jp nz,@loop
042CF4 C9          0016*       ret
042CF5             0017*   @beg:
042CF5 17 00 85    0018*               db 23, 0, $85
042CF8 00          0019*   @channel:   db 0
042CF9 08          0020*               db 8 ; command 8: enable channel
042CFA             0021*   @end:
042CFA             0022*   
042CFA             0023*   ; disable all but the three default sound channels
042CFA             0024*   ; inputs: max_channels set
042CFA             0025*   ; outputs: none
042CFA             0026*   ; destroys: ah,hl,bc
042CFA             0027*   vdu_disable_channels:
042CFA 3E 01       0028*       ld a,max_channels
042CFC D6 03       0029*       sub 3 ; subtract number of default channels already enabled
042CFE F2 05 2D 04 0030*       jp p,@loop
042D02 C9          0031*       ret
042D03 3E 03       0032*       ld a,3 ; first non-default channel
042D05             0033*   @loop:
042D05 32 20 2D 04 0034*       ld (@channel),a
042D09 21 1D 2D 04 0035*       ld hl,@beg
042D0D 01 05 00 00 0036*       ld bc,@end-@beg
042D11 F5          0037*       push af
042D12 5B DF       0038*       rst.lil $18
042D14 F1          0039*       pop af
042D15 3C          0040*       inc a
042D16 FE 01       0041*       cp max_channels
042D18 C2 05 2D 04 0042*       jp nz,@loop
042D1C C9          0043*       ret
042D1D             0044*   @beg:
042D1D 17 00 85    0045*       db 23, 0, $85
042D20 00          0046*   @channel: db 0
042D21 09          0047*       db 9 ; command 9: disable channel
042D22             0048*   @end:
042D22             0049*   
042D22             0050*   
042D22             0051*   ; ############################################################
042D22             0052*   ; VDU SOUND API
042D22             0053*   ; ############################################################
042D22             0054*   ; Command 0: Play note
042D22             0055*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
042D22             0056*       MACRO PLAY_NOTE channel, volume, frequency, duration
042D22             0057*       ld hl, @PLAY_NOTE_CMD        ; Start of command block
042D22             0058*       ld bc, @PLAY_NOTE_END - @PLAY_NOTE_CMD  ; Command block size
042D22             0059*       rst.lil $18
042D22             0060*       jr @PLAY_NOTE_END
042D22             0061*   @PLAY_NOTE_CMD:  db 23, 0, 0x85               ; Command header
042D22             0062*                    db channel                  ; Channel, 0 (commented out)
042D22             0063*                    db 0                        ; Play note command
042D22             0064*                    db volume                   ; Volume
042D22             0065*                    dw frequency                ; Frequency
042D22             0066*                    dw duration                 ; Duration
042D22             0067*   @PLAY_NOTE_END:
042D22             0068*       ENDMACRO
042D22             0069*   
042D22             0070*       MACRO MUTE_CHANNEL channel
042D22             0071*       ld hl, @MUTE_CHANNEL_CMD     ; Start of command block
042D22             0072*       ld bc, @MUTE_CHANNEL_END - @MUTE_CHANNEL_CMD  ; Command block size
042D22             0073*       rst.lil $18
042D22             0074*       jr @MUTE_CHANNEL_END
042D22             0075*   @MUTE_CHANNEL_CMD: db 23, 0, 0x85             ; Command header
042D22             0076*                      db channel                ; Channel, 0 (commented out)
042D22             0077*                      db 2                      ; Set volume command
042D22             0078*                      db 0                      ; Volume (mute)
042D22             0079*   @MUTE_CHANNEL_END:
042D22             0080*       ENDMACRO
042D22             0081*   
042D22             0082*   ; inputs: c = channel, b = volume, hl = frequency; de = duration;
042D22             0083*   vdu_play_note:
042D22 79          0084*       ld a,c
042D23 32 43 2D 04 0085*       ld (@channel),a
042D27 78          0086*       ld a,b
042D28 32 45 2D 04 0087*       ld (@volume),a
042D2C 22 46 2D 04 0088*       ld (@frequency),hl
042D30 ED 53 48 2D 0089*       ld (@duration),de
       04          
042D35 21 40 2D 04 0090*       ld hl,@cmd
042D39 01 0A 00 00 0091*       ld bc,@end-@cmd
042D3D 5B DF       0092*       rst.lil $18
042D3F C9          0093*       ret
042D40 17 00 85    0094*   @cmd:       db 23, 0, 0x85
042D43 00          0095*   @channel:   db 0x00
042D44 00          0096*               db 0x00 ; play note command
042D45 00          0097*   @volume:    db 0x00
042D46 00 00       0098*   @frequency: dw 0x0000
042D48 00 00       0099*   @duration:  dw 0x0000
042D4A 00          0100*   @end:       db 0x00 ; padding
042D4B             0101*   
042D4B             0102*   ; Command 1: Status
042D4B             0103*   ; VDU 23, 0, &85, channel, 1
042D4B             0104*   ; inputs: a = channel
042D4B             0105*   ; Returns a bit mask indicating the status of the specified channel, or 255 if the channel is not valid, or has been disabled. The bit mask is as follows:
042D4B             0106*   ; Bit 	Name 	Meaning
042D4B             0107*   ; 0 	Active 	When set this indicates the channel is in use (has an active waveform)
042D4B             0108*   ; 1 	Playing 	Indicates the channel is actively playing a note, and thus will reject calls to play a new note
042D4B             0109*   ; 2 	Indefinite 	Set if the channel is playing an indefinite duration note
042D4B             0110*   ; 3 	Has Volume Envelope 	Set if the channel has a volume envelope
042D4B             0111*   ; 4 	Has Frequency Envelope 	Set if the channel has a frequency envelope
042D4B             0112*   
042D4B             0113*   ; Bits 5-7 are reserved for future use and, for enabled channels, will currently always be zero.
042D4B             0114*   vdu_channel_status:
042D4B 32 5D 2D 04 0115*       ld (@channel),a
042D4F 21 5A 2D 04 0116*       ld hl,@cmd
042D53 01 05 00 00 0117*       ld bc,@end-@cmd
042D57 5B DF       0118*       rst.lil $18
042D59 C9          0119*       ret
042D5A 17 00 85    0120*   @cmd:       db 23, 0, 0x85
042D5D 00          0121*   @channel:   db 0x00
042D5E 01          0122*               db 0x01 ; get channel status command
042D5F             0123*   @end:
042D5F             0124*   
042D5F             0125*   ; VDU 23, 0, &85, channel, 2, volume
042D5F             0126*   ; inputs: c = channel, b = volume
042D5F             0127*   ; Sets the volume of the specified channel. The volume is a value from 0 to 127, where 0 is silent and 127 is full volume. Values over 127 will be treated as 127 (with one exception described later).
042D5F             0128*   
042D5F             0129*   ; Specifying a channel of -1 (or 255) will set the global sound system volume level. (Requires Console8 VDP 2.5.0 or later.)
042D5F             0130*   
042D5F             0131*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the volume of a channel that is already playing a note.
042D5F             0132*   vdu_channel_volume:
042D5F 79          0133*       ld a,c
042D60 32 77 2D 04 0134*       ld (@channel),a
042D64 78          0135*       ld a,b
042D65 32 79 2D 04 0136*       ld (@volume),a
042D69 21 74 2D 04 0137*       ld hl,@cmd
042D6D 01 06 00 00 0138*       ld bc,@end-@cmd
042D71 5B DF       0139*       rst.lil $18
042D73 C9          0140*       ret
042D74 17 00 85    0141*   @cmd:       db 23, 0, 0x85
042D77 00          0142*   @channel:   db 0x00
042D78 02          0143*               db 0x02 ; set volume command
042D79 00          0144*   @volume:    db 0x00
042D7A             0145*   @end:
042D7A             0146*   
042D7A             0147*   ; VDU 23, 0, &85, channel, 3, frequency;
042D7A             0148*   
042D7A             0149*   ; Sets the frequency of the specified channel. The frequency is a 16-bit value specifying in Hz the frequency of the note to be played.
042D7A             0150*   
042D7A             0151*   ; Using this command provides more direct control over a channel than the play note command. It can be used to adjust the frequency of a channel that is already playing a note.
042D7A             0152*   
042D7A             0153*   ; Returns 1 on success, 0 for failure.
042D7A             0154*   vdu_channel_frequency:
042D7A 79          0155*       ld a,c
042D7B 32 92 2D 04 0156*       ld (@channel),a
042D7F ED 53 94 2D 0157*       ld (@frequency),de
       04          
042D84 21 8F 2D 04 0158*       ld hl,@cmd
042D88 01 07 00 00 0159*       ld bc,@end-@cmd
042D8C 5B DF       0160*       rst.lil $18
042D8E C9          0161*       ret
042D8F 17 00 85    0162*   @cmd:       db 23, 0, 0x85
042D92 00          0163*   @channel:   db 0x00
042D93 03          0164*               db 0x03 ; set frequency command
042D94 00 00       0165*   @frequency: dw 0x0000
042D96 00          0166*   @end:       db 0x00 ; padding
042D97             0167*   
042D97             0168*   
042D97             0169*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
042D97             0170*   ; inputs: c = channel, b = waveformOrSample, [hl = bufferId]
042D97             0171*   ; Sets the waveform type for a channel to use. The waveformOrSample value is a single byte treated as a signed value.
042D97             0172*   
042D97             0173*   ; Using a negative value for the waveform indicates that a sample should be used instead. For more information see the documentation for the sample command.
042D97             0174*   
042D97             0175*   ; By default a channel is set to use waveform 0 (square wave).
042D97             0176*   
042D97             0177*   ; Valid waveform values are as follows:
042D97             0178*   ; Value 	Waveform
042D97             0179*   ; 0 	Square wave
042D97             0180*   ; 1 	Triangle wave
042D97             0181*   ; 2 	Sawtooth wave
042D97             0182*   ; 3 	Sine wave
042D97             0183*   ; 4 	Noise (simple white noise with no frequency support)
042D97             0184*   ; 5 	VIC Noise (emulates a VIC6561; supports frequency)
042D97             0185*   ; 8 	Sample (specifying a 16-bit buffer ID for sample data)
042D97             0186*   
042D97             0187*   vdu_channel_waveform:
042D97 79          0188*       ld a,c
042D98 32 BD 2D 04 0189*       ld (@channel),a
042D9C 78          0190*       ld a,b
042D9D 32 BF 2D 04 0191*       ld (@waveform),a
042DA1 FE 08       0192*       cp 8 ; check if the waveform is a sample
042DA3 28 06       0193*       jr z, @sample
042DA5 01 06 00 00 0194*       ld bc,@bufferId-@cmd
042DA9 18 08       0195*       jr @sendToVdu
042DAB             0196*   @sample:
042DAB 22 C0 2D 04 0197*       ld (@bufferId),hl
042DAF 01 08 00 00 0198*       ld bc,@end-@cmd
042DB3             0199*   @sendToVdu:
042DB3 21 BA 2D 04 0200*       ld hl,@cmd
042DB7 5B DF       0201*       rst.lil $18
042DB9 C9          0202*       ret
042DBA 17 00 85    0203*   @cmd:       db 23, 0, 0x85
042DBD 00          0204*   @channel:   db 0x00
042DBE 04          0205*               db 0x04 ; set waveform command
042DBF 00          0206*   @waveform:  db 0x00
042DC0 00 00       0207*   @bufferId:  dw 0x0000
042DC2 00          0208*   @end:       db 0x00 ; padding
042DC3             0209*   
042DC3             0210*   ; VDU 23, 0, &85, channel (ignored), 5, 2, bufferId; format, [sampleRate;]
042DC3             0211*   ; inputs: hl = bufferId; a = format, de = sample rate in Hz
042DC3             0212*   ; The format is a single byte giving the format of the sample data. The following formats are supported:
042DC3             0213*   ; Value	Description
042DC3             0214*   ; 0	8-bit signed
042DC3             0215*   ; 1	8-bit unsigned
042DC3             0216*   ; The format value can also have modifier bits set to modify the behaviour of the sample. The following modifier bits are supported:
042DC3             0217*   ; Value	Description
042DC3             0218*   ; 8	sample rate is sent in the next 16-bits
042DC3             0219*   ; 16	sample is tuneable
042DC3             0220*   ; The default sample rate for samples on the VDP is 16kHz (actually 16.384kHz to be precise).
042DC3             0221*   vdu_buffer_to_sound:
042DC3 22 E3 2D 04 0222*       ld (@bufferId),hl
042DC7 C6 08       0223*       add a,8 ; modify format byte to indicate sample rate argument is given
042DC9 32 E5 2D 04 0224*       ld (@format),a
042DCD ED 53 E6 2D 0225*       ld (@sampleRate),de
       04          
042DD2 21 DD 2D 04 0226*       ld hl,@cmd
042DD6 01 0B 00 00 0227*       ld bc,@end-@cmd
042DDA 5B DF       0228*       rst.lil $18
042DDC C9          0229*       ret
042DDD 17 00 85    0230*   @cmd:       db 23, 0, 0x85
042DE0 00          0231*   @channel:   db 0x00 ; ignored
042DE1 05          0232*               db 0x05 ; buffer to sound command
042DE2 02          0233*               db 0x02 ; command 2 create sample
042DE3 00 00       0234*   @bufferId:  dw 0x0000
042DE5 00          0235*   @format:    db 0x00
042DE6 00 00       0236*   @sampleRate: dw 0x0000
042DE8 00          0237*   @end:       db 0x00 ; padding
042DE9             0238*   
042DE9             0239*   ; Command 13: Set sample rate
042DE9             0240*   ; VDU 23, 0, &85, channel, 13, sampleRate;
042DE9             0241*   ; inputs: c = channel, hl = sampleRate (Hz)
042DE9             0242*   vdu_set_sample_rate:
042DE9 79          0243*       ld a,c
042DEA 32 00 2E 04 0244*       ld (@channel),a
042DEE 22 02 2E 04 0245*       ld (@sampleRate),hl
042DF2 21 FD 2D 04 0246*       ld hl,@cmd
042DF6 01 07 00 00 0247*       ld bc,@end-@cmd
042DFA 5B DF       0248*       rst.lil $18
042DFC C9          0249*       ret
042DFD 17 00 85    0250*   @cmd:       db 23, 0, 0x85
042E00 00          0251*   @channel:   db 0x00
042E01 0D          0252*               db 13 ; set sample rate command
042E02 00 00       0253*   @sampleRate: dw 0x0000
042E04 00          0254*   @end:       db 0x00 ; padding
042E05             0255*   
042E05             0256*   ; load a sound file to a buffer
042E05             0257*   ; inputs: hl = bufferId ; de = sampleRate in Hz ; iy = pointer to filename
042E05             0258*   vdu_load_sfx:
042E05             0259*   ; back up input parameters
042E05 E5          0260*       push hl ; bufferId
042E06 D5          0261*       push de ; sample rate
042E07             0262*   ; load the sound
042E07 CD 3C 31 04 0263*       call vdu_load_buffer_from_file
042E0B             0264*   ; now make the buffer a sound sample
042E0B D1          0265*       pop de ; sample rate
042E0C E1          0266*       pop hl ; bufferId
042E0D AF          0267*       xor a ; zero is the magic number for mono 8-bit signed PCM
042E0E CD C3 2D 04 0268*       call vdu_buffer_to_sound
042E12 C9          0269*       ret
042E13             0270*   
042E13             0271*   
042E13 00          0272*   last_channel: db 0
042E14             0273*   max_channels: equ 1
042E14             0274*   
042E14             0275*   ; play a sound effect from an already loaded buffer
042E14             0276*   ; inputs: hl = bufferId ; bc = duration in milliseconds
042E14             0277*   vdu_play_sfx:
042E14 22 4C 2E 04 0278*       ld (@bufferId),hl
042E18 ED 43 56 2E 0279*       ld (@duration),bc
       04          
042E1D 3E 17       0280*       ld a,23
042E1F 32 4E 2E 04 0281*       ld (@bufferId+2),a
042E23 3A 13 2E 04 0282*       ld a,(last_channel)
042E27 3C          0283*       inc a
042E28             0284*       ; and 31 ; modulo 32
042E28 FE 01       0285*       cp max_channels
042E2A C2 2F 2E 04 0286*       jp nz,@load_channel
042E2E AF          0287*       xor a
042E2F             0288*   @load_channel:
042E2F 32 13 2E 04 0289*       ld (last_channel),a
042E33 32 49 2E 04 0290*       ld (@channel0),a
042E37 32 51 2E 04 0291*       ld (@channel1),a
042E3B 21 46 2E 04 0292*       ld hl, @sample
042E3F 01 12 00 00 0293*       ld bc, @sample_end - @sample
042E43 5B DF       0294*       rst.lil $18
042E45 C9          0295*       ret
042E46             0296*   @sample:
042E46             0297*   ; Command 4: Set waveform
042E46             0298*   ; VDU 23, 0, &85, channel, 4, waveformOrSample, [bufferId;]
042E46 17 00 85    0299*       .db 23,0,$85                        ; do sound
042E49             0300*   @channel0:
042E49 00 04 08    0301*       .db 0,4,8 ; channel, command, waveform
042E4C             0302*   @bufferId:
042E4C 00 00       0303*       .dw 0x0000
042E4E             0304*   ; Command 0: Play note
042E4E             0305*   ; VDU 23, 0, &85, channel, 0, volume, frequency; duration;
042E4E 17 00 85    0306*       .db 23,0,$85                        ; do sound
042E51             0307*   @channel1:
042E51 00 00 7F    0308*       .db 0,0,127                ; channel, volume
042E54 00 00       0309*       .dw 0
042E56             0310*   @duration:                              ; freq (tuneable samples only)
042E56 00 00       0311*       .dw 0x0000                        ; duration
042E58             0312*   @sample_end:
042E58 00          0313*       .db 0x00 ; padding
042E59             0314*   
042E59             0315*   ; inputs: c = channel, b = volume, de = sample rate; hl = bufferId;
042E59             0316*   vdu_play_sample:
042E59             0317*       ; populate input parameters
042E59 79          0318*       ld a,c
042E5A 32 8C 2E 04 0319*       ld (@channel0),a
042E5E 32 94 2E 04 0320*       ld (@channel1),a
042E62 32 9B 2E 04 0321*       ld (@channel2),a
042E66 78          0322*       ld a,b
042E67 32 9D 2E 04 0323*       ld (@volume),a
042E6B ED 53 96 2E 0324*       ld (@sampleRate),de
       04          
042E70 22 8F 2E 04 0325*       ld (@bufferId),hl
042E74 3E 17       0326*       ld a,23
042E76 32 91 2E 04 0327*       ld (@cmd1),a
042E7A 32 98 2E 04 0328*       ld (@cmd2),a
042E7E             0329*       ; prep the vdu command string
042E7E 21 89 2E 04 0330*       ld hl, @cmd0
042E82 01 19 00 00 0331*       ld bc, @end - @cmd0
042E86 5B DF       0332*       rst.lil $18
042E88 C9          0333*       ret
042E89             0334*   ; set waveform command
042E89 17 00 85    0335*   @cmd0:       db 23, 0, 0x85
042E8C 00          0336*   @channel0:   db 0x00
042E8D 04          0337*                db 0x04 ; set waveform command
042E8E 08          0338*   @waveform:   db 0x08 ; sample
042E8F 00 00       0339*   @bufferId:   dw 0x0000
042E91             0340*   ; set sample rate command
042E91 17 00 85    0341*   @cmd1:       db 23, 0, 0x85
042E94 00          0342*   @channel1:   db 0x00
042E95 0D          0343*               db 13 ; set sample rate command
042E96 00 00       0344*   @sampleRate: dw 0x0000
042E98             0345*   ; play note command
042E98 17 00 85    0346*   @cmd2:       db 23, 0, 0x85
042E9B 00          0347*   @channel2:   db 0x00
042E9C 00          0348*                db 0x00 ; play note command
042E9D 00          0349*   @volume:     db 0x00
042E9E 00 00       0350*   @frequency:  dw 0x00 ; no effect unless buffer has been set to tuneable sample
042EA0 00 00       0351*   @duration:   dw 0x0000 ; milliseconds: set to -1 to loop indefinitely, 0 to play full duration once
042EA2 00          0352*   @end:        db 0x00 ; padding
042EA3             0043        include "../agon/vdu.inc"
042EA3             0001*       MACRO VDU_BEEP
042EA3             0002*       ld a,7
042EA3             0003*       rst.lil $10
042EA3             0004*       ENDMACRO
042EA3             0005*   
042EA3             0006*   ; VDU 30: Home cursor
042EA3             0007*   vdu_home_cursor:
042EA3 3E 1E       0008*       ld a,30
042EA5 5B D7       0009*   	rst.lil $10
042EA7 C9          0010*   	ret
042EA8             0011*   
042EA8             0012*   vdu_cursor_on:
042EA8 21 B3 2E 04 0013*   	ld hl,@cmd
042EAC 01 03 00 00 0014*   	ld bc,@end-@cmd
042EB0 5B DF       0015*   	rst.lil $18
042EB2 C9          0016*   	ret
042EB3             0017*   @cmd:
042EB3 17 01 01    0018*   	db 23,1,1
042EB6             0019*   @end:
042EB6             0020*   
042EB6             0021*   vdu_cursor_off:
042EB6 21 C1 2E 04 0022*   	ld hl,@cmd
042EBA 01 03 00 00 0023*   	ld bc,@end-@cmd
042EBE 5B DF       0024*   	rst.lil $18
042EC0 C9          0025*   	ret
042EC1             0026*   @cmd:
042EC1 17 01 00    0027*   	db 23,1,0
042EC4             0028*   @end:
042EC4             0029*   
042EC4             0030*   ; VDU 4: Write text at text cursor
042EC4             0031*   ; This causes text to be written at th current text cursor position. This is the default mode for text display.
042EC4             0032*   ; inputs: none
042EC4             0033*   ; prerequisites: the text cursor at the intended position on screen
042EC4             0034*   ; outputs: none
042EC4             0035*   ; destroys: af
042EC4             0036*   vdu_text_to_text_cursor:
042EC4 3E 04       0037*       ld a,4
042EC6 5B D7       0038*       rst.lil $10
042EC8 C9          0039*       ret
042EC9             0040*   ; end vdu_text_to_text_cursor
042EC9             0041*   
042EC9             0042*   ; set the text cursor to a specified location and print a string there
042EC9             0043*   ; inputs: hl = address of string to print, c,b = x,y text coordinates
042EC9             0044*   ; outputs: text
042EC9             0045*   ; destroys: af, bc, hl
042EC9             0046*   ; affects: moves text cursor to position after final char printed by default
042EC9             0047*   ;          unless overridden by VDU 23, 16 cursor control command settings
042EC9             0048*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the text cursor
042EC9             0049*   vdu_print_to_text_location:
042EC9 E5          0050*       push hl ; preserve string pointer
042ECA 3E 04       0051*       ld a,4 ; VDU 4 char to text cursor
042ECC 5B D7       0052*       rst.lil $10
042ECE CD 06 2F 04 0053*       call vdu_move_cursor
042ED2 E1          0054*       pop hl ; restore string pointer
042ED3 CD EC 20 04 0055*       call printString
042ED7 C9          0056*       ret
042ED8             0057*   ; end vdu_print_at_text_location
042ED8             0058*   
042ED8             0059*   ; VDU 5: Write text at graphics cursor
042ED8             0060*   ; inputs: none
042ED8             0061*   ; prerequisites: the graphics cursor at the intended position on screen
042ED8             0062*   ; outputs: none
042ED8             0063*   ; destroys: af
042ED8             0064*   vdu_text_to_gfx_cursor:
042ED8 3E 05       0065*       ld a,5
042EDA 5B D7       0066*   	rst.lil $10
042EDC C9          0067*   	ret
042EDD             0068*   ; end vdu_char_to_gfx_cursor
042EDD             0069*   
042EDD             0070*   ; set the graphics cursor to a specified location and print a string there
042EDD             0071*   ; inputs: hl = address of string to print, bc,de = x,y graphics coordinates
042EDD             0072*   ; outputs: text
042EDD             0073*   ; destroys: af, bc, de, hl
042EDD             0074*   ; affects: moves graphics cursor to position after final char printed by default
042EDD             0075*   ;          unless overridden by setting bit 6 of the cursor control register (VDU 23, 16)
042EDD             0076*   ;          all subsequent print commands (rst.lil $10 or $18) will go to the graphics cursor
042EDD             0077*   vdu_print_to_gfx_location:
042EDD E5          0078*       push hl ; preserve string pointer
042EDE 3E 44       0079*       ld a,plot_pt+mv_abs
042EE0 CD F4 2B 04 0080*       call vdu_plot ; moves the graphics cursor to the specified location
042EE4 3E 05       0081*       ld a,5 ; VDU 5 char to gfx cursor
042EE6 5B D7       0082*       rst.lil $10
042EE8 E1          0083*       pop hl ; restore string pointer
042EE9 01 00 00 00 0084*       ld bc,0
042EED 3E 00       0085*       ld a,0
042EEF 5B DF       0086*       rst.lil $18 ; print the string
042EF1 C9          0087*       ret
042EF2             0088*   ; end vdu_print_at_gfx_location
042EF2             0089*   
042EF2             0090*   ; VDU 8: Move cursor back one character
042EF2             0091*   vdu_cursor_back:
042EF2 3E 08       0092*       ld a,8
042EF4 5B D7       0093*       rst.lil $10
042EF6 C9          0094*       ret
042EF7             0095*   ; end vdu_cursor_back
042EF7             0096*   
042EF7             0097*   ; VDU 9: Move cursor forward one character
042EF7             0098*   vdu_cursor_forward:
042EF7 3E 09       0099*       ld a,9
042EF9 5B D7       0100*   	rst.lil $10
042EFB C9          0101*   	ret
042EFC             0102*   ; end vdu_cursor_forward
042EFC             0103*   
042EFC             0104*   ; VDU 10: Move cursor down one line
042EFC             0105*   vdu_cursor_down:
042EFC 3E 0A       0106*       ld a,10
042EFE 5B D7       0107*       rst.lil $10
042F00 C9          0108*       ret
042F01             0109*   ; end vdu_cursor_down
042F01             0110*   
042F01             0111*   ; VDU 11: Move cursor up one line
042F01             0112*   vdu_cursor_up:
042F01 3E 0B       0113*       ld a,11
042F03 5B D7       0114*       rst.lil $10
042F05 C9          0115*       ret
042F06             0116*   ; end vdu_cursor_up
042F06             0117*   
042F06             0118*   
042F06             0119*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
042F06             0120*   ; inputs: c=x, b=y 8-bit unsigned integers
042F06             0121*   vdu_move_cursor:
042F06 ED 43 17 2F 0122*       ld (@x0),bc
       04          
042F0B 21 16 2F 04 0123*   	ld hl,@cmd
042F0F 01 03 00 00 0124*   	ld bc,@end-@cmd
042F13 5B DF       0125*   	rst.lil $18
042F15 C9          0126*   	ret
042F16 1F          0127*   @cmd: 	db 31
042F17 00          0128*   @x0:	db 0
042F18 00          0129*   @y0: 	db 0
042F19 00          0130*   @end: 	db 0 ; padding
042F1A             0131*   
042F1A             0132*   ; https://agonconsole8.github.io/agon-docs/vdp/VDU-Commands/#vdu-23-1-n-cursor-control
042F1A             0133*   ; VDU 23, 16, setting, mask: Define cursor movement behaviour
042F1A             0134*   ; inputs: l = setting, h = mask
042F1A             0135*   ; new_setting = (current_setting AND mask) EOR setting
042F1A             0136*   ; in English: mask controls which bit to turn on or off, setting is the value of the bits to set or reset
042F1A             0137*   vdu_cursor_behaviour:
042F1A 22 2B 2F 04 0138*       ld (@setting),hl ; little-endian!
042F1E 21 29 2F 04 0139*       ld hl,@cmd
042F22 01 04 00 00 0140*       ld bc,@end-@cmd
042F26 5B DF       0141*       rst.lil $18
042F28 C9          0142*       ret
042F29 17 10       0143*   @cmd: db 23,16
042F2B 00          0144*   @setting: db 0
042F2C 00          0145*   @mask: db 0
042F2D 00          0146*   @end: db 0 ; padding
042F2E             0147*   
042F2E             0148*   ; VDU 12: Clear text area (CLS)
042F2E             0149*   vdu_cls:
042F2E 3E 0C       0150*       ld a,12
042F30 5B D7       0151*   	rst.lil $10
042F32 C9          0152*   	ret
042F33             0153*   
042F33             0154*   vdu_flip:
042F33 21 3E 2F 04 0155*   	ld hl,@cmd
042F37 01 03 00 00 0156*   	ld bc,@end-@cmd
042F3B 5B DF       0157*   	rst.lil $18
042F3D C9          0158*   	ret
042F3E 17 00 C3    0159*   @cmd: db 23,0,0xC3
042F41             0160*   @end:
042F41             0161*   
042F41             0162*   ; VDU 16: Clear graphics area (CLG)
042F41             0163*   vdu_clg:
042F41 3E 10       0164*       ld a,16
042F43 5B D7       0165*   	rst.lil $10
042F45 C9          0166*   	ret
042F46             0167*   
042F46             0168*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
042F46             0169*   ; VDU 23, 7: Scrolling
042F46             0170*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
042F46             0171*   ; inputs: a, extent; l, direction; h; speed
042F46             0172*   vdu_scroll_down:
042F46 32 5B 2F 04 0173*   	ld (@extent),a
042F4A 22 5C 2F 04 0174*   	ld (@dir),hl ; implicitly populates @speed
042F4E 21 59 2F 04 0175*   	ld hl,@cmd
042F52 01 05 00 00 0176*   	ld bc,@end-@cmd
042F56 5B DF       0177*   	rst.lil $18     ;; Sending command to VDP
042F58 C9          0178*   	ret
042F59 17 07       0179*   @cmd:       db 23,7
042F5B 00          0180*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
042F5C 00          0181*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
042F5D 00          0182*   @speed:     db 0x00 ; pixels
042F5E 00          0183*   @end:		db 0x00 ; padding
042F5F             0184*   
042F5F             0185*   ; COLOUR MODES
042F5F             0186*   ; Mode	Effect
042F5F             0187*   ; 0	Set on-screen pixel to target colour value
042F5F             0188*   ; 1	OR value with the on-screen pixel
042F5F             0189*   ; 2	AND value with the on-screen pixel
042F5F             0190*   ; 3	XOR value with the on-screen pixel
042F5F             0191*   ; 4	Invert the on-screen pixel
042F5F             0192*   ; 5	No operation
042F5F             0193*   ; 6	AND the inverse of the specified colour with the on-screen pixel
042F5F             0194*   ; 7	OR the inverse of the specified colour with the on-screen pixel
042F5F             0195*   
042F5F             0196*   ; VDU 17, colour: Define text colour (COLOUR)
042F5F             0197*   vdu_colour_text:
042F5F 32 6F 2F 04 0198*   	ld (@arg),a
042F63 21 6E 2F 04 0199*   	ld hl,@cmd
042F67 01 02 00 00 0200*   	ld bc,@end-@cmd
042F6B 5B DF       0201*   	rst.lil $18
042F6D C9          0202*   	ret
042F6E 11          0203*   @cmd: db 17
042F6F 00          0204*   @arg: db 0
042F70             0205*   @end:
042F70             0206*   
042F70             0207*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
042F70             0208*   ; inputs: a=mode, c=colour (add 128 to set background colour)
042F70             0209*   vdu_gcol:
042F70 32 85 2F 04 0210*   	ld (@mode),a
042F74 79          0211*       ld a,c
042F75 32 86 2F 04 0212*       ld (@col),a
042F79 21 84 2F 04 0213*   	ld hl,@cmd
042F7D 01 03 00 00 0214*   	ld bc,@end-@cmd
042F81 5B DF       0215*   	rst.lil $18
042F83 C9          0216*   	ret
042F84 12          0217*   @cmd:  db 18
042F85 00          0218*   @mode: db 0
042F86 00          0219*   @col:  db 0
042F87             0220*   @end:
042F87             0221*   
042F87             0222*   
042F87             0223*   ; VDU 28, left, bottom, right, top: Set text viewport **
042F87             0224*   ; MIND THE LITTLE-ENDIANESS
042F87             0225*   ; inputs: c=left,b=bottom,e=right,d=top
042F87             0226*   ; outputs; nothing
042F87             0227*   ; destroys: af, hl, bc, de
042F87             0228*   vdu_set_txt_viewport:
042F87 ED 43 9D 2F 0229*       ld (@lb),bc
       04          
042F8C ED 53 9F 2F 0230*   	ld (@rt),de
       04          
042F91 21 9C 2F 04 0231*   	ld hl,@cmd
042F95 01 05 00 00 0232*   	ld bc,@end-@cmd
042F99 5B DF       0233*   	rst.lil $18
042F9B C9          0234*   	ret
042F9C 1C          0235*   @cmd:   db 28 ; set text viewport command
042F9D 00 00       0236*   @lb: 	dw 0x0000 ; set by bc
042F9F 00 00       0237*   @rt: 	dw 0x0000 ; set by de
042FA1 00          0238*   @end:   db 0x00	  ; padding
042FA2             0239*   
042FA2             0240*   ; Wait for VBLANK interrupt
042FA2             0241*   vdu_vblank:
042FA2 DD E5       0242*       PUSH 	IX
042FA4             0243*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
042FA4 3E 08       0001*M1 			LD	A, function
042FA6 5B CF       0002*M1 			RST.LIL	08h
042FA8 DD 7E 00    0244*   	LD	A, (IX + sysvar_time + 0)
042FAB             0245*   @wait:
042FAB DD BE 00    0246*       CP 	A, (IX + sysvar_time + 0)
042FAE 28 FB       0247*       JR	Z, @wait
042FB0 DD E1       0248*       POP	IX
042FB2 C9          0249*       RET
042FB3             0250*   
042FB3             0251*   ; VDU 29, x; y;: Set graphics origin
042FB3             0252*   ; This command sets the graphics origin.
042FB3             0253*   ; The origin is the point on the screen where the coordinates (0,0) are located.
042FB3             0254*   ; inputs: bc=x0,de=y0
042FB3             0255*   ; outputs; nothing
042FB3             0256*   ; destroys: a might make it out alive
042FB3             0257*   vdu_set_gfx_origin:
042FB3 ED 43 C9 2F 0258*       ld (@x0),bc
       04          
042FB8 ED 53 CB 2F 0259*       ld (@y0),de
       04          
042FBD 21 C8 2F 04 0260*       ld hl,@cmd
042FC1 01 05 00 00 0261*       ld bc,@end-@cmd
042FC5 5B DF       0262*       rst.lil $18
042FC7 C9          0263*       ret
042FC8 1D          0264*   @cmd:   db 29 ; set graphics origin command
042FC9 00 00       0265*   @x0: 	dw 0x0000 ; set by bc
042FCB 00 00       0266*   @y0: 	dw 0x0000 ; set by de
042FCD 00          0267*   @end:   db 0x00	  ; padding
042FCE             0268*   
042FCE             0269*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
042FCE             0270*   ; NOTE: the order of the y-coordinate parameters are inverted
042FCE             0271*   ; 	because we have turned off logical screen scaling
042FCE             0272*   ; NOTE: coordinates are relative to current gfx origin
042FCE             0273*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
042FCE             0274*   ; outputs; nothing
042FCE             0275*   ; destroys: a might make it out alive
042FCE             0276*   vdu_set_gfx_viewport:
042FCE ED 43 EE 2F 0277*       ld (@x0),bc
       04          
042FD3 FD 22 F0 2F 0278*       ld (@y1),iy
       04          
042FD8 DD 22 F2 2F 0279*   	ld (@x1),ix
       04          
042FDD ED 53 F4 2F 0280*   	ld (@y0),de
       04          
042FE2 21 ED 2F 04 0281*   	ld hl,@cmd
042FE6 01 09 00 00 0282*   	ld bc,@end-@cmd
042FEA 5B DF       0283*   	rst.lil $18
042FEC C9          0284*   	ret
042FED 18          0285*   @cmd:   db 24 ; set graphics viewport command
042FEE 00 00       0286*   @x0: 	dw 0x0000 ; set by bc
042FF0 00 00       0287*   @y1: 	dw 0x0000 ; set by iy
042FF2 00 00       0288*   @x1: 	dw 0x0000 ; set by ix
042FF4 00 00       0289*   @y0: 	dw 0x0000 ; set by de
042FF6 00          0290*   @end:   db 0x00	  ; padding
042FF7             0291*   
042FF7             0292*   ; VDU 26: Reset graphics and text viewports
042FF7             0293*   vdu_reset_viewports:
042FF7 3E 1A       0294*       ld a,26
042FF9 5B D7       0295*       rst.lil $10
042FFB C9          0296*       ret
042FFC             0297*   
042FFC             0298*   ; SCREEN MODES
042FFC             0299*   ; ===============================
042FFC             0300*   ; Mode  Horz  Vert  Cols  Refresh
042FFC             0301*   ; ---   ----  ----  ----  -------
042FFC             0302*   ; 11    320   240   2     60hz
042FFC             0303*   ; 139   320   240   2     60hz
042FFC             0304*   ; 23    512   384   2     60hz
042FFC             0305*   ; 151   512   384   2     60hz
042FFC             0306*   ; 6     640   240   2     60hz
042FFC             0307*   ; 134   640   240   2     60hz
042FFC             0308*   ; 2     640   480   2     60hz
042FFC             0309*   ; 130   640   480   2     60hz
042FFC             0310*   ; 17    800   600   2     60hz
042FFC             0311*   ; 145   800   600   2     60hz
042FFC             0312*   ; 18    1024  768   2     60hz
042FFC             0313*   ; 146   1024  768   2     60hz
042FFC             0314*   ; ---   ----  ----  ----  -------
042FFC             0315*   ; 10    320   240   4     60hz
042FFC             0316*   ; 138   320   240   4     60hz
042FFC             0317*   ; 22    512   384   4     60hz
042FFC             0318*   ; 150   512   384   4     60hz
042FFC             0319*   ; 5     640   240   4     60hz
042FFC             0320*   ; 133   640   240   4     60hz
042FFC             0321*   ; 1     640   480   4     60hz
042FFC             0322*   ; 129   640   480   4     60hz
042FFC             0323*   ; 16    800   600   4     60hz
042FFC             0324*   ; 19    1024  768   4     60hz
042FFC             0325*   ; ---   ----  ----  ----  -------
042FFC             0326*   ; 9     320   240   16    60hz
042FFC             0327*   ; 137   320   240   16    60hz
042FFC             0328*   ; 21    512   384   16    60hz
042FFC             0329*   ; 149   512   384   16    60hz
042FFC             0330*   ; 4     640   240   16    60hz
042FFC             0331*   ; 132   640   240   16    60hz
042FFC             0332*   ; 0     640   480   16    60hz
042FFC             0333*   ; 7     n/a   n/a   16    60hz
042FFC             0334*   ; ---   ----  ----  ----  -------
042FFC             0335*   ; 8     320   240   64    60hz
042FFC             0336*   ; 136   320   240   64    60hz
042FFC             0337*   ; 20    512   384   64    60hz
042FFC             0338*   ; 3     640   240   64    60hz
042FFC             0339*   ; ---   ----  ----  ----  -------
042FFC             0340*   vdu_set_screen_mode:
042FFC 32 0C 30 04 0341*   	ld (@arg),a
043000 21 0B 30 04 0342*   	ld hl,@cmd
043004 01 02 00 00 0343*   	ld bc,@end-@cmd
043008 5B DF       0344*   	rst.lil $18
04300A C9          0345*   	ret
04300B 16          0346*   @cmd: db 22 ; set screen mode
04300C 00          0347*   @arg: db 0  ; screen mode parameter
04300D             0348*   @end:
04300D             0349*   
04300D             0350*   ; get the current screen mode
04300D             0351*   ; inputs: none
04300D             0352*   ; outputs: a=screen mode
04300D             0353*   ; destroys: af, ix
04300D             0354*   vdu_get_screen_mode:
04300D             0355*       MOSCALL mos_sysvars
                       M1 Args: function=mos_sysvars 
04300D 3E 08       0001*M1 			LD	A, function
04300F 5B CF       0002*M1 			RST.LIL	08h
043011 DD 7E 27    0356*       ld a,(IX+sysvar_scrMode)
043014 C9          0357*       ret
043015             0358*   ; end vdu_get_screen_mode
043015             0359*   
043015             0360*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
043015             0361*   ; inputs: a is scaling mode, 1=on, 0=off
043015             0362*   ; note: default setting on boot is scaling ON
043015             0363*   vdu_set_scaling:
043015 32 27 30 04 0364*   	ld (@arg),a
043019 21 24 30 04 0365*   	ld hl,@cmd
04301D 01 04 00 00 0366*   	ld bc,@end-@cmd
043021 5B DF       0367*   	rst.lil $18
043023 C9          0368*   	ret
043024 17 00 C0    0369*   @cmd: db 23,0,0xC0
043027 00          0370*   @arg: db 0  ; scaling on/off
043028             0371*   @end:
043028             0372*   
043028             0373*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
043028             0374*   ; inputs: hl=bufferId
043028             0375*   vdu_buff_select:
043028 22 3A 30 04 0376*   	ld (@bufferId),hl
04302C 21 37 30 04 0377*   	ld hl,@cmd
043030 01 05 00 00 0378*   	ld bc,@end-@cmd
043034 5B DF       0379*   	rst.lil $18
043036 C9          0380*   	ret
043037 17 1B 20    0381*   @cmd: db 23,27,0x20
04303A 00 00       0382*   @bufferId: dw 0x0000
04303C 00          0383*   @end: db 0x00 ; padding
04303D             0384*   
04303D             0385*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04303D             0386*   ; inputs: a=format; bc=width; de=height
04303D             0387*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04303D             0388*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04303D             0389*   ; 0 	RGBA8888 (4-bytes per pixel)
04303D             0390*   ; 1 	RGBA2222 (1-bytes per pixel)
04303D             0391*   ; 2 	Mono/Mask (1-bit per pixel)
04303D             0392*   ; 3 	Reserved for internal use by VDP (native format)
04303D             0393*   vdu_bmp_create:
04303D ED 43 59 30 0394*       ld (@width),bc
       04          
043042 ED 53 5B 30 0395*       ld (@height),de
       04          
043047 32 5D 30 04 0396*       ld (@fmt),a
04304B 21 56 30 04 0397*   	ld hl,@cmd
04304F 01 08 00 00 0398*   	ld bc,@end-@cmd
043053 5B DF       0399*   	rst.lil $18
043055 C9          0400*   	ret
043056 17 1B 21    0401*   @cmd:       db 23,27,0x21
043059 00 00       0402*   @width:     dw 0x0000
04305B 00 00       0403*   @height:    dw 0x0000
04305D 00          0404*   @fmt:       db 0x00
04305E             0405*   @end:
04305E             0406*   
04305E             0407*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04305E             0408*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04305E             0409*   vdu_load_img_rgba2_to_8:
04305E             0410*   ; backup the target buffer id and image dimensions
04305E E5          0411*       push hl
04305F D5          0412*       push de
043060 C5          0413*       push bc
043061             0414*   ; load the rgba2 image to working buffer 65534
043061 21 FE FF 00 0415*       ld hl,65534 ; temporary working buffer id
043065 CD 3C 31 04 0416*   	call vdu_load_buffer_from_file
043069             0417*   ; restore the image dimensions and target buffer id
043069 C1          0418*       pop bc
04306A D1          0419*       pop de
04306B E1          0420*       pop hl
04306C             0421*   ; fall through to vdu_rgba2_to_8
04306C             0422*   
04306C             0423*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04306C             0424*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04306C             0425*   ; the "expand bitmap" command is:
04306C             0426*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04306C             0427*   ; and then to reverse the byte order to fix endian-ness:
04306C             0428*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04306C             0429*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04306C             0430*   ; VDU 23,27,&20,targetBufferID%;
04306C             0431*   ; VDU 23,27,&21,width%;height%;0
04306C             0432*   ; -------------------------------------------------------------------
04306C             0433*   ; inputs: bc,de image width,height ; hl = targetBufferId
04306C             0434*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04306C             0435*   vdu_rgba2_to_8:
04306C             0436*   ; load the image dimensions and buffer id parameters
04306C ED 43 C8 30 0437*       ld (@width),bc
       04          
043071 ED 53 CA 30 0438*       ld (@height),de
       04          
043076 22 AD 30 04 0439*       ld (@bufferId0),hl
04307A 22 BA 30 04 0440*       ld (@bufferId2),hl
04307E 22 C3 30 04 0441*       ld (@bufferId1),hl
043082             0442*   ; clean up bytes that got stomped on by the ID loads
043082 3E 48       0443*       ld a,0x48
043084 32 AF 30 04 0444*       ld (@bufferId0+2),a
043088 3E 17       0445*       ld a,23
04308A 32 C5 30 04 0446*       ld (@bufferId1+2),a
04308E 3E 18       0447*       ld a,24
043090 32 BC 30 04 0448*       ld (@bufferId2+2),a
043094 AF          0449*       xor a
043095 32 CC 30 04 0450*       ld (@height+2),a
043099             0451*   ; send the vdu command strings
043099 21 A4 30 04 0452*       ld hl,@beg
04309D 01 29 00 00 0453*       ld bc,@end-@beg
0430A1 5B DF       0454*       rst.lil $18
0430A3 C9          0455*       ret
0430A4             0456*   @beg:
0430A4             0457*   ; Command 14: Consolidate blocks in a buffer
0430A4             0458*   ; VDU 23, 0, &A0, bufferId; 14
0430A4 17 00 A0    0459*       db 23,0,0xA0
0430A7 FE FF       0460*       dw 65534 ; workingBufferId
0430A9 0E          0461*       db 14 ; consolidate blocks
0430AA             0462*   ; the "expand bitmap" command is:
0430AA             0463*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0430AA 17 00 A0    0464*       db 23,0,0xA0
0430AD 00 00       0465*   @bufferId0: dw 0x0000 ; targetBufferId
0430AF 48          0466*       db 0x48 ; given as decimal command 72 in the docs
0430B0 02          0467*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0430B1 FE FF       0468*       dw 65534 ; sourceBufferId
0430B3 00 7F BF FF 0469*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0430B7             0470*   ; reverse the byte order to fix endian-ness:
0430B7             0471*   ; Command 24: Reverse the order of data of blocks within a buffer
0430B7             0472*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0430B7             0473*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0430B7 17 00 A0    0474*       db 23,0,0xA0
0430BA 00 00       0475*   @bufferId2:    dw 0x0000 ; targetBufferId
0430BC 18          0476*       db 24 ; reverse byte order
0430BD 04          0477*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0430BE 04 00       0478*       dw 4 ; size (4 bytes)
0430C0             0479*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0430C0             0480*   ; VDU 23,27,&20,targetBufferID%;
0430C0 17 1B 20    0481*       db 23,27,0x20 ; select bitmap
0430C3 00 00       0482*   @bufferId1: dw 0x0000 ; targetBufferId
0430C5             0483*   ; VDU 23,27,&21,width%;height%;0
0430C5 17 1B 21    0484*       db 23,27,0x21 ; create bitmap from buffer
0430C8 00 00       0485*   @width: dw 0x0000
0430CA 00 00       0486*   @height: dw 0x0000
0430CC 00          0487*       db 0x00 ; rgba8888 format
0430CD             0488*   @end:
0430CD             0489*   
0430CD             0490*   ; scratch variables
0430CD 00 00 00    0491*   bufferId0: dl 0x000000
0430D0 00 00 00    0492*   bufferId1: dl 0x000000
0430D3             0493*   
0430D3             0494*   ; load a vdu buffer from local memory
0430D3             0495*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0430D3             0496*   vdu_load_buffer:
0430D3 ED 43 FC 30 0497*       ld (@length),bc
       04          
0430D8 D5          0498*       push de ; save data pointer
0430D9             0499*   ; send the vdu command string
0430D9 7D          0500*       ld a,l
0430DA 32 F9 30 04 0501*       ld (@bufferId),a
0430DE 7C          0502*       ld a,h
0430DF 32 FA 30 04 0503*       ld (@bufferId+1),a
0430E3 21 F6 30 04 0504*       ld hl,@cmd
0430E7 01 08 00 00 0505*       ld bc,@end-@cmd
0430EB 5B DF       0506*       rst.lil $18
0430ED             0507*   ; send the buffer data
0430ED E1          0508*       pop hl ; pointer to data
0430EE ED 4B FC 30 0509*       ld bc,(@length)
       04          
0430F3 5B DF       0510*       rst.lil $18 ; send it
0430F5 C9          0511*       ret
0430F6             0512*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0430F6 17 00 A0    0513*   @cmd:       db 23,0,0xA0
0430F9 00 00       0514*   @bufferId:	dw 0x0000
0430FB 00          0515*   		    db 0 ; load buffer
0430FC 00 00       0516*   @length:	dw 0x0000
0430FE 00          0517*   @end: db 0 ; padding
0430FF             0518*   
0430FF             0519*   ; Command 14: Consolidate blocks in a buffer
0430FF             0520*   vdu_consolidate_buffer:
0430FF             0521*   ; set parameters for vdu call
0430FF 7D          0522*       ld a,l
043100 32 17 31 04 0523*       ld (@bufferId),a
043104 7C          0524*       ld a,h
043105 32 18 31 04 0525*       ld (@bufferId+1),a
043109 21 14 31 04 0526*       ld hl,@beg
04310D 01 06 00 00 0527*       ld bc,@end-@beg
043111 5B DF       0528*       rst.lil $18
043113 C9          0529*       ret
043114             0530*   ; VDU 23, 0, &A0, bufferId; 14
043114 17 00 A0    0531*   @beg: db 23,0,0xA0
043117 00 00       0532*   @bufferId: dw 0x0000
043119 0E          0533*              db 14
04311A             0534*   @end:
04311A             0535*   
04311A             0536*   ; load an image file to a buffer and make it a bitmap
04311A             0537*   ; inputs: a = image format ; bc,de image width,height ; hl = bufferId ; iy = pointer to filename
04311A             0538*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04311A             0539*   ; 0 	RGBA8888 (4-bytes per pixel)
04311A             0540*   ; 1 	RGBA2222 (1-bytes per pixel)
04311A             0541*   ; 2 	Mono/Mask (1-bit per pixel)
04311A             0542*   ; 3 	Reserved for internal use by VDP (native format)
04311A             0543*   vdu_load_img:
04311A             0544*   ; back up image type and dimension parameters
04311A 22 CD 30 04 0545*       ld (bufferId0),hl
04311E F5          0546*       push af
04311F C5          0547*   	push bc
043120 D5          0548*   	push de
043121             0549*   ; load the image
043121 CD 3C 31 04 0550*   	call vdu_load_buffer_from_file
043125             0551*   ; now make it a bitmap
043125 2A CD 30 04 0552*       ld hl,(bufferId0)
043129 CD FF 30 04 0553*       call vdu_consolidate_buffer
04312D 2A CD 30 04 0554*       ld hl,(bufferId0)
043131 CD 28 30 04 0555*       call vdu_buff_select
043135 D1          0556*   	pop de ; image height
043136 C1          0557*   	pop bc ; image width
043137 F1          0558*   	pop af ; image type
043138 C3 3D 30 04 0559*   	jp vdu_bmp_create ; will return to caller from there
04313C             0560*   
04313C             0561*   ; inputs: hl = bufferId; iy = pointer to filename
04313C             0562*   vdu_load_buffer_from_file:
04313C 22 CD 30 04 0563*       ld (bufferId0),hl
043140             0564*   
043140             0565*   ; clear target buffer
043140 CD CC 29 04 0566*       call vdu_clear_buffer
043144             0567*   
043144             0568*   ; open the file in read mode
043144             0569*   ; Open a file
043144             0570*   ; HLU: Filename
043144             0571*   ;   C: Mode
043144             0572*   ; Returns:
043144             0573*   ;   A: Filehandle, or 0 if couldn't open
043144 FD E5       0574*   	push iy ; pointer to filename
043146 E1          0575*   	pop hl
043147 0E 01       0576*   	ld c,fa_read
043149             0577*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
043149 3E 0A       0001*M1 			LD	A, function
04314B 5B CF       0002*M1 			RST.LIL	08h
04314D 32 88 31 04 0578*       ld (@filehandle),a
043151             0579*   
043151             0580*   @read_file:
043151             0581*   ; Read a block of data from a file
043151             0582*   ;   C: Filehandle
043151             0583*   ; HLU: Pointer to where to write the data to
043151             0584*   ; DEU: Number of bytes to read
043151             0585*   ; Returns:
043151             0586*   ; DEU: Number of bytes read
043151 3A 88 31 04 0587*       ld a,(@filehandle)
043155 4F          0588*       ld c,a
043156 21 00 46 04 0589*       ld hl,filedata
04315A 11 00 20 00 0590*       ld de,8192 ; max we can read into onboard sram at one time
04315E             0591*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
04315E 3E 1A       0001*M1 			LD	A, function
043160 5B CF       0002*M1 			RST.LIL	08h
043162             0592*   
043162             0593*   ; test de for zero bytes read
043162 21 00 00 00 0594*       ld hl,0
043166 AF          0595*       xor a ; clear carry
043167 ED 52       0596*       sbc hl,de
043169 CA 7F 31 04 0597*       jp z,@close_file
04316D             0598*   
04316D             0599*   ; load a vdu buffer from local memory
04316D             0600*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04316D 2A CD 30 04 0601*       ld hl,(bufferId0)
043171 D5          0602*       push de ; chunksize
043172 C1          0603*       pop bc
043173 11 00 46 04 0604*       ld de,filedata
043177 CD D3 30 04 0605*       call vdu_load_buffer
04317B             0606*   
04317B             0607*   ; read the next block
04317B C3 51 31 04 0608*       jp @read_file
04317F             0609*   
04317F             0610*   ; close the file
04317F             0611*   @close_file:
04317F 3A 88 31 04 0612*       ld a,(@filehandle)
043183             0613*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
043183 3E 0B       0001*M1 			LD	A, function
043185 5B CF       0002*M1 			RST.LIL	08h
043187 C9          0614*       ret ; vdu_load_buffer_from_file
043188             0615*   
043188 00          0616*   @filehandle: db 0 ; file handle
043189 00 00 00    0617*   @fil: dl 0 ; pointer to FIL struct
04318C             0618*   
04318C 00 00 00    0619*   @chunkpointer: dl 0 ; pointer to current chunk
04318F             0620*   
04318F             0621*   ; File information structure (FILINFO)
04318F             0622*   @filinfo:
04318F 00 00 00 00 0623*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
043193 00 00       0624*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
043195 00 00       0625*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
043197 00          0626*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
043198 00 00 00 00 0627*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0431A5 00 00 00 00 0628*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0432A5             0044    
0432A5             0045        include "../softfloat/globals.inc"
0432A5             0001*   canonicalNaNF16: EQU 0x7E00
0432A5             0002*   
0432A5 20 49 6E 66 0003*   str_inf: asciz " Inf"
       00          
0432AA 20 4E 61 4E 0004*   str_nan: asciz " NaN"
       00          
0432AF 20 30 00    0005*   str_zero: asciz " 0"
0432B2             0006*   
0432B2 7A 7A 7A 7A 0007*   str_numbers: db "zzzzzzzz"
       7A 7A 7A 7A 
0432BA 00 00 00 00 0008*   strBuff:      blkb 32,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0432DA             0009*   
0432DA             0010*   ; 16-bit floating point globals
0432DA             0011*   ; A group
0432DA             0012*   uiA:         EQU 0
0432DA             0013*   sigA:        EQU uiA + 3
0432DA             0014*   signA:       EQU sigA + 3
0432DA             0015*   expA:        EQU signA + 1
0432DA             0016*   
0432DA             0017*   ; B group
0432DA             0018*   uiB:         EQU expA + 2
0432DA             0019*   sigB:        EQU uiB + 3
0432DA             0020*   signB:       EQU sigB + 3
0432DA             0021*   expB:        EQU signB + 1
0432DA             0022*   
0432DA             0023*   ; X group
0432DA             0024*   sigX:        EQU expB + 2
0432DA             0025*   signX:       EQU sigX + 3
0432DA             0026*   expX:        EQU signX + 1
0432DA             0027*   
0432DA             0028*   ; Y group
0432DA             0029*   sigY:        EQU expX + 2
0432DA             0030*   signY:       EQU sigY + 3
0432DA             0031*   expY:        EQU signY + 1
0432DA             0032*   
0432DA             0033*   ; Z group
0432DA             0034*   uiZ:         EQU expY + 2
0432DA             0035*   sigZ:        EQU uiZ + 3
0432DA             0036*   signZ:       EQU sigZ + 3
0432DA             0037*   expZ:        EQU signZ + 1
0432DA             0038*   
0432DA             0039*   ; Shared / Misc
0432DA             0040*   expDiff:     EQU expZ + 2
0432DA             0041*   shiftDist:   EQU expDiff + 1
0432DA             0042*   sigDiff:     EQU shiftDist + 1
0432DA             0043*   r0:          EQU sigDiff + 3
0432DA             0044*   rem:         EQU r0 + 3
0432DA             0045*   
0432DA             0046*   ; 32-bit floating point globals
0432DA             0047*   sig32A:      EQU rem + 5
0432DA             0048*   sig32B:      EQU sig32A + 5
0432DA             0049*   sig32X:      EQU sig32B + 5
0432DA             0050*   sig32Y:      EQU sig32X + 5
0432DA             0051*   sig32Z:      EQU sig32Y + 5
0432DA             0052*   sig48Z:      EQU sig32Z + 5
0432DA             0053*   
0432DA             0054*   ; Global variable table
0432DA             0055*   s_globals:
0432DA             0056*   
0432DA 00 00 00    0057*       _uiA:          dl 0
0432DD 00 00 00    0058*       _sigA:         dl 0
0432E0 00          0059*       _signA:        db 0
0432E1 00          0060*       _expA:         db 0
0432E2 00          0061*                      db 0   ; padding
0432E3             0062*   
0432E3 00 00 00    0063*       _uiB:          dl 0
0432E6 00 00 00    0064*       _sigB:         dl 0
0432E9 00          0065*       _signB:        db 0
0432EA 00          0066*       _expB:         db 0
0432EB 00          0067*                      db 0   ; padding
0432EC             0068*   
0432EC             0069*       ; X group
0432EC 00 00 00    0070*       _sigX:         dl 0
0432EF 00          0071*       _signX:        db 0
0432F0 00          0072*       _expX:         db 0
0432F1 00          0073*                      db 0   ; padding
0432F2             0074*   
0432F2             0075*       ; Y group
0432F2 00 00 00    0076*       _sigY:         dl 0
0432F5 00          0077*       _signY:        db 0
0432F6 00          0078*       _expY:         db 0
0432F7 00          0079*                      db 0   ; padding
0432F8             0080*   
0432F8 00 00 00    0081*       _uiZ:          dl 0
0432FB 00 00 00    0082*       _sigZ:         dl 0
0432FE 00          0083*       _signZ:        db 0
0432FF 00          0084*       _expZ:         db 0
043300 00          0085*                      db 0   ; padding
043301             0086*   
043301 00          0087*       _expDiff:      db 0
043302 00          0088*       _shiftDist:    db 0
043303 00 00 00    0089*       _sigDiff:      dl 0
043306 00 00 00    0090*       _r0:           dl 0
043309 00 00 00 00 0091*       _rem:          blkb 5,0
       00          
04330E             0092*   
04330E 00 00 00 00 0093*       _sig32A:       blkb 5,0
       00          
043313 00 00 00 00 0094*       _sig32B:       blkb 5,0
       00          
043318 00 00 00 00 0095*       _sig32X:       blkb 5,0
       00          
04331D 00 00 00 00 0096*       _sig32Y:       blkb 5,0
       00          
043322 00 00 00 00 0097*       _sig32Z:       blkb 5,0
       00          
043327 00 00 00 00 0098*       _sig48Z:       blkb 7,0
       00 00 00    
04332E             0046        include "../softfloat/helpers.inc"
04332E             0001*   ; Inputs: hl is the 16 bit multiplicand, a is the 8 bit multiplier
04332E             0002*   ; Outputs: ade = 24-bit result
04332E             0003*   ; Destroys: f, hl
04332E             0004*   mul_16x8_24_ade:
04332E 55          0005*       ld d,l
04332F 5F          0006*       ld e,a
043330 ED 5C       0007*       mlt de ; l * a
043332 6F          0008*       ld l,a
043333 ED 6C       0009*       mlt hl ; h * a
043335             0010*   ; hl<<8 + de -> ade
043335 7A          0011*       ld a,d
043336 85          0012*       add a,l
043337 57          0013*       ld d,a
043338 8C          0014*       adc a,h
043339 92          0015*       sub a,d
04333A C9          0016*       ret
04333B             0017*   ; end mul_16x8_24_ade
04333B             0018*   
04333B             0019*   ; Inputs: hl is the 16 bit multiplicand, a is the 8 bit multiplier
04333B             0020*   ; Outputs: uhl = 24-bit result
04333B             0021*   ; Destroys: f, de
04333B             0022*   mul_16x8_24_uhl:
04333B 55          0023*       ld d,l
04333C 5F          0024*       ld e,a
04333D ED 5C       0025*       mlt de ; l * a
04333F 6F          0026*       ld l,a
043340 ED 6C       0027*       mlt hl ; h * a
043342             0028*   ; hl<<8 + de -> uhl
043342 29          0029*       add hl,hl ; 1
043343 29          0030*       add hl,hl ; 2
043344 29          0031*       add hl,hl ; 3
043345 29          0032*       add hl,hl ; 4
043346 29          0033*       add hl,hl ; 5
043347 29          0034*       add hl,hl ; 6
043348 29          0035*       add hl,hl ; 7
043349 29          0036*       add hl,hl ; 8
04334A 19          0037*       add hl,de
04334B C9          0038*       ret
04334C             0039*   ; end mul_16x8_24_uhl
04334C             0040*   
04334C             0041*   ;Inputs: hl,de = operands
04334C             0042*   ;Outputs: hlde = 32-bit product
04334C             0043*   ;Destroys: af,bc
04334C             0044*   ;53 cycles
04334C             0045*   ;32 bytes
04334C             0046*   mul_16x16_32:
04334C 43          0047*       ld b,e
04334D 4D          0048*       ld c,l
04334E 6B          0049*       ld l,e
04334F 59          0050*       ld e,c
043350 ED 4C       0051*       mlt bc
043352 78          0052*       ld a,b
043353 44          0053*       ld b,h
043354 ED 6C       0054*       mlt hl
043356             0055*       ; Add high part of low product, cannot overflow 16 bits
043356 85          0056*       add a,l
043357 6F          0057*       ld l,a
043358 8C          0058*       adc a,h
043359 95          0059*       sub a,l
04335A 67          0060*       ld h,a
04335B 79          0061*       ld a,c
04335C 4A          0062*       ld c,d
04335D ED 5C       0063*       mlt de
04335F 52 19       0064*       add.s hl,de ; .s to force 16-bit addition
043361 5F          0065*       ld e,a
043362 55          0066*       ld d,l
043363 6C          0067*       ld l,h
043364 26 00       0068*       ld h,0
043366 CB 14       0069*       rl h
043368 ED 4C       0070*       mlt bc
04336A 09          0071*       add hl,bc ; Cannot overflow 16 bits
04336B C9          0072*       ret
04336C             0073*   ; end mul_16x16_32
04336C             0074*   
04336C             0075*   ; multiply 32 x 16 -> 48 bit product
04336C             0076*   ; inputs: hlde = 32-bit multiplicand, bc = 16-bit multiplier
04336C             0077*   ; outputs: hldebc = 48-bit product
04336C             0078*   mul_32x16_48:
04336C C5          0079*       push bc
04336D D5          0080*       push de
04336E             0081*   ; hl * bc
04336E 59          0082*       ld e,c
04336F 50          0083*       ld d,b
043370 CD 4C 33 04 0084*       call mul_16x16_32 ; hlde = hl * bc
043374             0085*   ; de * bc
043374 C1          0086*       pop bc ; de
043375 E3          0087*       ex (sp),hl ; bc
043376 D5          0088*       push de
043377 59          0089*       ld e,c
043378 50          0090*       ld d,b
043379 CD 4C 33 04 0091*       call mul_16x16_32 ; hlde = de * bc
04337D             0092*   ; accumulate bc out
04337D 4B          0093*       ld c,e
04337E 42          0094*       ld b,d ; bc out
04337F             0095*   ; accumulate de out
04337F D1          0096*       pop de
043380 52 19       0097*       add.s hl,de
043382 EB          0098*       ex de,hl ; de out
043383             0099*   ; accumulate hl out
043383 E1          0100*       pop hl
043384 D0          0101*       ret nc
043385 23          0102*       inc hl ; Cannot overflow 16 bits
043386 C9          0103*       ret
043387             0104*   ; end mul_32x16_48_calc84
043387             0105*   
043387             0106*   ; https://www.cemetech.net/forum/viewtopic.php?t=12833&start=0
043387             0107*   ;Inputs:
043387             0108*   ;  HL:DE  32-bit unsigned integer
043387             0109*   ;Outputs:
043387             0110*   ;  A = HLDE mod 10
043387             0111*   ;  Z flag is set if divisible by 10
043387             0112*   ;Destroys:
043387             0113*   ;  HL
043387             0114*   ;  25 bytes,  109cc
043387             0115*   hlde_mod10:
043387 52 19       0116*      add.s hl,de                  ;add words, n mod 65535 (+1)
043389 7C          0117*      ld a,h                     ;add bytes
04338A 8D          0118*      adc a,l
04338B CE 00       0119*      adc a,0                    ;n mod 255 (+1)
04338D 67          0120*      ld h,a                     ;add nibbles
04338E 0F          0121*      rrca
04338F 0F          0122*      rrca
043390 0F          0123*      rrca
043391 0F          0124*      rrca
043392 84          0125*      add a,h
043393 CE 00       0126*      adc a,0                    ;n mod 15 (+1) in both nibbles
043395 27          0127*      daa
043396 67          0128*      ld h,a
043397 93          0129*      sub e                      ; Test if quotient is even or odd
043398 1F          0130*      rra
043399 9F          0131*      sbc a,a
04339A E6 05       0132*      and 5
04339C 84          0133*      add a,h
04339D 27          0134*      daa
04339E E6 0F       0135*      and 0Fh
0433A0 C9          0136*      ret
0433A1             0137*   ; end hlde_mod10
0433A1             0138*   
0433A1             0139*   ; https://www.cemetech.net/forum/viewtopic.php?t=12833&start=0
0433A1             0140*   ;Inputs:
0433A1             0141*   ;  HL  16-bit unsigned integer
0433A1             0142*   ;Outputs:
0433A1             0143*   ;  A = HL mod 10
0433A1             0144*   ;  Z flag is set if divisible by 10
0433A1             0145*   ;Destroys:
0433A1             0146*   ;  HL
0433A1             0147*   ;  24 bytes,  98cc
0433A1             0148*   hl_mod10:
0433A1 7C          0149*      ld a,h                     ;add bytes
0433A2 85          0150*      add a,l
0433A3 CE 00       0151*      adc a,0                    ;n mod 255 (+1)
0433A5 67          0152*      ld h,a                     ;add nibbles
0433A6 0F          0153*      rrca
0433A7 0F          0154*      rrca
0433A8 0F          0155*      rrca
0433A9 0F          0156*      rrca
0433AA 84          0157*      add a,h
0433AB CE 00       0158*      adc a,0                    ;n mod 15 (+1) in both nibbles
0433AD 27          0159*      daa
0433AE 67          0160*      ld h,a
0433AF 95          0161*      sub l
0433B0 1F          0162*      rra
0433B1 9F          0163*      sbc a,a
0433B2 E6 05       0164*      and 5
0433B4 84          0165*      add a,h
0433B5 27          0166*      daa
0433B6 E6 0F       0167*      and 0Fh
0433B8 C9          0168*      ret
0433B9             0169*   ; end hl_mod10
0433B9             0170*   
0433B9             0171*   ; https://www.cemetech.net/forum/viewtopic.php?t=12833&start=0
0433B9             0172*   ;Inputs:
0433B9             0173*   ;  A  8-bit unsigned integer
0433B9             0174*   ;Outputs:
0433B9             0175*   ;  A = A mod 10
0433B9             0176*   ;  Z flag is set if divisible by 10
0433B9             0177*   ;Destroys:
0433B9             0178*   ;  HL
0433B9             0179*   a_mod10:
0433B9 67          0180*      ld h,a                     ;add nibbles
0433BA 0F          0181*      rrca
0433BB 0F          0182*      rrca
0433BC 0F          0183*      rrca
0433BD 0F          0184*      rrca
0433BE 84          0185*      add a,h
0433BF CE 00       0186*      adc a,0                    ;n mod 15 (+1) in both nibbles
0433C1 27          0187*      daa
0433C2 6F          0188*      ld l,a                     ; -- h -> l for 8-bit
0433C3 94          0189*      sub h                      ; -- l -> h for 8-bit. Test if quotient is even or odd
0433C4 1F          0190*      rra
0433C5 9F          0191*      sbc a,a
0433C6 E6 05       0192*      and 5
0433C8 85          0193*      add a,l                    ; -- h -> l for 8-bit
0433C9 27          0194*      daa
0433CA E6 0F       0195*      and 0Fh
0433CC C9          0196*      ret
0433CD             0197*   ; end a_mod10
0433CD             0047        include "../softfloat/internals.inc"
0433CD             0001*   ; #define signF16UI( a ) ((bool) ((uint16_t) (a)>>15))
0433CD             0002*       MACRO signF16UI
0433CD             0003*           ld a,h
0433CD             0004*           and %10000000
0433CD             0005*           ld c,a
0433CD             0006*       ENDMACRO
0433CD             0007*   
0433CD             0008*   ; #define expF16UI( a ) ((int_fast8_t) ((a)>>10) & 0x1F)
0433CD             0009*       MACRO expF16UI
0433CD             0010*           ld a,h
0433CD             0011*           rrca
0433CD             0012*           rrca
0433CD             0013*           and %00011111
0433CD             0014*           ld b,a
0433CD             0015*       ENDMACRO
0433CD             0016*   
0433CD             0017*   ; #define fracF16UI( a ) ((a) & 0x03FF)
0433CD             0018*       MACRO fracF16UI
0433CD             0019*           ld a,h
0433CD             0020*           and %00000011
0433CD             0021*           ld h,a
0433CD             0022*       ENDMACRO
0433CD             0023*   
0433CD             0024*   ; inputs: hl is the float16 to unpack
0433CD             0025*   ; outputs: c is the sign (0=pos,1=neg), b is the biased exponent, hl is the normalised mantissa
0433CD             0026*   ;          sign and zero flags are correctly (re)set, carry set if hl is +/-zero
0433CD             0027*   ; destroys: a
0433CD             0028*   softfloat16_unpack:
0433CD             0029*   ; set sign
0433CD 7C          0030*       ld a,h
0433CE E6 80       0031*       and %10000000
0433D0 4F          0032*       ld c,a ; sign
0433D1             0033*   ; get hl's stored exponent and shift down twice
0433D1 7C          0034*       ld a,h
0433D2 0F          0035*       rrca
0433D3 0F          0036*       rrca
0433D4 E6 1F       0037*       and %00011111
0433D6 47          0038*       ld b,a ; biased exponent
0433D7 B7          0039*       or a ; check for zero
0433D8 20 10       0040*       jr nz,@check_special ; non-zero exponent means normal number
0433DA             0041*   ; check for zero or -zero
0433DA CB BC       0042*       res 7,h ; clear sign bit
0433DC             0043*       SIGN_HL
                       M1 Args: none
0433DC 19          0001*M1     add hl,de
0433DD B7          0002*M1     or a ; clear flags
0433DE 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
0433E1 28 1E       0044*       jr z,@is_zero ; result is zero so nothing more to do
0433E3             0045*   @is_sub:
0433E3 CD 5D 3B 04 0046*       call softfloat_normSubnormalF16Sig ; number is subnormal
0433E7 79          0047*       ld a,c ; get sign
0433E8 B7          0048*       or a ; (re)set sign flag and clear carry indicating non-zero result
0433E9 C9          0049*       ret
0433EA             0050*   @check_special:
0433EA             0051*   ; Check for special values - infinity and NaN
0433EA FE 1F       0052*       cp 0x1F ; Is exponent 0x1F?
0433EC 20 06       0053*       jr nz,@is_nor ; non-zero exponent means normal number
0433EE             0054*   ; mask out everything but the top tw bits of hl's mantissa
0433EE 7C          0055*       ld a,h
0433EF E6 03       0056*       and %00000011
0433F1 67          0057*       ld h,a
0433F2 B7          0058*       or a ; reset carry indicating non-zero result
0433F3 C9          0059*       ret
0433F4             0060*   @is_nor:
0433F4             0061*   ; put the explicit 1 into the mantissa and (re)set sign flag
0433F4 CB D4       0062*       set 2,h
0433F6             0063*       SIGN_HL
                       M1 Args: none
0433F6 19          0001*M1     add hl,de
0433F7 B7          0002*M1     or a ; clear flags
0433F8 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
0433FB             0064*   ; mask out everything but the top three bits of hl's mantissa
0433FB 7C          0065*       ld a,h
0433FC E6 07       0066*       and %00000111
0433FE 67          0067*       ld h,a
0433FF B7          0068*       or a ; reset carry indicating non-zero result
043400 C9          0069*       ret
043401             0070*   @is_zero:
043401 79          0071*       ld a,c ; get sign
043402 B7          0072*       or a ; (re)set sign flag
043403 37          0073*       scf ; set carry indicating zero result
043404 C9          0074*       ret
043405             0075*   ; end softfloat16_unpack
043405             0076*   
043405             0077*   
043405             0078*   ; #define packToF16UI( sign, exp, sig ) (((uint16_t) (sign)<<15) + ((uint16_t) (exp)<<10) + (sig))
043405             0079*   ; inputs: c = sign (0=pos, 0x80=neg), b = exp, hl = sig (implied 1 place in bit 10)
043405             0080*   packToF16UI:
043405             0081*       ; call dumpRegistersHex ; DEBUG
043405             0082*   ; exponent
043405 78          0083*       ld a,b
043406 87          0084*       add a,a
043407 87          0085*       add a,a
043408 84          0086*       add a,h
043409             0087*   ; sign
043409 81          0088*       add a,c
04340A 67          0089*       ld h,a
04340B             0090*       ; call dumpRegistersHex ; DEBUG
04340B C9          0091*       ret
04340C             0092*   ; end packToF16UI
04340C             0093*   
04340C             0094*   ; #define isNaNF16UI( a ) (((~(a) & 0x7C00) == 0) && ((a) & 0x03FF))
04340C             0048        include "../softfloat/primitives.inc"
04340C             0001*   softfloat_approxRecip_1k0s:
04340C C4 FF BE F0 0002*       dw 0xFFC4, 0xF0BE, 0xE363, 0xD76F, 0xCCAD, 0xC2F0, 0xBA16, 0xB201
       63 E3 6F D7 
       AD CC F0 C2 
       16 BA 01 B2 
04341C 97 AA C6 A3 0003*       dw 0xAA97, 0xA3C6, 0x9D7A, 0x97A6, 0x923C, 0x8D32, 0x887E, 0x8417
       7A 9D A6 97 
       3C 92 32 8D 
       7E 88 17 84 
04342C             0004*   
04342C             0005*   softfloat_approxRecip_1k1s:
04342C F1 F0 2C D6 0006*       dw 0xF0F1, 0xD62C, 0xBFA1, 0xAC77, 0x9C0A, 0x8DDB, 0x8185, 0x76BA
       A1 BF 77 AC 
       0A 9C DB 8D 
       85 81 BA 76 
04343C 3B 6D D4 64 0007*       dw 0x6D3B, 0x64D4, 0x5D5C, 0x56B1, 0x50B6, 0x4B55, 0x4679, 0x4211
       5C 5D B1 56 
       B6 50 55 4B 
       79 46 11 42 
04344C             0008*   
04344C             0009*   softfloat_approxRecipSqrt_1k0s:
04344C C9 B4 AB FF 0010*       dw 0xB4C9, 0xFFAB, 0xAA7D, 0xF11C, 0xA1C5, 0xE4C7, 0x9A43, 0xDA29
       7D AA 1C F1 
       C5 A1 C7 E4 
       43 9A 29 DA 
04345C B5 93 E5 D0 0011*       dw 0x93B5, 0xD0E5, 0x8DED, 0xC8B7, 0x88C6, 0xC16D, 0x8424, 0xBAE1
       ED 8D B7 C8 
       C6 88 6D C1 
       24 84 E1 BA 
04346C             0012*   
04346C             0013*   softfloat_approxRecipSqrt_1k1s:
04346C A5 A5 42 EA 0014*       dw 0xA5A5, 0xEA42, 0x8C21, 0xC62D, 0x788F, 0xAA7F, 0x6928, 0x94B6
       21 8C 2D C6 
       8F 78 7F AA 
       28 69 B6 94 
04347C C7 5C 35 83 0015*       dw 0x5CC7, 0x8335, 0x52A6, 0x74E2, 0x4A3E, 0x68FE, 0x432B, 0x5EFD
       A6 52 E2 74 
       3E 4A FE 68 
       2B 43 FD 5E 
04348C             0049        include "../softfloat/f16_add.inc"
04348C             0001*   ; add two 16-bit floating point numbers
04348C             0002*   ; inputs: hl = a, de = b
04348C             0003*   ; outputs: hl = a + b
04348C             0004*   ; destroys: af, bc, de, ix
04348C             0005*   f16_add:
04348C             0006*   ; ensure operands are 16-bits otherwise errors happen
04348C 2B          0007*       dec hl
04348D 52 23       0008*       inc.s hl
04348F 1B          0009*       dec de
043490 52 13       0010*       inc.s de
043492             0011*   ; set index to global variables
043492 DD 21 DA 32 0012*       ld ix,s_globals
       04          
043497             0013*   ; compare signs
043497 7C          0014*       ld a,h ; sign opA
043498 E6 80       0015*       and %10000000
04349A AA          0016*       xor d ; xor sign opA with sign opB
04349B E6 80       0017*       and %10000000
04349D             0018*   ; if ( signF16UI( uiA ^ uiB ) ) {
04349D             0019*   ;     return softfloat_subMagsF16( uiA, uiB );
04349D C2 FB 3B 04 0020*           jp nz,softfloat_subMagsF16
0434A1             0021*   ; } else {
0434A1             0022*   ;     return softfloat_addMagsF16( uiA, uiB );
0434A1 C3 C5 39 04 0023*           jp softfloat_addMagsF16
0434A5             0024*   ; end f16_add
0434A5             0050        include "../softfloat/f16_div.inc"
0434A5             0001*   ; inputs: hl = dividend, de = divisor
0434A5             0002*   ; outputs: hl = float16 result
0434A5             0003*   ; destroys af, bc, de, ix
0434A5             0004*   f16_div:
0434A5             0005*   ; set index to global variables
0434A5 DD 21 DA 32 0006*       ld ix,s_globals
       04          
0434AA             0007*   ; compute sign of the quotient
0434AA 7C          0008*       ld a,h ; sign opA
0434AB E6 80       0009*       and %10000000
0434AD AA          0010*       xor d ; xor sign opA with sign opB
0434AE E6 80       0011*       and %10000000
0434B0 DD 77 24    0012*       ld (ix+signZ),a
0434B3             0013*   
0434B3             0014*   ; unpack opB
0434B3 EB          0015*       ex de,hl
0434B4 CD CD 33 04 0016*       call softfloat16_unpack
0434B8 DD 2F 0C    0017*       ld (ix+sigB),hl ; store sigB
0434BB 78          0018*       ld a,b ; exponent
0434BC DD 77 10    0019*       ld (ix+expB),a ; store exponent
0434BF             0020*   
0434BF             0021*   ; unpack opA
0434BF EB          0022*       ex de,hl
0434C0 CD CD 33 04 0023*       call softfloat16_unpack
0434C4 78          0024*       ld a,b ; exponent
0434C5 DD 77 07    0025*       ld (ix+expA),a
0434C8 DD 2F 03    0026*       ld (ix+sigA),hl ; store sigA
0434CB             0027*   
0434CB             0028*   ; === HANDLE SPECIAL CASES ===
0434CB             0029*   ; if ( expA == 0x1F ) {
0434CB FE 1F       0030*       cp 0x1F ; check expA for inf
0434CD 20 22       0031*       jr nz,@check_expB_inf
0434CF             0032*   ;     if ( sigA ) goto propagateNaN;
0434CF             0033*           SIGN_HL
                       M1 Args: none
0434CF 19          0001*M1     add hl,de
0434D0 B7          0002*M1     or a ; clear flags
0434D1 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
0434D4 C2 EB 35 04 0034*           jp nz,@return_nan
0434D8             0035*   ;     if ( expB == 0x1F ) {
0434D8 DD 7E 10    0036*           ld a,(ix+expB)
0434DB FE 1F       0037*           cp 0x1F ; check expB for inf
0434DD C2 F0 35 04 0038*           jp nz,@return_inf
0434E1             0039*   ;         if ( sigB ) goto propagateNaN;
0434E1 DD 27 0C    0040*               ld hl,(ix+sigB)
0434E4             0041*               SIGN_HL
                       M1 Args: none
0434E4 19          0001*M1     add hl,de
0434E5 B7          0002*M1     or a ; clear flags
0434E6 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
0434E9 C2 EB 35 04 0042*               jp nz,@return_nan ; non-signalling NaN
0434ED             0043*   ;         goto invalid;
0434ED C3 EB 35 04 0044*               jp @return_invalid ; signalling NaN
0434F1             0045*   ;     }
0434F1             0046*   ;     goto infinity; // handled above
0434F1             0047*   ; }
0434F1             0048*   @check_expB_inf:
0434F1             0049*   ; if ( expB == 0x1F ) {
0434F1 DD 7E 10    0050*       ld a,(ix+expB)
0434F4 FE 1F       0051*       cp 0x1F ; check expB for inf
0434F6 20 10       0052*       jr nz,@check_expB_zero
0434F8             0053*   ;     if ( sigB ) goto propagateNaN;
0434F8 DD 27 0C    0054*           ld hl,(ix+sigB)
0434FB             0055*           SIGN_HL
                       M1 Args: none
0434FB 19          0001*M1     add hl,de
0434FC B7          0002*M1     or a ; clear flags
0434FD 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043500 C2 EB 35 04 0056*           jp nz,@return_nan ; non-signalling NaN
043504             0057*   ;     goto zero;
043504 C3 F9 35 04 0058*           jp @return_zero
043508             0059*   ; }
043508             0060*   ; /*------------------------------------------------------------------------
043508             0061*   ; *------------------------------------------------------------------------*/
043508             0062*   @check_expB_zero:
043508             0063*   ; if ( ! expB ) {
043508 B7          0064*       or a ; check expB for zero
043509 20 22       0065*       jr nz,@check_expA_zero
04350B             0066*   ; if ( ! sigB ) {
04350B DD 27 0C    0067*       ld hl,(ix+sigB)
04350E             0068*       SIGN_HL
                       M1 Args: none
04350E 19          0001*M1     add hl,de
04350F B7          0002*M1     or a ; clear flags
043510 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043513 20 18       0069*       jr nz,@check_expA_zero
043515             0070*   ; if ( ! (expA | sigA) ) goto invalid;
043515 DD 7E 07    0071*       ld a,(ix+expA)
043518 B7          0072*       or a ; check expA for zero
043519 20 0E       0073*       jr nz,@b_zero_a_nonzero
04351B DD 27 03    0074*       ld hl,(ix+sigA)
04351E             0075*       SIGN_HL
                       M1 Args: none
04351E 19          0001*M1     add hl,de
04351F B7          0002*M1     or a ; clear flags
043520 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043523 20 04       0076*       jr nz,@b_zero_a_nonzero
043525             0077*   ; 0/0 case
043525 C3 EB 35 04 0078*       jp @return_invalid
043529             0079*   @b_zero_a_nonzero:
043529             0080*   ; goto infinity;
043529 C3 F0 35 04 0081*       jp @return_inf
04352D             0082*   ; }
04352D             0083*   @check_expA_zero:
04352D             0084*   ; if ( ! expA ) {
04352D DD 7E 07    0085*       ld a,(ix+expA)
043530 B7          0086*       or a ; check expA for zero
043531 20 0C       0087*       jr nz,@end_specials
043533             0088*   ;     if ( ! sigA ) goto zero;
043533 DD 27 03    0089*           ld hl,(ix+sigA)
043536             0090*           SIGN_HL
                       M1 Args: none
043536 19          0001*M1     add hl,de
043537 B7          0002*M1     or a ; clear flags
043538 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
04353B CA F9 35 04 0091*           jp z,@return_zero
04353F             0092*   ; }
04353F             0093*   @end_specials:
04353F             0094*   
04353F             0095*   ; expZ = expA - expB + 0xE
04353F DD 7E 07    0096*       ld a,(ix+expA)
043542 47          0097*       ld b,a
043543 DD 7E 10    0098*       ld a,(ix+expB)
043546 90          0099*       sub b
043547 ED 44       0100*       neg
043549 C6 0E       0101*       add 0x0E
04354B             0102*   ; if sigA < sigB: expZ = expZ - 1, numShifts = 5
04354B             0103*   ; else: numShifts = 4
04354B             0104*   ; sigA = u16(sigA << numShifts)
04354B DD 07 0C    0105*       ld bc,(ix+sigB)
04354E B7          0106*       or a ; clear carry
04354F 52 ED 42    0107*       sbc.s hl,bc ; sigA - sigB (.s to force 16-bit subtraction)
043552 DD 27 03    0108*       ld hl,(ix+sigA)
043555 30 02       0109*       jr nc,@sigA_gte_sigB ; sigA < sigB
043557             0110*   ; expZ = expZ - 1
043557 3D          0111*       dec a
043558             0112*   ; sigA = u16(sigA << 5)
043558 29          0113*       add hl,hl
043559             0114*   @sigA_gte_sigB:
043559 DD 77 25    0115*       ld (ix+expZ),a
04355C             0116*   ; else: sigA = u16(sigA << 4)
04355C 29          0117*       add hl,hl
04355D 29          0118*       add hl,hl
04355E 29          0119*       add hl,hl
04355F 29          0120*       add hl,hl
043560 DD 2F 03    0121*       ld (ix+sigA),hl ; store sigA shifted up
043563             0122*   
043563             0123*   ; index = sigB>>6 & 0xF;
043563 69          0124*       ld l,c
043564 60          0125*       ld h,b
043565 29          0126*       add hl,hl
043566 29          0127*       add hl,hl
043567 7C          0128*       ld a,h
043568 E6 0F       0129*       and 0x0F ; index
04356A             0130*   
04356A 87          0131*       add a,a ; 2 bytes per LUT entry
04356B 5F          0132*       ld e,a
04356C 16 00       0133*       ld d,0
04356E 1B          0134*       dec de
04356F 52 13       0135*       inc.s de ; zero deu
043571 DD E5       0136*       push ix ; preserve
043573 DD 21 0C 34 0137*       ld ix,softfloat_approxRecip_1k0s
       04          
043578 DD 19       0138*       add ix,de
04357A             0139*   
04357A             0140*   ; r0 = approx1k0s - (((approx1k1s * (sigB & 0x3F)) >> 10))
04357A DD 27 20    0141*       ld hl,(ix+32) ; approx1k1s
04357D 79          0142*       ld a,c ; sigB low byte
04357E E6 3F       0143*       and 0x3F ; sigB & 0x3F
043580 CD 2E 33 04 0144*       call mul_16x8_24_ade ; (sigB & 0x3F) -> ade
043584             0145*   ; >>10
043584 B7          0146*       or a ; clear carry
043585 1F          0147*       rra
043586 CB 1A       0148*       rr d
043588 B7          0149*       or a ; clear carry
043589 1F          0150*       rra
04358A CB 1A       0151*       rr d
04358C 5A          0152*       ld e,d
04358D 57          0153*       ld d,a
04358E 1B          0154*       dec de
04358F 52 13       0155*       inc.s de ; zero deu
043591 DD 27 00    0156*       ld hl,(ix) ; approx1k0s
043594 DD E1       0157*       pop ix ; send back how it came in
043596 B7          0158*       or a ; clear carry
043597 52 ED 52    0159*       sbc.s hl,de ; hl = r0 = approx1k0s - ((approx1k1s * (sigB & 0x3F)) >> 10)
04359A DD 2F 2C    0160*       ld (ix+r0),hl ; store r0
04359D             0161*   
04359D             0162*   ; sigZ = u32((sigA * r0) >> 16)
04359D DD 17 03    0163*       ld de,(ix+sigA)
0435A0 CD 4C 33 04 0164*       call mul_16x16_32 ; hl = sigZ
0435A4 DD 2F 21    0165*       ld (ix+sigZ),hl
0435A7 CD 00 36 04 0166*       call @compute_sigZ_error
0435AB             0167*   
0435AB             0168*   ; sigZ += (rem * (uint_fast32_t) r0)>>26;
0435AB             0169*   ; both multiplicands are 16 bits so we can use 16x16->32 bit multiply
0435AB DD 27 2C    0170*       ld hl,(ix+r0)
0435AE CD 4C 33 04 0171*       call mul_16x16_32 ; hlde = rem * r0
0435B2 7C          0172*       ld a,h ; top byte of product
0435B3 CB 3F       0173*       srl a
0435B5 CB 3F       0174*       srl a
0435B7 DD 27 21    0175*       ld hl,(ix+sigZ)
0435BA 85          0176*       add a,l
0435BB 6F          0177*       ld l,a
0435BC 8C          0178*       adc a,h
0435BD 95          0179*       sub l
0435BE 67          0180*       ld h,a
0435BF             0181*   ; ++sigZ;
0435BF 23          0182*       inc hl
0435C0             0183*   
0435C0             0184*   ; if ( ! (sigZ & 7) ) {
0435C0 7D          0185*       ld a,l
0435C1 E6 07       0186*       and 0x07
0435C3 20 1F       0187*       jr nz,@return
0435C5             0188*   ;     sigZ &= ~1;
0435C5 CB 85       0189*           res 0,l
0435C7 DD 2F 21    0190*           ld (ix+sigZ),hl
0435CA             0191*   ;     rem = (sigA<<10) - sigZ * sigB;
0435CA CD 00 36 04 0192*           call @compute_sigZ_error
0435CE             0193*   ;     if ( rem & 0x8000 ) {
0435CE DD 27 21    0194*           ld hl,(ix+sigZ)
0435D1 7A          0195*           ld a,d
0435D2 E6 80       0196*           and 0x80
0435D4 28 04       0197*           jr z,@F
0435D6             0198*   ;         sigZ -= 2;
0435D6 2B          0199*               dec hl
0435D7 2B          0200*               dec hl
0435D8 18 0A       0201*               jr @return
0435DA             0202*   ;     } else {
0435DA             0203*   @@:
0435DA             0204*   ;         if ( rem ) sigZ |= 1;
0435DA 7A          0205*               ld a,d
0435DB B7          0206*               or a
0435DC 20 04       0207*               jr nz,@F
0435DE 7B          0208*               ld a,e
0435DF B7          0209*               or a
0435E0 28 02       0210*               jr z,@return
0435E2             0211*   @@:
0435E2 CB C5       0212*               set 0,l
0435E4             0213*   ;     }
0435E4             0214*   ; }
0435E4             0215*   
0435E4             0216*   @return:
0435E4             0217*   ; hl must be set to sigZ at this point
0435E4 DD 07 24    0218*       ld bc,(ix+signZ) ; b=expZ, c=signZ
0435E7 C3 66 3B 04 0219*       jp softfloat_roundPackToF16 ; assumes hl holds sig
0435EB             0220*   @return_invalid: ; fow now, we don't distinguish between signalling and non-signalling NaN
0435EB             0221*   @return_nan:
0435EB 21 00 7E 00 0222*       ld hl,canonicalNaNF16
0435EF C9          0223*       ret
0435F0             0224*   @return_inf:
0435F0 2E 00       0225*       ld l,0
0435F2 DD 7E 24    0226*       ld a,(ix+signZ)
0435F5 F6 7C       0227*       or 0x7C
0435F7 67          0228*       ld h,a
0435F8 C9          0229*       ret
0435F9             0230*   @return_zero:
0435F9 2E 00       0231*       ld l,0
0435FB DD 7E 24    0232*       ld a,(ix+signZ)
0435FE 67          0233*       ld h,a
0435FF C9          0234*       ret
043600             0235*   ; compute the error of sigZ
043600             0236*   ; inputs: hl = sigZ, (ix+sigB), (ix+sigA), (ix+r0)
043600             0237*   ; returns: hlde = rem (only de should matter)
043600             0238*   @compute_sigZ_error:
043600             0239*   ; rem = u32((sigA << 10) - sigZ * sigB)
043600 DD 17 0C    0240*       ld de,(ix+sigB)
043603 CD 4C 33 04 0241*       call mul_16x16_32 ; hlde = sigZ * sigB
043607 E5          0242*       push hl ; stack upper word of product
043608 DD 27 03    0243*       ld hl,(ix+sigA)
04360B 29          0244*       add hl,hl
04360C 29          0245*       add hl,hl
04360D             0246*       ; ld (ix+rem),hl ; don't need since difference will not occupy more than two bytes
04360D C1          0247*       pop bc ; restore upper word of product (was hl)
04360E AF          0248*       xor a ; a is our phantom zero register
04360F             0249*   ; now we're set to do the subtraction:
04360F             0250*   ;   uhl0
04360F             0251*   ; - bcde
04360F             0252*   ;  ------
04360F             0253*   ;   bcde
04360F 93          0254*       sub e
043610 5F          0255*       ld e,a
043611 7D          0256*       ld a,l
043612 9A          0257*       sbc a,d
043613 57          0258*       ld d,a
043614             0259*   ; ; difference is contained in two bytes so we only need de
043614             0260*   ;     ld a,h
043614             0261*   ;     sbc a,c
043614             0262*   ;     ld c,a
043614             0263*   ;     ld a,(ix+rem+2) ; hlu
043614             0264*   ;     sub b
043614             0265*   ;     ld b,a ; we assume no carry out
043614 C9          0266*       ret
043615             0267*   ; end @compute_sigZ_error
043615             0268*   ; end f16_div
043615             0051        include "../softfloat/f16_mul.inc"
043615             0001*   ; multiply two signed fixed16 numbers and get a fixed16 result
043615             0002*   ; operation: 0hl * 0de -> 0hl
043615             0003*   ; destroys: af,af', bc, de
043615             0004*   f16_mul:
043615             0005*   ; compute sign of product
043615 7C          0006*       ld a,h ; sign hl
043616 E6 80       0007*       and %10000000
043618 AA          0008*       xor d ; xor sign hl with sign de
043619 E6 80       0009*       and %10000000
04361B 4F          0010*       ld c,a  ; signZ
04361C             0011*   
04361C             0012*   ; clear sign bits to make specials tests easier
04361C CB BC       0013*       res 7,h
04361E CB BA       0014*       res 7,d
043620             0015*   
043620             0016*   ; check operands for NaN
043620 3E 7E       0017*       ld a,0x7E ; NaN upper byte is all we need
043622 BC          0018*       cp h
043623 CA CD 36 04 0019*       jp z,@ret_nan
043627 BA          0020*       cp d
043628 CA CD 36 04 0021*       jp z,@ret_nan
04362C             0022*   
04362C             0023*   ; check hl for zero
04362C             0024*       SIGN_HL
                       M1 Args: none
04362C 19          0001*M1     add hl,de
04362D B7          0002*M1     or a ; clear flags
04362E 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043631 CA B0 36 04 0025*       jp z,@arg_is_zero
043635             0026*   
043635             0027*   ; check hl for inf
043635 7C          0028*       ld a,h ; expA
043636 E6 7C       0029*       and %01111100 ; stored exp of hl
043638 FE 7C       0030*       cp %01111100 ; check for inf
04363A CA BD 36 04 0031*       jp z,@arg_is_inf
04363E             0032*   
04363E             0033*   ; check de for zero
04363E EB          0034*       ex de,hl ; flip operands
04363F             0035*       SIGN_HL
                       M1 Args: none
04363F 19          0001*M1     add hl,de
043640 B7          0002*M1     or a ; clear flags
043641 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043644 CA B0 36 04 0036*       jp z,@arg_is_zero
043648             0037*   
043648             0038*   ; check de for inf
043648 7C          0039*       ld a,h ; expB
043649 E6 7C       0040*       and %01111100 ; stored exp of de
04364B FE 7C       0041*       cp %01111100 ; check for inf
04364D CA BD 36 04 0042*       jp z,@arg_is_inf
043651             0043*   
043651             0044*   ; get exponent of de
043651 B7          0045*       or a ; clear carry
043652 1F          0046*       rra ; shift exp
043653 1F          0047*       rra ; down twice
043654 47          0048*       ld b,a ; assume normal
043655 A7          0049*       and a ; test for subnormal
043656 CC 5D 3B 04 0050*       call z,softfloat_normSubnormalF16Sig
04365A             0051*   
04365A             0052*   ; get mantissa of de
04365A 7C          0053*       ld a,h
04365B E6 03       0054*       and %00000011 ; mask out sign and exponent
04365D 67          0055*       ld h,a
04365E EB          0056*       ex de,hl ; flip operands back
04365F             0057*   
04365F             0058*   ; get exponent of hl
04365F 7C          0059*       ld a,h ; expA
043660 E6 7C       0060*       and %01111100 ; stored exp of hl
043662 1F          0061*       rra ; shift exp
043663 1F          0062*       rra ; down twice
043664 A7          0063*       and a ; test for subnormal
043665 20 05       0064*       jr nz,@F ; skip if normal
043667 78          0065*       ld a,b ; a = expB
043668 CD 5D 3B 04 0066*       call softfloat_normSubnormalF16Sig
04366C             0067*   @@:
04366C             0068*   ; compute exponent of product
04366C 80          0069*       add a,b ; expA + expB
04366D D6 0F       0070*       sub 0x0F ; expA + expB - 0xF
04366F 47          0071*       ld b,a ; expZ
043670             0072*   
043670             0073*   ; get mantissa of hl
043670 7C          0074*       ld a,h
043671 E6 03       0075*       and %00000011 ; mask out sign and exponent
043673 67          0076*       ld h,a
043674             0077*   
043674             0078*   ; cleared to proceed with the multiplication
043674 C5          0079*       push bc ; stack sign and exponent of product
043675             0080*   ; sigA = (sigA | 0x0400)<<4;
043675 CB D4       0081*       set 2,h ; set implicit 1
043677 29          0082*       add hl,hl
043678 29          0083*       add hl,hl
043679 29          0084*       add hl,hl
04367A 29          0085*       add hl,hl
04367B             0086*   ; sigB = (sigB | 0x0400)<<5;
04367B EB          0087*       ex de,hl
04367C CB D4       0088*       set 2,h ; set implicit 1
04367E 29          0089*       add hl,hl
04367F 29          0090*       add hl,hl
043680 29          0091*       add hl,hl
043681 29          0092*       add hl,hl
043682 29          0093*       add hl,hl
043683 EB          0094*       ex de,hl
043684             0095*   ; sig32Z = (uint_fast32_t) sigA * sigB;
043684 CD 4C 33 04 0096*       call mul_16x16_32
043688 EB          0097*       ex de,hl
043689 EB          0098*       ex de,hl
04368A             0099*   ; sigZ = sig32Z>>16; (we get this for free since HL contains the relevant bits)
04368A             0100*   ; if ( sig32Z & 0xFFFF ) sigZ |= 1; set sticky bit
04368A 7B          0101*       ld a,e
04368B A7          0102*       and a
04368C C2 9A 36 04 0103*       jp nz,@need_sticky
043690 7A          0104*       ld a,d
043691 A7          0105*       and a
043692 C2 9A 36 04 0106*       jp nz,@need_sticky
043696 C3 9C 36 04 0107*       jp @do_sign_exp
04369A             0108*   @need_sticky:
04369A CB C5       0109*       set 0,l ; set sticky bit
04369C             0110*   @do_sign_exp:
04369C C1          0111*       pop bc ; exp and sign of product
04369D             0112*   ; check for subnormal
04369D 7C          0113*       ld a,h
04369E E6 C0       0114*       and %11000000 ; sigZ - 0x4000
0436A0 C2 AC 36 04 0115*       jp nz,@end_normalise ; sigZ >= 0x4000
0436A4             0116*   @normalise_loop:
0436A4 05          0117*       dec b ; --expZ
0436A5 29          0118*       add hl,hl ; sigZ <<= 1
0436A6 CB 74       0119*       bit 6,h ; test for carry into assumed 1 place
0436A8 CA A4 36 04 0120*       jp z,@normalise_loop
0436AC             0121*   @end_normalise: ; we land here if product was normal
0436AC             0122*   ; return softfloat_roundPackToF16( signZ, expZ, sigZ );
0436AC C3 66 3B 04 0123*       jp softfloat_roundPackToF16
0436B0             0124*   @arg_is_zero:
0436B0 7A          0125*       ld a,d ; check other arg for inf
0436B1 E6 7C       0126*       and %01111100
0436B3 FE 7C       0127*       cp %01111100
0436B5 CA CD 36 04 0128*       jp z,@ret_nan ; return NaN if exponent is inf
0436B9 79          0129*       ld a,c ; otherwise, sign the zero
0436BA B4          0130*       or h ; (re)set sign bit
0436BB 67          0131*       ld h,a
0436BC C9          0132*       ret
0436BD             0133*   @arg_is_inf:
0436BD EB          0134*       ex de,hl          ; flip operands to get other arg in hl
0436BE             0135*       SIGN_HL           ; test other arg for zero
                       M1 Args: none
0436BE 19          0001*M1     add hl,de
0436BF B7          0002*M1     or a ; clear flags
0436C0 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
0436C3 28 08       0136*       jr z,@ret_nan     ; zero * inf = NaN
0436C5 21 00 7C 00 0137*       ld hl,0x7C00      ; Inf result
0436C9 79          0138*       ld a,c            ; get product sign
0436CA B4          0139*       or h              ; reapply sign
0436CB 67          0140*       ld h,a
0436CC C9          0141*       ret
0436CD             0142*   @ret_nan:
0436CD 21 00 7E 00 0143*       ld hl,canonicalNaNF16
0436D1 C9          0144*       ret
0436D2             0145*   ; }
0436D2             0052        include "../softfloat/f16_print.inc"
0436D2             0001*   ; inputs: hl = float16 to print
0436D2             0002*   ; outputs: hl points to zero-terminated string
0436D2             0003*   ; destroys: af, bc, de, ix, iy
0436D2             0004*   
0436D2             0005*   ; // uiA    : raw 16-bit half-precision float input (bits)
0436D2             0006*   ; // iy     : output string buffer pointer
0436D2             0007*   ; // strBuff: saved start of output buffer
0436D2             0008*   ; // signA  : sign bit (0 = positive, 1 = negative)
0436D2             0009*   ; // expA   : exponent field (5 bits, biased by 15)
0436D2             0010*   ; // sigA   : fraction/mantissa field (10 bits, no implicit leading 1)
0436D2             0011*   ; // expZ   : unbiased exponent minus 10 (adjusted for 10-bit mantissa shift)
0436D2             0012*   ; // sig32Z : full normalized mantissa (10 or 11 bits as 32-bit value)
0436D2             0013*   ; // sig32X : integer part after applying exponent
0436D2             0014*   ; // sig32Y : fractional part numerator (still divided by 2^expY)
0436D2             0015*   ; // sig48Z   ; mask for sig32Y
0436D2             0016*   ; // expY   : number of bits shifted (i.e., denominator is 2^expY)
0436D2             0017*   ; // temp[] : temporary buffer for reversing integer digits
0436D2             0018*   ; // ti     : counter for integer digit collection
0436D2             0019*   
0436D2             0020*   f16_print:
0436D2             0021*   ; ; DEBUG
0436D2             0022*   ;     ld hl,str_nan
0436D2             0023*   ;     ret
0436D2             0024*   ; ; END DEBUG
0436D2             0025*   
0436D2             0026*   ; ; DEBUG
0436D2             0027*   ;     push hl
0436D2             0028*   ;     ld hl,strBuff0
0436D2             0029*   ;     ld de,strBuff
0436D2             0030*   ;     ld bc,32
0436D2             0031*   ;     ldir
0436D2             0032*   ;     pop hl
0436D2             0033*   ; ; END DEBUG
0436D2             0034*   
0436D2             0035*   ; set index to global variables
0436D2 DD 21 DA 32 0036*       ld ix,s_globals
       04          
0436D7             0037*   ; char* strBuff = iy;              // Save start of output buffer
0436D7             0038*   ; uint16_t signA = uiA >> 15;         // 1-bit signA
0436D7             0039*   ; uint16_t expA  = (uiA >> 10) & 0x1F; // 5-bit exponent (biased by 15)
0436D7             0040*   ; uint16_t sigA = uiA & 0x3FF;       // 10-bit fraction (mantissa)
0436D7             0041*   ; signA = signF16UI( uiA );
0436D7             0042*       signF16UI
                       M1 Args: none
0436D7 7C          0001*M1         ld a,h
0436D8 E6 80       0002*M1         and %10000000
0436DA 4F          0003*M1         ld c,a
0436DB             0043*   ; expA  = expF16UI( uiA );
0436DB             0044*       expF16UI
                       M1 Args: none
0436DB 7C          0001*M1         ld a,h
0436DC 0F          0002*M1         rrca
0436DD 0F          0003*M1         rrca
0436DE E6 1F       0004*M1         and %00011111
0436E0 47          0005*M1         ld b,a
0436E1 DD 0F 06    0045*       ld (ix+signA),bc ; implicitly stores expA
0436E4             0046*   ; sigA  = fracF16UI( uiA );
0436E4             0047*       fracF16UI
                       M1 Args: none
0436E4 7C          0001*M1         ld a,h
0436E5 E6 03       0002*M1         and %00000011
0436E7 67          0003*M1         ld h,a
0436E8 DD 2F 03    0048*       ld (ix+sigA),hl
0436EB             0049*   
0436EB             0050*   ; DEBUG
0436EB             0051*       ; ld a,c
0436EB             0052*       ; PRINT_A_HEX "    signA"
0436EB             0053*       ; ld a,b
0436EB             0054*       ; PRINT_A_HEX "    expA"
0436EB             0055*       ; PRINT_HL_HEX "    sigA"
0436EB             0056*   ; END DEBUG
0436EB             0057*   
0436EB             0058*   ; // Special cases: Inf/NaN&#8203;:contentReference[oaicite:0]{index=0}
0436EB             0059*   ; if (expA == 0x1F) {
0436EB 78          0060*       ld a,b ; expA
0436EC FE 1F       0061*       cp 0x1F ; check expA for inf
0436EE C2 05 37 04 0062*       jp nz,@check_zero
0436F2             0063*   ;     if (sigA == 0) {               // Infinity
0436F2             0064*           ZERO_HL
                       M1 Args: none
0436F2 7C          0001*M1     ld a,h
0436F3 B5          0002*M1     or l
0436F4 C2 00 37 04 0065*           jp nz,@return_nan
0436F8             0066*   ;         *iy++ = 'I'; *iy++ = 'n'; *iy++ = 'f';
0436F8 21 A5 32 04 0067*               ld hl,str_inf
0436FC             0068*   ;         if (signA) *iy++ = '-';
0436FC C3 5C 38 04 0069*               jp @set_sign
043700             0070*   ;     } else {                       // NaN (Not a Number)
043700             0071*       @return_nan:
043700 21 AA 32 04 0072*           ld hl,str_nan
043704 C9          0073*           ret
043705             0074*   ; }
043705             0075*   @check_zero:
043705             0076*   ; // Special case: Zero (expA=0, sigA=0)&#8203;:contentReference[oaicite:1]{index=1}
043705             0077*   ; if (expA == 0 && sigA == 0) {
043705 B7          0078*       or a ; check expA for zero
043706 C2 1B 37 04 0079*       jp nz,@end_specials
04370A             0080*       SIGN_HL ; test sigA for zero (don't use ZERO_HL because it destroys a)
                       M1 Args: none
04370A 19          0001*M1     add hl,de
04370B B7          0002*M1     or a ; clear flags
04370C 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
04370F C2 1B 37 04 0081*       jp nz,@end_specials
043713 21 AF 32 04 0082*           ld hl,str_zero
043717             0083*   ;     if (signA) *iy++ = '-';
043717 C3 5C 38 04 0084*           jp @set_sign
04371B             0085*   ; }
04371B             0086*   @end_specials:
04371B             0087*   ; // Determine normalized mantissa and exponent
04371B             0088*   ; int expZ;
04371B             0089*   ; uint32_t sig32Z;
04371B             0090*   ; if (expA == 0) {
04371B B7          0091*       or a ; check expA for zero
04371C C2 26 37 04 0092*       jp nz,@is_normal
043720             0093*   ;     // Subnormal number: exponent = 1 - bias (15)&#8203;:contentReference[oaicite:2]{index=2}
043720             0094*   ;     expZ = -14;                 // (1 - 15)
043720 3E F2       0095*           ld a,-14
043722             0096*   ;     sig32Z = sigA;                  // no implicit leading 1
043722 C3 2A 37 04 0097*           jp @store_sig32Z
043726             0098*   ; } else {
043726             0099*   @is_normal:
043726             0100*   ;     expZ = (int)expA - 15;
043726 D6 0F       0101*           sub 15 ; expA - 15
043728             0102*   ;     sig32Z   = 0x400 | sigA;        // add implicit 1 (1<<10)
043728 CB D4       0103*           set 2,h ; set implicit 1
04372A             0104*   ; }
04372A             0105*   @store_sig32Z:
04372A             0106*   ; // Now value = (-1)^signA * sig32Z * 2^(expZ - 10)
04372A DD 2F 48    0107*       ld (ix+sig32Z),hl ; store sig32Z low word
04372D 11 00 00 00 0108*       ld de,0 ; clear high word of sig32Z
043731 DD 1F 4A    0109*       ld (ix+sig32Z+2),de ; store sig32Z high word
043734             0110*       ; PRINT_A_HEX "    expZ normalized"
043734             0111*       ; PRINT_DEHL_HEX "sig32Z normalized"
043734             0112*   ; // Incorporate the 2^(-10) factor of the mantissa into exponent
043734             0113*   ; expZ -= 10;
043734 D6 0A       0114*       sub 10 ; expZ - 10
043736             0115*       ; PRINT_A_HEX "    expZ -= 10;"
043736             0116*   ; // Separate integer and fractional parts by base-2 exponent
043736             0117*   ; uint32_t sig32X;
043736             0118*   ; uint32_t sig32Y = 0;
043736 01 00 00 00 0119*       ld bc,0
04373A DD 0F 43    0120*       ld (ix+sig32Y),bc ; clear sig32Y low word
04373D DD 0F 45    0121*       ld (ix+sig32Y+2),bc ; clear sig32Y high word
043740             0122*   ; uint32_t expY = 0;
043740             0123*   ; if (expZ >= 0) {
043740 FA 5C 37 04 0124*       jp m,@expZ_lt0
043744 47          0125*           ld b,a ; loop counter = expZ
043745 AF          0126*           xor a
043746 DD 77 1C    0127*           ld (ix+expY),a ; store expY
043749             0128*           ; PRINT_A_HEX "    expY = 0;"
043749             0129*       @expZ_gte0_loop:
043749             0130*       ; sig32X = sig32Z << expZ;
043749 EB          0131*           ex de,hl ; de = low word
04374A 52 29       0132*           add.s hl,hl ; low word <<= 1, .s to force 16-bit add
04374C EB          0133*           ex de,hl
04374D 52 ED 6A    0134*           adc.s hl,hl ; high word <<= 1, .s to force 16-bit adc
043750 10 F7       0135*           djnz @expZ_gte0_loop ; loop until all bits shifted
043752             0136*           ; PRINT_DEHL_HEX "sig32X = sig32Z << expZ;"
043752 DD 2F 3E    0137*           ld (ix+sig32X),hl ; store sig32X low word
043755 DD 1F 40    0138*           ld (ix+sig32X+2),de ; store sig32X high word
043758             0139*           ; ld bc,0 ; DEBUG
043758             0140*           ; PRINT_BC_HEX "    sig32Y = 0;"
043758 C3 91 37 04 0141*           jp @convert_int_to_string
04375C             0142*   ; } else {
04375C             0143*   @expZ_lt0:
04375C             0144*   ;     expY = (uint32_t)(-expZ);
04375C ED 44       0145*           neg ; a = -expZ
04375E DD 77 1C    0146*           ld (ix+expY),a ; store
043761             0147*           ; PRINT_A_HEX "    expY =-expZ;"
043761 47          0148*           ld b,a ; loop counter = expY
043762             0149*       @expZ_lt0_loop_sig32X:
043762             0150*       ; sig32X = sig32Z >> expY;
043762 CB 3C       0151*           srl h ; low word high byte >>= 1
043764 CB 1D       0152*           rr l ; low word low byte >>= 1
043766 10 FA       0153*           djnz @expZ_lt0_loop_sig32X ; loop until all bits shifted
043768             0154*           ; PRINT_DEHL_HEX "sig32X = sig32Z >> expY;"
043768 DD 2F 3E    0155*           ld (ix+sig32X),hl ; store sig32X low word
04376B DD 1F 40    0156*           ld (ix+sig32X+2),de ; store sig32X high word
04376E             0157*       ; sig32Y      = sig32Z & ((1u << expY) - 1);
04376E 21 01 00 00 0158*           ld hl,1
043772 47          0159*           ld b,a ; loop counter = expY (max 25)
043773             0160*           @expZ_lt0_loop_sig32Y:
043773 29          0161*               add hl,hl
043774 10 FD       0162*               djnz @expZ_lt0_loop_sig32Y ; loop until all bits shifted
043776 2B          0163*           dec hl
043777 DD 2F 4D    0164*           ld (ix+sig48Z),hl ; mask for sig32Y
04377A             0165*           ; PRINT_UHL_HEX "  sig48Z = (1u << expY) - 1;"
04377A DD 17 48    0166*           ld de,(ix+sig32Z) ; get sig32Z low word
04377D 7D          0167*           ld a,l
04377E A3          0168*           and e
04377F 5F          0169*           ld e,a
043780 7C          0170*           ld a,h
043781 A2          0171*           and d
043782 57          0172*           ld d,a
043783 DD 7E 4F    0173*           ld a,(ix+sig48Z+2) ; mask middle low byte
043786 DD 27 4A    0174*           ld hl,(ix+sig32Z+2) ; get sig32Z high word
043789 A5          0175*           and l
04378A 6F          0176*           ld l,a
04378B DD 1F 43    0177*           ld (ix+sig32Y),de ; store sig32Y low word
04378E DD 2F 45    0178*           ld (ix+sig32Y+2),hl ; store sig32Y high word
043791             0179*   ; }
043791             0180*   @convert_int_to_string:
043791 FD 21 BF 32 0181*       ld iy,strBuff+5 ; one's place
       04          
043796             0182*   ; if (sig32X == 0) {
043796 DD 27 3E    0183*       ld hl,(ix+sig32X) ; get sig32X low word
043799             0184*       ZERO_HL
                       M1 Args: none
043799 7C          0001*M1     ld a,h
04379A B5          0002*M1     or l
04379B C2 AC 37 04 0185*       jp nz,@sig32X_not_zero
04379F             0186*   ;     *iy++ = '0';
04379F 3E 30       0187*           ld a,'0'
0437A1 FD 77 00    0188*           ld (iy),a
0437A4 FD 2B       0189*           dec iy
0437A6 3E 04       0190*           ld a,4 ; 4-spaces
0437A8 C3 D4 37 04 0191*           jp @write_spaces
0437AC             0192*   ; } else {
0437AC             0193*       @sig32X_not_zero:
0437AC             0194*   ;     char temp[16];
0437AC             0195*   ;     int ti = 0;
0437AC F3          0196*           di ; we'll be using af'
0437AD 3E 05       0197*           ld a,5 ; ti = max integer digits
0437AF             0198*   ;     while (sig32X) {
0437AF             0199*           @write_sig32X_loop:
0437AF             0200*               SIGN_HL ; check sig32X for zero (don't use ZERO_HL because that destroys a)
                       M1 Args: none
0437AF 19          0001*M1     add hl,de
0437B0 B7          0002*M1     or a ; clear flags
0437B1 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
0437B4 CA D4 37 04 0201*               jp z,@write_spaces
0437B8 E5          0202*               push hl ; save sig32X
0437B9 08          0203*               ex af,af' ; save ti
0437BA             0204*   ;         temp[ti++] = '0' + (sig32X % 10);
0437BA CD A1 33 04 0205*               call hl_mod10
0437BE C6 30       0206*               add a,'0'
0437C0 FD 77 00    0207*               ld (iy),a ; store digit
0437C3 FD 2B       0208*               dec iy ; move to next position
0437C5             0209*   ;         sig32X  /= 10;
0437C5 E1          0210*               pop hl ; restore sig32X
0437C6 11 9A 19 00 0211*               ld de,0x199A ; reciprocal
0437CA CD 4C 33 04 0212*               call mul_16x16_32
0437CE 08          0213*               ex af,af' ; restore ti
0437CF 3D          0214*               dec a ; decrement ti
0437D0 C3 AF 37 04 0215*               jp @write_sig32X_loop ; loop until all digits written
0437D4             0216*   ;     }
0437D4             0217*       @write_spaces:
0437D4 FB          0218*           ei
0437D5             0219*           ; PRINT_A_HEX "    ti"
0437D5 B7          0220*           or a
0437D6 28 0A       0221*           jr z,@do_frac
0437D8 47          0222*           ld b,a ; loop counter = ti
0437D9 3E 20       0223*           ld a,' '
0437DB             0224*   ;     while (ti--) {
0437DB             0225*           @write_spaces_loop:
0437DB             0226*   ;         *iy++ = temp[ti];
0437DB FD 77 00    0227*               ld (iy),a ; store space
0437DE FD 2B       0228*               dec iy ; move to next position
0437E0 10 F9       0229*           djnz @write_spaces_loop ; loop until all spaces written
0437E2             0230*   ;     }
0437E2             0231*   ; }
0437E2             0232*   ; // Convert fractional part (if any) by multiplying by 10 repeatedly
0437E2             0233*   @do_frac:
0437E2 FD 21 C0 32 0234*       ld iy,strBuff+6 ; decimal point
       04          
0437E7             0235*   ; if (sig32Y != 0) {
0437E7 DD 27 43    0236*       ld hl,(ix+sig32Y) ; get sig32Y low word
0437EA             0237*       ZERO_HL
                       M1 Args: none
0437EA 7C          0001*M1     ld a,h
0437EB B5          0002*M1     or l
0437EC CA 52 38 04 0238*       jp z,@terminate_string
0437F0             0239*   ;     *iy++ = '.';
0437F0 3E 2E       0240*           ld a,'.'
0437F2 FD 77 00    0241*           ld (iy),a ; store decimal point
0437F5 DD 27 43    0242*           ld hl,(ix+sig32Y) ; sig32Y low word
0437F8 DD 17 45    0243*           ld de,(ix+sig32Y+2) ; sig32Y high word
0437FB             0244*       @write_frac_loop:
0437FB             0245*   ;    while (sig32Y != 0) {
0437FB             0246*           ZERO_HL ; check sig32Y low word for zero
                       M1 Args: none
0437FB 7C          0001*M1     ld a,h
0437FC B5          0002*M1     or l
0437FD C2 09 38 04 0247*           jp nz,@sig32Y_not_zero
043801 EB          0248*           ex de,hl ; hl = high word, de = low word
043802             0249*           ZERO_HL ; check sig32Y high word for zero
                       M1 Args: none
043802 7C          0001*M1     ld a,h
043803 B5          0002*M1     or l
043804 EB          0250*           ex de,hl ; hl = low word, de = high word
043805 CA 52 38 04 0251*           jp z,@terminate_string
043809             0252*   ;         sig32Y *= 10;
043809             0253*           @sig32Y_not_zero:
043809 52 29       0254*               add.s hl,hl
04380B EB          0255*               ex de,hl
04380C ED 6A       0256*               adc hl,hl
04380E EB          0257*               ex de,hl ; sig32Y * 2
04380F D5          0258*               push de ; sig32Y * 2 high word
043810 E5          0259*               push hl ; sig32Y * 2 low word
043811 52 29       0260*               add.s hl,hl
043813 EB          0261*               ex de,hl
043814 ED 6A       0262*               adc hl,hl
043816 EB          0263*               ex de,hl ; sig32Y * 4
043817 52 29       0264*               add.s hl,hl
043819 EB          0265*               ex de,hl
04381A ED 6A       0266*               adc hl,hl
04381C EB          0267*               ex de,hl ; sig32Y * 8
04381D C1          0268*               pop bc ; sig32Y * 2 low word
04381E 52 09       0269*               add.s hl,bc
043820 EB          0270*               ex de,hl
043821 C1          0271*               pop bc ; sig32Y * 2 high word
043822 ED 4A       0272*               adc hl,bc
043824 EB          0273*               ex de,hl ; sig32Y * 10
043825             0274*               ; PRINT_DEHL_HEX "DEHL * 10"
043825 D5          0275*               push de ; sig32Y high word
043826 E5          0276*               push hl ; sig32Y low word
043827             0277*   ;         uint32_t digit = sig32Y >> expY;           // divide by 2^expY
043827 DD 46 1C    0278*               ld b,(ix+expY) ; expY = loop counter
04382A             0279*               @digit_loop:
04382A CB 3A       0280*                   srl d
04382C CB 1B       0281*                   rr e
04382E CB 1C       0282*                   rr h
043830 CB 1D       0283*                   rr l
043832 10 F6       0284*                   djnz @digit_loop ; l is our digit at the end of the loop
043834             0285*   ;         *iy++ = (char)('0' + digit);
043834 FD 23       0286*               inc iy ; move to next position
043836 3E 30       0287*               ld a,'0'
043838 85          0288*               add a,l ; convert digit to ASCII
043839 FD 77 00    0289*               ld (iy),a ; store digit
04383C             0290*   ;         sig32Y &= ((1u << expY) - 1);              // sig32Y mod 2^expY
04383C DD 07 4D    0291*               ld bc,(ix+sig48Z) ; get mask low word
04383F E1          0292*               pop hl ; sig32Y low word
043840 79          0293*               ld a,c
043841 A5          0294*               and l
043842 6F          0295*               ld l,a
043843 78          0296*               ld a,b
043844 A4          0297*               and h
043845 67          0298*               ld h,a
043846 DD 7E 4F    0299*               ld a,(ix+sig48Z+2) ; get mask middle high byte
043849 D1          0300*               pop de ; sig32Y high word
04384A A3          0301*               and e
04384B 5F          0302*               ld e,a
04384C 16 00       0303*               ld d,0 ; high byte will always be masked out TODO: VERIFY
04384E             0304*               ; PRINT_DEHL_HEX "sig32Y &= ((1u << expY) - 1);"
04384E C3 FB 37 04 0305*               jp @write_frac_loop
043852             0306*   ;     }
043852             0307*   ; }
043852             0308*   
043852             0309*   ; *iy = '\0';  // null-terminate the string
043852             0310*   @terminate_string:
043852 AF          0311*       xor a ; zero = null terminator
043853 FD 23       0312*       inc iy
043855 FD 77 00    0313*       ld (iy),a
043858             0314*   ; return strBuff;
043858 21 BA 32 04 0315*       ld hl,strBuff
04385C             0316*   @set_sign:
04385C             0317*   ; set sign
04385C DD 7E 06    0318*       ld a,(ix+signA) ; signA
04385F B7          0319*       or a ; check signA for zero
043860 C2 6A 38 04 0320*       jp nz,@sign_neg
043864 3E 20       0321*       ld a,' ' ; positive sign
043866 C3 6C 38 04 0322*       jp @write_sign
04386A             0323*   @sign_neg:
04386A 3E 2D       0324*       ld a,'-' ; negative sign
04386C             0325*   @write_sign:
04386C 77          0326*       ld (hl),a ; store sign
04386D C9          0327*       ret
04386E             0053        include "../softfloat/f16_sqrt.inc"
04386E             0001*   ; sqrt of a 16-bit floating point number
04386E             0002*   ; inputs: hl = a, de = b
04386E             0003*   ; outputs: hl = a - b
04386E             0004*   ; destroys: af, bc, de, ix
04386E             0005*   f16_sqrt:
04386E             0006*   ; set index to global variables
04386E DD 21 DA 32 0007*       ld ix,s_globals
       04          
043873             0008*   ; save original value of a
043873 DD 2F 00    0009*       ld (ix+uiA),hl ; store uiA
043876             0010*   ; extract the sign, exponent and significand
043876             0011*   ; signA = signF16UI( uiA );
043876             0012*       signF16UI
                       M1 Args: none
043876 7C          0001*M1         ld a,h
043877 E6 80       0002*M1         and %10000000
043879 4F          0003*M1         ld c,a
04387A             0013*   ; expA  = expF16UI( uiA );
04387A             0014*       expF16UI
                       M1 Args: none
04387A 7C          0001*M1         ld a,h
04387B 0F          0002*M1         rrca
04387C 0F          0003*M1         rrca
04387D E6 1F       0004*M1         and %00011111
04387F 47          0005*M1         ld b,a
043880 DD 0F 06    0015*       ld (ix+signA),bc ; implicitly stores expA
043883             0016*   ; sigA  = fracF16UI( uiA );
043883             0017*       fracF16UI
                       M1 Args: none
043883 7C          0001*M1         ld a,h
043884 E6 03       0002*M1         and %00000011
043886 67          0003*M1         ld h,a
043887 DD 2F 03    0018*       ld (ix+sigA),hl
04388A             0019*   ; /*------------------------------------------------------------------------
04388A             0020*   ; *------------------------------------------------------------------------*/
04388A             0021*   ; if ( expA == 0x1F ) {
04388A 78          0022*       ld a,b ; expA
04388B FE 1F       0023*       cp 0x1F ; check expA for inf
04388D C2 A7 38 04 0024*       jp nz,@expA_not_inf
043891             0025*   ;     if ( sigA ) {
043891 7D          0026*           ld a,l
043892 B4          0027*           or h
043893 28 05       0028*           jr z,@F
043895             0029*   ;         uiZ = softfloat_propagateNaNF16UI( uiA, 0 );
043895             0030*   ;         goto uiZ;
043895 21 00 7E 00 0031*               ld hl,canonicalNaNF16
043899 C9          0032*               ret
04389A             0033*   ;     }
04389A             0034*   @@:
04389A             0035*   ;     if ( ! signA ) return a;
04389A 79          0036*           ld a,c ; signA
04389B B7          0037*           or a
04389C 20 04       0038*           jr nz,@F
04389E DD 27 00    0039*           ld hl,(ix+uiA) ; uiZ = uiA
0438A1 C9          0040*           ret
0438A2             0041*   @@:
0438A2             0042*   ;     goto invalid;
0438A2 21 00 7E 00 0043*           ld hl,canonicalNaNF16
0438A6 C9          0044*           ret
0438A7             0045*   ; }
0438A7             0046*   @expA_not_inf:
0438A7             0047*   ; /*------------------------------------------------------------------------
0438A7             0048*   ; *------------------------------------------------------------------------*/
0438A7             0049*   ; if ( signA ) {
0438A7 79          0050*       ld a,c ; signA
0438A8 B7          0051*       or a ; check signA for zero
0438A9 CA C2 38 04 0052*       jp z,@signA_zero
0438AD             0053*   ;     if ( ! (expA | sigA) ) return a;
0438AD 78          0054*           ld a,b ; expA
0438AE B7          0055*           or a ; check expA for zero
0438AF C2 BD 38 04 0056*           jp nz,@F
0438B3 7D          0057*           ld a,l
0438B4 B4          0058*           or h ; test sigA for zero
0438B5 C2 BD 38 04 0059*           jp nz,@F
0438B9 DD 27 00    0060*           ld hl,(ix+uiA) ; uiZ = uiA
0438BC C9          0061*           ret
0438BD             0062*   @@:
0438BD             0063*   ;     goto invalid;
0438BD 21 00 7E 00 0064*           ld hl,canonicalNaNF16
0438C1 C9          0065*           ret
0438C2             0066*   ; }
0438C2             0067*   @signA_zero:
0438C2             0068*   ; /*------------------------------------------------------------------------
0438C2             0069*   ; *------------------------------------------------------------------------*/
0438C2             0070*   ; if ( ! expA ) {
0438C2 78          0071*       ld a,b ; expA
0438C3 B7          0072*       or a ; check expA for zero
0438C4 C2 DC 38 04 0073*       jp nz,@expA_not_zero
0438C8             0074*   ;     if ( ! sigA ) return a;
0438C8 7D          0075*           ld a,l
0438C9 B4          0076*           or h ; test sigA for zero
0438CA C2 D2 38 04 0077*           jp nz,@F
0438CE DD 27 00    0078*           ld hl,(ix+uiA) ; uiZ = uiA
0438D1 C9          0079*           ret
0438D2             0080*   @@:
0438D2             0081*   ;     normExpSig = softfloat_normSubnormalF16Sig( sigA );
0438D2 CD 5D 3B 04 0082*           call softfloat_normSubnormalF16Sig
0438D6 DD 2F 03    0083*           ld (ix+sigA),hl ; store normalised sigA
0438D9             0084*   ;     expA = normExpSig.exp;
0438D9             0085*   ;     sigA = normExpSig.sig;
0438D9 DD 0F 06    0086*           ld (ix+signA),bc ; implicitly stores expA
0438DC             0087*   ; }
0438DC             0088*   @expA_not_zero:
0438DC             0089*   ; /*------------------------------------------------------------------------
0438DC             0090*   ; *------------------------------------------------------------------------*/
0438DC             0091*   ; expZ = ((expA - 0xF)>>1) + 0xE;
0438DC 78          0092*       ld a,b ; expA
0438DD D6 0F       0093*       sub 0xF ; expA - 0xF
0438DF CB 2F       0094*       sra a ; expA - 0xF >> 1
0438E1 C6 0E       0095*       add a,0xE ; expZ = ((expA - 0xF)>>1) + 0xE
0438E3 DD 77 25    0096*       ld (ix+expZ),a ; store expZ
0438E6             0097*   ; expA &= 1;
0438E6 78          0098*       ld a,b ; expA
0438E7 E6 01       0099*       and 1 ; expA &= 1
0438E9 47          0100*       ld b,a ; b = expA
0438EA DD 77 07    0101*       ld (ix+expA),a ; store expA
0438ED             0102*   ; sigA |= 0x0400;
0438ED CB D4       0103*       set 2,h ; set implicit 1
0438EF             0104*   ; index = (sigA>>6 & 0xE) + expA;
0438EF DD 2F 03    0105*       ld (ix+sigA),hl ; store sigA
0438F2 29          0106*       add hl,hl ; sigA <<= 1
0438F3 29          0107*       add hl,hl ; sigA <<= 1
0438F4 3E 0E       0108*       ld a,0xE
0438F6 A4          0109*       and h
0438F7 80          0110*       add a,b ; a = index
0438F8 87          0111*       add a,a ; two bytes per LUT entry
0438F9 11 00 00 00 0112*       ld de,0
0438FD 5F          0113*       ld e,a
0438FE FD E5       0114*       push iy ; preserve iy
043900 FD 21 4C 34 0115*       ld iy,softfloat_approxRecipSqrt_1k0s
       04          
043905 FD 19       0116*       add iy,de
043907             0117*   ; r0 = softfloat_approxRecipSqrt_1k0s[index] - (((uint_fast32_t) softfloat_approxRecipSqrt_1k1s[index] * (sigA & 0x7F))>>11);
043907 FD 27 20    0118*       ld hl,(iy+32) ; approxRecipSqrt_1k1s
04390A DD 7E 03    0119*       ld a,(ix+sigA) ; sigA low byte
04390D E6 7F       0120*       and 0x7F ; sigA & 0x7F
04390F CD 2E 33 04 0121*       call mul_16x8_24_ade ; ade holds the 24-bit product
043913 5A          0122*       ld e,d
043914 57          0123*       ld d,a
043915 CB 3A       0124*       srl d
043917 CB 1B       0125*       rr e
043919 CB 3A       0126*       srl d
04391B CB 1B       0127*       rr e
04391D CB 3A       0128*       srl d
04391F CB 1B       0129*       rr e
043921 FD 27 00    0130*       ld hl,(iy) ; approxRecipSqrt_1k0s
043924 FD E1       0131*       pop iy ; restore iy since no longer needed
043926 B7          0132*       or a ; clear carry
043927 ED 52       0133*       sbc hl,de ; hl = approxRecipSqrt_1k0s - approxRecipSqrt_1k1s
043929 DD 2F 2C    0134*       ld (ix+r0),hl ; store r0
04392C             0135*   ; ESqrR0 = ((uint_fast32_t) r0 * r0)>>1;
04392C 5D          0136*       ld e,l
04392D 54          0137*       ld d,h
04392E CD 4C 33 04 0138*       call mul_16x16_32 ; hlde = r0 * r0
043932 CB 3C       0139*       srl h
043934 CB 1D       0140*       rr l
043936 CB 1A       0141*       rr d
043938 CB 1B       0142*       rr e ; hlde = (r0 * r0)>>1
04393A             0143*   ; if ( expA ) ESqrR0 >>= 1;
04393A DD 7E 07    0144*       ld a,(ix+expA) ; expA
04393D B7          0145*       or a ; check expA for zero
04393E CA 4A 39 04 0146*       jp z,@F
043942 CB 3C       0147*       srl h
043944 CB 1D       0148*       rr l
043946 CB 1A       0149*       rr d
043948 CB 1B       0150*       rr e
04394A             0151*   @@:
04394A             0152*   ; sigma0 = ~(uint_fast16_t) ((ESqrR0 * sigA)>>16);
04394A DD 07 03    0153*       ld bc,(ix+sigA) ; sigA
04394D CD 6C 33 04 0154*       call mul_32x16_48 ; hlde = (ESqrR0 * sigA)>>16
043951 EB          0155*       ex de,hl
043952 7D          0156*       ld a,l
043953 2F          0157*       cpl
043954 6F          0158*       ld l,a
043955 7C          0159*       ld a,h
043956 2F          0160*       cpl
043957 67          0161*       ld h,a
043958             0162*   ; recipSqrt16 = r0 + (((uint_fast32_t) r0 * sigma0)>>25);
043958 DD 17 2C    0163*       ld de,(ix+r0)
04395B CD 4C 33 04 0164*       call mul_16x16_32 ; hlde = r0 * sigma0
04395F 7C          0165*       ld a,h
043960 CB 3F       0166*       srl a
043962 DD 27 2C    0167*       ld hl,(ix+r0)
043965 85          0168*       add a,l
043966 6F          0169*       ld l,a
043967 8C          0170*       adc a,h
043968 95          0171*       sub l
043969 67          0172*       ld h,a
04396A             0173*   ; if ( ! (recipSqrt16 & 0x8000) ) recipSqrt16 = 0x8000;
04396A 7C          0174*       ld a,h
04396B E6 80       0175*       and 0x80
04396D B7          0176*       or a ; check MSB
04396E C2 76 39 04 0177*       jp nz,@F
043972 21 00 80 00 0178*       ld hl,0x8000
043976             0179*   @@:
043976             0180*   ; sigZ = ((uint_fast32_t) (sigA<<5) * recipSqrt16)>>16;
043976 EB          0181*       ex de,hl ; de = recipSqrt16
043977 DD 27 03    0182*       ld hl,(ix+sigA) ; sigA
04397A 29          0183*       add hl,hl ; sigA <<= 1
04397B 29          0184*       add hl,hl ; sigA <<= 2
04397C 29          0185*       add hl,hl ; sigA <<= 3
04397D 29          0186*       add hl,hl ; sigA <<= 4
04397E 29          0187*       add hl,hl ; sigA <<= 5
04397F CD 4C 33 04 0188*       call mul_16x16_32 ; hlde = (sigA<<5) * recipSqrt16
043983             0189*   ; if ( expA ) sigZ >>= 1;
043983 DD 7E 07    0190*       ld a,(ix+expA) ; expA
043986 B7          0191*       or a ; check expA for zero
043987 CA 8F 39 04 0192*       jp z,@F
04398B CB 3C       0193*       srl h
04398D CB 1D       0194*       rr l
04398F             0195*   @@:
04398F             0196*   ; /*------------------------------------------------------------------------
04398F             0197*   ; *------------------------------------------------------------------------*/
04398F             0198*   ; ++sigZ;
04398F 23          0199*       inc hl
043990             0200*   ; if ( ! (sigZ & 7) ) {
043990 7D          0201*       ld a,l
043991 E6 07       0202*       and 0x07
043993 C2 B4 39 04 0203*       jp nz,@return_roundPack
043997             0204*   ;     shiftedSigZ = sigZ>>1;
043997 E5          0205*           push hl ; stash sigZ
043998 CB 3C       0206*           srl h
04399A CB 1D       0207*           rr l
04399C             0208*   ;     negRem = shiftedSigZ * shiftedSigZ;
04399C 5D          0209*           ld e,l
04399D 54          0210*           ld d,h
04399E CD 4C 33 04 0211*           call mul_16x16_32 ; hlde = shiftedSigZ * shiftedSigZ
0439A2             0212*   ;     sigZ &= ~1;
0439A2 E1          0213*           pop hl ; restore sigZ
0439A3 CB 85       0214*           res 0,l
0439A5             0215*   ;     if ( negRem & 0x8000 ) {
0439A5 7A          0216*           ld a,d
0439A6 E6 80       0217*           and 0x80
0439A8 B7          0218*           or a ; check MSB
0439A9 28 04       0219*           jr z,@F
0439AB             0220*   ;         sigZ |= 1;
0439AB CB C5       0221*               set 0,l ; set the LSB of sigZ
0439AD 18 05       0222*               jr @return_roundPack
0439AF             0223*   ;     } else {
0439AF             0224*   @@:
0439AF             0225*   ;         if ( negRem ) --sigZ;
0439AF 7A          0226*               ld a,d
0439B0 B3          0227*               or e
0439B1 28 01       0228*               jr z,@return_roundPack
0439B3 2B          0229*               dec hl
0439B4             0230*   ;     }
0439B4             0231*   ; }
0439B4             0232*   @return_roundPack:
0439B4             0233*   ; return softfloat_roundPackToF16( 0, expZ, sigZ );
0439B4 0E 00       0234*       ld c,0 ; sign is always positive for sqrt
0439B6 DD 46 25    0235*       ld b,(ix+expZ) ; b = expZ
0439B9 C3 66 3B 04 0236*       jp softfloat_roundPackToF16 ; assumes hl holds sigZ
0439BD             0237*   ; /*------------------------------------------------------------------------
0439BD             0238*   ; *------------------------------------------------------------------------*/
0439BD             0239*   ; invalid:
0439BD             0240*   ; softfloat_raiseFlags( softfloat_flag_invalid );
0439BD             0241*   ; uiZ = defaultNaNF16UI;
0439BD             0242*   ; uiZ:
0439BD             0243*   ; uZ.ui = uiZ;
0439BD             0244*   ; return uZ.f;
0439BD             0245*   
0439BD             0246*   ; }
0439BD             0247*   ; end f16_sqrt
0439BD             0248*   
0439BD             0249*   
0439BD             0250*   
0439BD             0054        include "../softfloat/f16_sub.inc"
0439BD             0001*   ; sub two 16-bit floating point numbers
0439BD             0002*   ; inputs: hl = a, de = b
0439BD             0003*   ; outputs: hl = a - b
0439BD             0004*   ; destroys: af, bc, de, ix
0439BD             0005*   f16_sub:
0439BD             0006*   ; flip sign of opB and call f16_add
0439BD 7A          0007*       ld a,d ; sign opB
0439BE EE 80       0008*       xor %10000000 ; flip sign
0439C0 57          0009*       ld d,a ; store sign opB
0439C1 C3 8C 34 04 0010*       jp f16_add ; call f16_add
0439C5             0011*   ; end f16_sub
0439C5             0055        include "../softfloat/s_addMagsF16.inc"
0439C5             0001*   ; add two 16-bit floating point numbers of the same sign
0439C5             0002*   ; inputs : hl = uiA, de = uiB, ix = s_globals
0439C5             0003*   ; outputs: hl = uiA + uiB
0439C5             0004*   ; destroys: af, bc, de
0439C5             0005*   softfloat_addMagsF16:
0439C5 DD 2F 00    0006*       ld (ix+uiA),hl ; store uiA
0439C8 DD 1F 09    0007*       ld (ix+uiB),de ; store uiB
0439CB             0008*   ; expA = expF16UI( uiA );
0439CB             0009*       expF16UI
                       M1 Args: none
0439CB 7C          0001*M1         ld a,h
0439CC 0F          0002*M1         rrca
0439CD 0F          0003*M1         rrca
0439CE E6 1F       0004*M1         and %00011111
0439D0 47          0005*M1         ld b,a
0439D1             0010*       signF16UI
                       M1 Args: none
0439D1 7C          0001*M1         ld a,h
0439D2 E6 80       0002*M1         and %10000000
0439D4 4F          0003*M1         ld c,a
0439D5 DD 0F 06    0011*       ld (ix+signA),bc ; implicitly stores expA
0439D8 DD 71 24    0012*       ld (ix+signZ),c ; signZ will be the same as signA or signB in this function
0439DB             0013*   ; sigA = fracF16UI( uiA );
0439DB             0014*       fracF16UI
                       M1 Args: none
0439DB 7C          0001*M1         ld a,h
0439DC E6 03       0002*M1         and %00000011
0439DE 67          0003*M1         ld h,a
0439DF DD 2F 03    0015*       ld (ix+sigA),hl ; store sigA
0439E2             0016*   ; expB = expF16UI( uiB );
0439E2 EB          0017*       ex de,hl ; flip operands
0439E3             0018*       expF16UI
                       M1 Args: none
0439E3 7C          0001*M1         ld a,h
0439E4 0F          0002*M1         rrca
0439E5 0F          0003*M1         rrca
0439E6 E6 1F       0004*M1         and %00011111
0439E8 47          0005*M1         ld b,a
0439E9             0019*       signF16UI
                       M1 Args: none
0439E9 7C          0001*M1         ld a,h
0439EA E6 80       0002*M1         and %10000000
0439EC 4F          0003*M1         ld c,a
0439ED DD 0F 0F    0020*       ld (ix+signB),bc ; implicitly stores expB
0439F0             0021*   ; sigB = fracF16UI( uiB );
0439F0             0022*       fracF16UI
                       M1 Args: none
0439F0 7C          0001*M1         ld a,h
0439F1 E6 03       0002*M1         and %00000011
0439F3 67          0003*M1         ld h,a
0439F4 DD 2F 0C    0023*       ld (ix+sigB),hl ; store sigB
0439F7             0024*   ; expDiff = expA - expB;
0439F7 DD 7E 07    0025*       ld a,(ix+expA)
0439FA 90          0026*       sub b
0439FB DD 77 27    0027*       ld (ix+expDiff),a ; store expDiff
0439FE             0028*   ; if ( ! expDiff ) {
0439FE C2 56 3A 04 0029*       jp nz,@expDiff_not_zero
043A02             0030*   ;     if ( ! expA ) {
043A02 DD 7E 07    0031*           ld a,(ix+expA)
043A05 B7          0032*           or a ; check expA for zero
043A06 C2 0F 3A 04 0033*           jp nz,@expA_not_zero
043A0A             0034*   ;         uiZ = uiA + sigB;
043A0A DD 17 00    0035*               ld de,(ix+uiA)
043A0D 19          0036*               add hl,de
043A0E             0037*   ;         goto uiZ;
043A0E C9          0038*               ret ; jp @uiZ
043A0F             0039*   ;     }
043A0F             0040*   @expA_not_zero:
043A0F             0041*   ;     if ( expA == 0x1F ) {
043A0F FE 1F       0042*           cp 0x1F ; check expA for inf
043A11 C2 2E 3A 04 0043*           jp nz,@expA_not_infA
043A15             0044*   ;         if ( sigA | sigB ) goto propagateNaN;
043A15             0045*               SIGN_HL ; test sigB for zero
                       M1 Args: none
043A15 19          0001*M1     add hl,de
043A16 B7          0002*M1     or a ; clear flags
043A17 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043A1A C2 56 3B 04 0046*               jp nz,@propagateNaN
043A1E DD 27 03    0047*               ld hl,(ix+sigA)
043A21             0048*               SIGN_HL ; test sigA for zero
                       M1 Args: none
043A21 19          0001*M1     add hl,de
043A22 B7          0002*M1     or a ; clear flags
043A23 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043A26 C2 56 3B 04 0049*               jp nz,@propagateNaN
043A2A             0050*   ;         uiZ = uiA;
043A2A             0051*   ;         goto uiZ;
043A2A DD 27 00    0052*               ld hl,(ix+uiA)
043A2D C9          0053*               ret ; jp @uiZ
043A2E             0054*   ;     }
043A2E             0055*   @expA_not_infA:
043A2E             0056*   ;     signZ = signF16UI( uiA );
043A2E             0057*   ;     expZ = expA;
043A2E DD 07 06    0058*           ld bc,(ix+signA) ; expZ = b, signZ = c
043A31             0059*   ;     sigZ = 0x0800 + sigA + sigB;
043A31 DD 27 03    0060*           ld hl,(ix+sigA)
043A34 DD 17 0C    0061*           ld de,(ix+sigB)
043A37 19          0062*           add hl,de ; hl = sigA + sigB
043A38 CB DC       0063*           set 3,h; add implicit 1
043A3A             0064*   ;     if ( ! (sigZ & 1) && (expZ < 0x1E) ) {
043A3A CB 45       0065*           bit 0,l ; test sigZ for odd
043A3C C2 4F 3A 04 0066*           jp nz,@sigZ_odd
043A40 78          0067*           ld a,b ; expZ
043A41 FE 1E       0068*           cp 0x1E ; check expZ for 0x1E
043A43 D2 4F 3A 04 0069*           jp nc,@sigZ_odd
043A47             0070*   ;         sigZ >>= 1;
043A47 CB 3C       0071*               srl h
043A49 CB 1D       0072*               rr l
043A4B             0073*   ;         goto pack;
043A4B C3 05 34 04 0074*               jp packToF16UI
043A4F             0075*   ;     }
043A4F             0076*   @sigZ_odd:
043A4F             0077*   ;     sigZ <<= 3;
043A4F 29          0078*           add hl,hl
043A50 29          0079*           add hl,hl
043A51 29          0080*           add hl,hl
043A52 C3 66 3B 04 0081*           jp softfloat_roundPackToF16
043A56             0082*   ; } else {
043A56             0083*   @expDiff_not_zero:
043A56             0084*   ;     signZ = signF16UI( uiA );
043A56             0085*   ;     if ( expDiff < 0 ) {
043A56 B7          0086*           or a ; check for negative
043A57 F2 AC 3A 04 0087*           jp p,@expDiff_positive
043A5B 57          0088*           ld d,a ; keep expDiff handy
043A5C             0089*   ;         if ( expB == 0x1F ) {
043A5C DD 7E 10    0090*               ld a,(ix+expB)
043A5F FE 1F       0091*               cp 0x1F ; check expB for inf
043A61 C2 7B 3A 04 0092*               jp nz,@expB_not_infB
043A65             0093*   ;             if ( sigB ) goto propagateNaN;
043A65 DD 27 0C    0094*                   ld hl,(ix+sigB)
043A68             0095*                   SIGN_HL ; test sigB for zero
                       M1 Args: none
043A68 19          0001*M1     add hl,de
043A69 B7          0002*M1     or a ; clear flags
043A6A 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043A6D C2 56 3B 04 0096*                   jp nz,@propagateNaN
043A71             0097*   ;             uiZ = packToF16UI( signZ, 0x1F, 0 );
043A71             0098*   ;             goto uiZ;
043A71 21 00 7C 00 0099*                   ld hl,0x7C00 ; +inf
043A75 DD 7E 06    0100*                   ld a,(ix+signA)
043A78 B4          0101*                   or h
043A79 67          0102*                   ld h,a
043A7A C9          0103*                   ret
043A7B             0104*   ;         }
043A7B             0105*   @expB_not_infB:
043A7B             0106*   ;         if ( expDiff <= -13 ) {
043A7B 3E F3       0107*               ld a,-13
043A7D BA          0108*               cp d
043A7E 38 04       0109*               jr c,@expDiff_gt_neg13
043A80             0110*   ;             uiZ = packToF16UI( signZ, expB, sigB );
043A80 DD 27 09    0111*                   ld hl,(ix+uiB)
043A83             0112*   ;             if ( expA | sigA ) goto addEpsilon; // no need to do this
043A83             0113*   ;             goto uiZ; // or this
043A83 C9          0114*                   ret
043A84             0115*   ;         }
043A84             0116*   @expDiff_gt_neg13:
043A84             0117*   ;         expZ = expB;
043A84 DD 7E 10    0118*               ld a,(ix+expB)
043A87 DD 77 25    0119*               ld (ix+expZ),a
043A8A             0120*   ;         sigX = sigB | 0x0400;
043A8A DD 27 0C    0121*               ld hl,(ix+sigB)
043A8D CB D4       0122*               set 2,h ; set implicit 1
043A8F DD 2F 12    0123*               ld (ix+sigX),hl ; store sigX
043A92             0124*   ;         sigY = sigA + (expA ? 0x0400 : sigA);
043A92 DD 27 03    0125*               ld hl,(ix+sigA)
043A95 DD 7E 07    0126*               ld a,(ix+expA)
043A98 B7          0127*               or a
043A99 28 04       0128*               jr z,@expA_Zero
043A9B CB D4       0129*               set 2,h ; set implicit 1
043A9D 18 01       0130*               jr @set_sigY_to_sigA
043A9F             0131*   @expA_Zero:
043A9F 29          0132*               add hl,hl
043AA0             0133*   @set_sigY_to_sigA:
043AA0 DD 2F 18    0134*               ld (ix+sigY),hl ; TODO: necessary?
043AA3             0135*   ;         shiftDist = 19 + expDiff;
043AA3 DD 7E 27    0136*               ld a,(ix+expDiff)
043AA6 C6 13       0137*               add a,19
043AA8             0138*               ; ld (ix+shiftDist),a
043AA8 C3 F3 3A 04 0139*               jp @calc_sig32Z
043AAC             0140*   ;     } else {
043AAC             0141*   @expDiff_positive:
043AAC             0142*   ;         uiZ = uiA;
043AAC             0143*   ;         if ( expA == 0x1F ) {
043AAC DD 7E 07    0144*               ld a,(ix+expA)
043AAF FE 1F       0145*               cp 0x1F ; check expA for inf
043AB1 20 10       0146*               JR nz,@expA_not_inf
043AB3             0147*   ;             if ( sigA ) goto propagateNaN;
043AB3 DD 27 03    0148*                   ld hl,(ix+sigA)
043AB6             0149*                   SIGN_HL ; test sigA for zero
                       M1 Args: none
043AB6 19          0001*M1     add hl,de
043AB7 B7          0002*M1     or a ; clear flags
043AB8 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043ABB C2 56 3B 04 0150*                   jp nz,@propagateNaN
043ABF             0151*   ;             goto uiZ;
043ABF DD 27 00    0152*                   ld hl,(ix+uiA)
043AC2 C9          0153*                   ret ; jp @uiZ
043AC3             0154*   ;         }
043AC3             0155*   @expA_not_inf:
043AC3             0156*   ;         if ( 13 <= expDiff ) {
043AC3 7A          0157*               ld a,d
043AC4 FE 0D       0158*               cp 13
043AC6 38 04       0159*               jr c,@expDiff_lt_13
043AC8             0160*   ;             if ( expB | sigB ) goto addEpsilon; // no need to do this
043AC8             0161*   ;             goto uiZ; // or this
043AC8 DD 27 00    0162*                   ld hl,(ix+uiA)
043ACB C9          0163*                   ret
043ACC             0164*   ;         }
043ACC             0165*   @expDiff_lt_13:
043ACC             0166*   ;         expZ = expA;
043ACC DD 7E 07    0167*               ld a,(ix+expA)
043ACF DD 77 25    0168*               ld (ix+expZ),a
043AD2             0169*   ;         sigX = sigA | 0x0400;
043AD2 DD 27 03    0170*               ld hl,(ix+sigA)
043AD5 CB D4       0171*               set 2,h ; set implicit 1
043AD7 DD 2F 12    0172*               ld (ix+sigX),hl ; store sigX
043ADA             0173*   ;         sigY = sigB + (expB ? 0x0400 : sigB);
043ADA DD 27 0C    0174*               ld hl,(ix+sigB)
043ADD DD 7E 10    0175*               ld a,(ix+expB)
043AE0 B7          0176*               or a
043AE1 28 04       0177*               jr z,@expB_Zero
043AE3 CB D4       0178*               set 2,h ; set implicit 1
043AE5 18 01       0179*               jr @set_sigY_to_sigB
043AE7             0180*   @expB_Zero:
043AE7 29          0181*               add hl,hl ; sigB + sigB
043AE8             0182*   @set_sigY_to_sigB:
043AE8 DD 2F 18    0183*               ld (ix+sigY),hl ; TODO: necessary?
043AEB             0184*   ;         shiftDist = 19 - expDiff;
043AEB 3E 13       0185*               ld a,19
043AED DD 96 27    0186*               sub (ix+expDiff)
043AF0 DD 77 28    0187*               ld (ix+shiftDist),a
043AF3             0188*   ;     }
043AF3             0189*   @calc_sig32Z: ; a needs to be shiftDist, hl needs to be sigY and sigX needs to be populated
043AF3             0190*   ;     sig32Z = ((uint_fast32_t) sigX<<19) + ((uint_fast32_t) sigY<<shiftDist);
043AF3 47          0191*           ld b,a ; b = shiftDist
043AF4 AF          0192*           xor a
043AF5 DD 27 18    0193*           ld hl,(ix+sigY) ; TODO: necessary?
043AF8             0194*   @sigY_shift: ; sigY<<shiftDist) -> auhl
043AF8 29          0195*           add hl,hl ; 1 cycle
043AF9 8F          0196*           adc a,a ; 1 cycle
043AFA 10 FC       0197*           djnz @sigY_shift ; 4 cycles
043AFC DD 2F 18    0198*           ld (ix+sigY),hl ; store low 3 bytes of sigY
043AFF EB          0199*           ex de,hl
043B00 DD 4E 1A    0200*           ld c,(ix+sigY+2) ; c = upper middle byte of sigY
043B03 47          0201*           ld b,a ; bcde is now sigY
043B04 DD 27 12    0202*           ld hl,(ix+sigX)
043B07 29          0203*           add hl,hl
043B08 29          0204*           add hl,hl
043B09 29          0205*           add hl,hl ; hl is now the upper word of sigX<<19
043B0A 09          0206*           add hl,bc ; hlde = sig32Z
043B0B             0207*   ;     if ( sig32Z < 0x40000000 ) {
043B0B 7C          0208*           ld a,h
043B0C FE 40       0209*           cp 0x40
043B0E D2 1B 3B 04 0210*           jp nc,@F
043B12             0211*   ;         --expZ;
043B12 DD 35 25    0212*               dec (ix+expZ)
043B15             0213*   ;         sig32Z <<= 1;
043B15 EB          0214*               ex de,hl
043B16 52 29       0215*               add.s hl,hl
043B18 EB          0216*               ex de,hl
043B19 ED 6A       0217*               adc hl,hl
043B1B             0218*   ;     }
043B1B             0219*   @@:
043B1B             0220*   ; get sign and exponent of result for return
043B1B DD 07 24    0221*           ld bc,(ix+signZ) ; b=expZ, c=signZ
043B1E             0222*   ;     sigZ = sig32Z>>16;
043B1E DD 2F 21    0223*           ld (ix+sigZ),hl
043B21             0224*   ;     if ( sig32Z & 0xFFFF ) {
043B21 EB          0225*           ex de,hl
043B22             0226*           SIGN_HL ; test low word of sig32Z for zero
                       M1 Args: none
043B22 19          0001*M1     add hl,de
043B23 B7          0002*M1     or a ; clear flags
043B24 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043B27 EB          0227*           ex de,hl
043B28 28 06       0228*           jr z,@F
043B2A             0229*   ;         sigZ |= 1;
043B2A CB C5       0230*               set 0,l ; set the LSB of sigZ
043B2C C3 66 3B 04 0231*               jp softfloat_roundPackToF16
043B30             0232*   ;     } else {
043B30             0233*   @@:
043B30             0234*   ;         if ( ! (sigZ & 0xF) && (expZ < 0x1E) ) {
043B30 7D          0235*               ld a,l
043B31 E6 0F       0236*               and 0x0F ; test round bits for non-zero
043B33 C2 66 3B 04 0237*               jp nz,softfloat_roundPackToF16
043B37 78          0238*               ld a,b ; expZ
043B38 FE 1E       0239*               cp 0x1E ; check expZ for 0x1E
043B3A D2 66 3B 04 0240*               jp nc,softfloat_roundPackToF16
043B3E             0241*   ;             sigZ >>= 4;
043B3E CB 3C       0242*                   srl h
043B40 CB 1D       0243*                   rr l
043B42 B7          0244*                   or a ; clear carry
043B43 CB 3C       0245*                   srl h
043B45 CB 1D       0246*                   rr l
043B47 B7          0247*                   or a ; clear carry
043B48 CB 3C       0248*                   srl h
043B4A CB 1D       0249*                   rr l
043B4C B7          0250*                   or a ; clear carry
043B4D CB 3C       0251*                   srl h
043B4F CB 1D       0252*                   rr l
043B51 B7          0253*                   or a ; clear carry
043B52             0254*   ;             goto pack;
043B52 C3 05 34 04 0255*                   jp packToF16UI
043B56             0256*   ;         }
043B56             0257*   ;     }
043B56             0258*   ; }
043B56             0259*   ; return softfloat_roundPackToF16( signZ, expZ, sigZ );
043B56             0260*   @propagateNaN:
043B56             0261*   ; uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
043B56             0262*   ; goto uiZ;
043B56 21 00 7E 00 0263*       ld hl,canonicalNaNF16
043B5A C9          0264*       ret
043B5B             0265*   @addEpsilon: ; since rounding mode is round to even, there's nothing to do here
043B5B             0266*   ; softfloat_exceptionFlags |= softfloat_flag_inexact;
043B5B             0267*   ; goto uiZ;
043B5B C9          0268*       ret ; jp @uiZ
043B5C             0269*   ; /*------------------------------------------------------------------------
043B5C             0270*   ; *------------------------------------------------------------------------*/
043B5C             0271*   @pack:
043B5C             0272*   ; uiZ = packToF16UI( signZ, expZ, sigZ );
043B5C             0273*   @uiZ: ; hl must be ready to return at this point
043B5C             0274*   ; uZ.ui = uiZ;
043B5C             0275*   ; return uZ.f;
043B5C C9          0276*       ret
043B5D             0277*   ; }
043B5D             0278*   ; end f16_add
043B5D             0056        include "../softfloat/s_normSubnormalF16Sig.inc"
043B5D             0001*   ; INLINE uint_fast8_t softfloat_countLeadingZeros16( uint16_t a )
043B5D             0002*   ;     { return a ? __builtin_clz( a ) - 16 : 16; }
043B5D             0003*   ; #define softfloat_countLeadingZeros16 softfloat_countLeadingZeros16
043B5D             0004*   
043B5D             0005*   ; struct exp8_sig16 softfloat_normSubnormalF16Sig( uint_fast16_t sig )
043B5D             0006*   ; {
043B5D             0007*   ;     int_fast8_t shiftDist;
043B5D             0008*   ;     struct exp8_sig16 z;
043B5D             0009*   
043B5D             0010*   ;     shiftDist = softfloat_countLeadingZeros16( sig ) - 5;
043B5D             0011*   ;     z.exp = 1 - shiftDist;
043B5D             0012*   ;     z.sig = sig<<shiftDist;
043B5D             0013*   ;     return z;
043B5D             0014*   
043B5D             0015*   ; }
043B5D             0016*   softfloat_normSubnormalF16Sig:
043B5D 06 01       0017*       ld b,1 ; set starting exponent
043B5F             0018*   @norm_loop:
043B5F 29          0019*       add hl,hl ; shift left
043B60 05          0020*       dec b ; decrement exponent
043B61 CB 54       0021*       bit 2,h ; test for carry into assumed 1 place
043B63 28 FA       0022*       jr z,@norm_loop
043B65 C9          0023*       ret
043B66             0024*   ; end softfloat_normSubnormalF16Sig
043B66             0057        include "../softfloat/s_roundPackToF16.inc"
043B66             0001*   
043B66             0002*   ; /*============================================================================
043B66             0003*   
043B66             0004*   ; This C source file is part of the SoftFloat IEEE Floating-Point Arithmetic
043B66             0005*   ; Package, Release 3e, by John R. Hauser.
043B66             0006*   
043B66             0007*   ; Copyright 2011, 2012, 2013, 2014, 2015, 2017 The Regents of the University of
043B66             0008*   ; California.  All rights reserved.
043B66             0009*   
043B66             0010*   ; Redistribution and use in source and binary forms, with or without
043B66             0011*   ; modification, are permitted provided that the following conditions are met:
043B66             0012*   
043B66             0013*   ;  1. Redistributions of source code must retain the above copyright notice,
043B66             0014*   ;     this list of conditions, and the following disclaimer.
043B66             0015*   
043B66             0016*   ;  2. Redistributions in binary form must reproduce the above copyright notice,
043B66             0017*   ;     this list of conditions, and the following disclaimer in the documentation
043B66             0018*   ;     and/or other materials provided with the distribution.
043B66             0019*   
043B66             0020*   ;  3. Neither the name of the University nor the names of its contributors may
043B66             0021*   ;     be used to endorse or promote products derived from this software without
043B66             0022*   ;     specific prior written permission.
043B66             0023*   
043B66             0024*   ; THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS", AND ANY
043B66             0025*   ; EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
043B66             0026*   ; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
043B66             0027*   ; DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
043B66             0028*   ; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
043B66             0029*   ; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
043B66             0030*   ; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
043B66             0031*   ; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
043B66             0032*   ; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
043B66             0033*   ; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
043B66             0034*   
043B66             0035*   ; =============================================================================*/
043B66             0036*   
043B66             0037*   ; ===============================================================================
043B66             0038*   ; eZ80 Assembly Implementation
043B66             0039*   ; Original C code has been simplified so that only the default rounding options
043B66             0040*   ; are used, and so branching tests are more ez80 friendly.
043B66             0041*   ; ===============================================================================
043B66             0042*   ; inputs: c = sign (0=pos, 0x80=neg), b = biased exp,
043B66             0043*   ;         hl = sig (implied 1 place in bit 14, rounding bits in bits 0-3)
043B66             0044*   ; outputs: hl = packed float16, c = sign (0=pos, 0x80=neg), b = biased exp
043B66             0045*   ; destroys: af, de
043B66             0046*   softfloat_roundPackToF16:
043B66             0047*   ; uint_fast8_t roundIncrement = 0x8;
043B66             0048*   ; uint_fast8_t roundBits = sig & 0xF;
043B66             0049*   ; if (exp < 0) {
043B66 78          0050*       ld a,b ; get exponent
043B67 FE 00       0051*       cp 0
043B69 F2 86 3B 04 0052*       jp p,@check_overflow
043B6D             0053*   ;     // -----------------------------
043B6D             0054*   ;     // Subnormal / Underflow path
043B6D             0055*   ;     // -----------------------------
043B6D             0056*   ;     bool isTiny = (
043B6D             0057*   ;         softfloat_detectTininess == softfloat_tininess_beforeRounding ||
043B6D             0058*   ;         exp < -1 ||
043B6D             0059*   ;         sig + roundIncrement < 0x8000
043B6D             0060*   ;     );
043B6D             0061*   ;     sig = softfloat_shiftRightJam32(sig, -exp);
043B6D ED 44       0062*           neg ; negate exponent
043B6F EB          0063*           ex de,hl ; move hl to lower bytes of the 32 bit argument
043B70 21 00 00 00 0064*           ld hl,0 ; upper bytes of 32 bit argument to zero
043B74 CD E4 3B 04 0065*           call softfloat_shiftRightJam32
043B78 EB          0066*           ex de,hl ; shifted/jammed sig back to hl
043B79             0067*   ;     exp = 0;
043B79 06 00       0068*           ld b,0
043B7B             0069*   ;     roundBits = sig & 0xF;
043B7B 3E 0F       0070*           ld a,0x0F
043B7D A5          0071*           and l
043B7E 57          0072*           ld d,a ; store roundBits
043B7F             0073*   ;     if (isTiny && roundBits) {
043B7F 28 16       0074*           jr z,@do_rounding ; skip if roundBits is zero
043B81 A0          0075*           and a,b ; check exponent for 0 (tiny)
043B82 28 13       0076*           jr z,@do_rounding ; skip if exponent is zero
043B84             0077*   ;         softfloat_raiseFlags(softfloat_flag_underflow);
043B84             0078*   ;     }
043B84 18 11       0079*           jr @do_rounding
043B86             0080*   ; }
043B86             0081*   @check_overflow:
043B86             0082*       ; } else if ( (0x1D < exp) || (0x8000 <= sig + roundIncrement) ) {
043B86             0083*       ;     softfloat_raiseFlags(
043B86             0084*       ;         softfloat_flag_overflow | softfloat_flag_inexact );
043B86             0085*       ;     uiZ = packToF16UI( sign, 0x1F, 0 ) - ! roundIncrement;
043B86 FE 1E       0086*           cp 0x1E
043B88 30 50       0087*           jr nc,@return_inf ; return inf if exp < 0x1D
043B8A 20 0B       0088*           jr nz,@do_rounding ; skip if exp != 0x1E (meaning we can round up without going to inf)
043B8C EB          0089*           ex de,hl ; preserve sig in de for upcoming test
043B8D 21 F7 7F 00 0090*           ld hl,0x8000 - 0x0008 - 1 ; 0x8000 - roundIncrement = 0x7FF7
043B91 B7          0091*           or a ; clear carry
043B92 ED 52       0092*           sbc hl, de           ; HL = 0x7FF7 - DE
043B94 EB          0093*           ex de, hl
043B95 38 43       0094*           jr c, @return_inf    ; if sig > 0x7FF7, overflow
043B97             0095*   ; }
043B97             0096*   @do_rounding:
043B97             0097*   ; roundBits = sig & 0xF
043B97 3E 0F       0098*       ld a,0x0F
043B99 A5          0099*       and l
043B9A 57          0100*       ld d,a ; store roundBits
043B9B             0101*   ; sig = (sig + roundIncrement) >> 4;
043B9B             0102*   ; add round increment
043B9B 7D          0103*       ld a,l
043B9C C6 08       0104*       add 0x08
043B9E 6F          0105*       ld l,a
043B9F 7C          0106*       ld a,h
043BA0 CE 00       0107*       adc a,0
043BA2 67          0108*       ld h,a
043BA3             0109*   ; shift right by 4 bits
043BA3             0110*   ; once
043BA3 B7          0111*       or a ; clear carry
043BA4 CB 1C       0112*       rr h
043BA6 CB 1D       0113*       rr l
043BA8             0114*   ; twice
043BA8 B7          0115*       or a
043BA9 CB 1C       0116*       rr h
043BAB CB 1D       0117*       rr l
043BAD B7          0118*       or a
043BAE             0119*   ; thrice
043BAE B7          0120*       or a
043BAF CB 1C       0121*       rr h
043BB1 CB 1D       0122*       rr l
043BB3             0123*   ; four times
043BB3 B7          0124*       or a
043BB4 CB 1C       0125*       rr h
043BB6 CB 1D       0126*       rr l
043BB8             0127*   ; if (roundBits) {
043BB8             0128*   ;     softfloat_exceptionFlags |= softfloat_flag_inexact;
043BB8             0129*   ; }
043BB8             0130*       ; d == roundBits
043BB8 7A          0131*       ld a,d
043BB9 FE 08       0132*       cp 0x08
043BBB C2 CB 3B 04 0133*       jp nz,@check_sig_zero      ; Not exactly halfway -> skip
043BBF             0134*       ; Exactly halfway => round to even.
043BBF CB 45       0135*       bit 0,l                    ; Test LSB of HL
043BC1 CA CB 3B 04 0136*       jp z,@check_sig_zero       ; If LSB = 0 (already even), skip
043BC5 CB 85       0137*       res 0,l                    ; Else clear LSB => rounding to even
043BC7 C3 05 34 04 0138*       jp packToF16UI
043BCB             0139*   ; if (!sig) {
043BCB             0140*   @check_sig_zero:
043BCB             0141*       SIGN_HL
                       M1 Args: none
043BCB 19          0001*M1     add hl,de
043BCC B7          0002*M1     or a ; clear flags
043BCD 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043BD0 C2 05 34 04 0142*       jp nz,packToF16UI ; skip if sig is not zero
043BD4             0143*   ;     exp = 0;
043BD4 06 00       0144*           ld b,0
043BD6             0145*   ; }
043BD6             0146*   ; return packToF16UI(sign, exp, sig);
043BD6 C3 05 34 04 0147*       jp packToF16UI
043BDA             0148*   @return_inf:
043BDA             0149*   ; // -----------------------------
043BDA             0150*   ; // Overflow after rounding
043BDA             0151*   ; // -----------------------------
043BDA             0152*   ; softfloat_raiseFlags(softfloat_flag_overflow | softfloat_flag_inexact);
043BDA             0153*   ; return packToF16UI(sign, 0x1F, 0) - !roundIncrement;
043BDA 21 00 7C 00 0154*       ld hl,0x7C00
043BDE 79          0155*       ld a,c ; get sign
043BDF B4          0156*       or h
043BE0 67          0157*       ld h,a
043BE1 06 1F       0158*       ld b,0x1F ; exponent
043BE3 C9          0159*       ret
043BE4             0160*   ; end softfloat_roundPackToF16
043BE4             0058        include "../softfloat/s_shiftRightJam32.inc"
043BE4             0001*   ; /*----------------------------------------------------------------------------
043BE4             0002*   ; | Shifts 'a' right by the number of bits given in 'dist', which must not
043BE4             0003*   ; | be zero.  If any nonzero bits are shifted off, they are "jammed" into the
043BE4             0004*   ; | least-significant bit of the shifted value by setting the least-significant
043BE4             0005*   ; | bit to 1.  This shifted-and-jammed value is returned.
043BE4             0006*   ; |   The value of 'dist' can be arbitrarily large.  In particular, if 'dist' is
043BE4             0007*   ; | greater than 32, the result will be either 0 or 1, depending on whether 'a'
043BE4             0008*   ; | is zero or nonzero.
043BE4             0009*   ; *----------------------------------------------------------------------------*/
043BE4             0010*   ;
043BE4             0011*   ; uint32_t softfloat_shiftRightJam32( uint32_t a, uint_fast16_t dist )
043BE4             0012*   ; {
043BE4             0013*   
043BE4             0014*   ;     return
043BE4             0015*   ;         (dist < 31) ? a>>dist | ((uint32_t) (a<<(-dist & 31)) != 0) : (a != 0);
043BE4             0016*   
043BE4             0017*   ; }
043BE4             0018*   ;
043BE4             0019*   ; Inputs: HLDE = 32-bit unsigned integer to shift (most to least significant byte)
043BE4             0020*   ;          A = number of bits to shift right (0255, only 031 meaningful)
043BE4             0021*   ;
043BE4             0022*   ; Outputs: HLDE = shifted result, with LSB jammed (bit 0 set) if any 1s were shifted out
043BE4             0023*   ;          A = jam bit (0 or 1)
043BE4             0024*   
043BE4             0025*   softfloat_shiftRightJam32:
043BE4             0026*       ; call dumpRegistersHex
043BE4             0027*   
043BE4 C5          0028*       push bc ; preserve b
043BE5 47          0029*       ld b,a ; loop counter
043BE6 AF          0030*       xor a ; zero jam bits and clear carry
043BE7             0031*   @shift_loop:
043BE7 CB 1C       0032*       rr h
043BE9 CB 1D       0033*       rr l
043BEB CB 1A       0034*       rr d
043BED CB 1B       0035*       rr e
043BEF CE 00       0036*       adc a,0 ; jam bit
043BF1 B7          0037*       or a ; clear carry
043BF2 10 F3       0038*       djnz @shift_loop
043BF4 B7          0039*       or a ; check whether to set jam bit
043BF5 28 02       0040*       jr z, @done ; no jam bit set
043BF7 CB C3       0041*       set 0,e ; set jam bit to LSB
043BF9             0042*   @done:
043BF9 C1          0043*       pop bc ; restore b
043BFA C9          0044*       ret
043BFB             0045*   ; end softfloat_shiftRightJam32
043BFB             0059        include "../softfloat/s_subMagsF16.inc"
043BFB             0001*   softfloat_subMagsF16:
043BFB DD 2F 00    0002*       ld (ix+uiA),hl ; store uiA
043BFE DD 1F 09    0003*       ld (ix+uiB),de ; store uiB
043C01             0004*   ; /*------------------------------------------------------------------------
043C01             0005*   ; *------------------------------------------------------------------------*/
043C01             0006*   ; expA = expF16UI( uiA );
043C01             0007*       expF16UI
                       M1 Args: none
043C01 7C          0001*M1         ld a,h
043C02 0F          0002*M1         rrca
043C03 0F          0003*M1         rrca
043C04 E6 1F       0004*M1         and %00011111
043C06 47          0005*M1         ld b,a
043C07             0008*       signF16UI
                       M1 Args: none
043C07 7C          0001*M1         ld a,h
043C08 E6 80       0002*M1         and %10000000
043C0A 4F          0003*M1         ld c,a
043C0B DD 0F 06    0009*       ld (ix+signA),bc ; implicitly stores expA
043C0E             0010*   ; sigA = fracF16UI( uiA );
043C0E             0011*       fracF16UI
                       M1 Args: none
043C0E 7C          0001*M1         ld a,h
043C0F E6 03       0002*M1         and %00000011
043C11 67          0003*M1         ld h,a
043C12 DD 2F 03    0012*       ld (ix+sigA),hl
043C15             0013*   ; expB = expF16UI( uiB );
043C15 EB          0014*       ex de,hl ; flip operands
043C16             0015*       expF16UI
                       M1 Args: none
043C16 7C          0001*M1         ld a,h
043C17 0F          0002*M1         rrca
043C18 0F          0003*M1         rrca
043C19 E6 1F       0004*M1         and %00011111
043C1B 47          0005*M1         ld b,a
043C1C             0016*       signF16UI
                       M1 Args: none
043C1C 7C          0001*M1         ld a,h
043C1D E6 80       0002*M1         and %10000000
043C1F 4F          0003*M1         ld c,a
043C20 DD 0F 0F    0017*       ld (ix+signB),bc ; implicitly stores expB
043C23             0018*   ; sigB = fracF16UI( uiB );
043C23             0019*       fracF16UI
                       M1 Args: none
043C23 7C          0001*M1         ld a,h
043C24 E6 03       0002*M1         and %00000011
043C26 67          0003*M1         ld h,a
043C27 DD 2F 0C    0020*       ld (ix+sigB),hl
043C2A             0021*   ; /*------------------------------------------------------------------------
043C2A             0022*   ; *------------------------------------------------------------------------*/
043C2A             0023*   ; expDiff = expA - expB;
043C2A DD 7E 07    0024*       ld a,(ix+expA)
043C2D 90          0025*       sub b
043C2E DD 77 27    0026*       ld (ix+expDiff),a ; store expDiff
043C31             0027*   ; if ( ! expDiff ) {
043C31 C2 9C 3C 04 0028*       jp nz,@expDiff_not_zero
043C35             0029*   ;     /*--------------------------------------------------------------------
043C35             0030*   ;     *--------------------------------------------------------------------*/
043C35             0031*   ;     if ( expA == 0x1F ) {
043C35 80          0032*           add a,b
043C36 FE 1F       0033*           cp 0x1F ; check expA for inf
043C38 C2 41 3C 04 0034*           jp nz,@expA_not_infA
043C3C             0035*   ;         if ( sigA | sigB ) goto propagateNaN;
043C3C             0036*   ;         softfloat_raiseFlags( softfloat_flag_invalid );
043C3C             0037*   ;         uiZ = defaultNaNF16UI;
043C3C             0038*   ;         goto uiZ;
043C3C 21 00 7E 00 0039*               ld hl,canonicalNaNF16
043C40 C9          0040*               ret
043C41             0041*   ;     }
043C41             0042*   @expA_not_infA:
043C41             0043*   ;     sigDiff = sigA - sigB;
043C41 EB          0044*           ex de,hl ; de = sigB
043C42 DD 27 03    0045*           ld hl,(ix+sigA) ; hl = sigA
043C45 B7          0046*           or a ; clear carry
043C46 ED 52       0047*           sbc hl,de ; sigDiff = sigA - sigB
043C48             0048*   ;     if ( ! sigDiff ) {
043C48 C2 51 3C 04 0049*           jp nz,@sigDiff_not_zero
043C4C             0050*   ;         uiZ = packToF16UI((softfloat_roundingMode == softfloat_round_min), 0, 0 );
043C4C             0051*   ;         goto uiZ;
043C4C 21 00 00 00 0052*               ld hl,0
043C50 C9          0053*               ret
043C51             0054*   ;     }
043C51             0055*   @sigDiff_not_zero:
043C51             0056*   ;     if ( expA ) --expA;
043C51 DD 7E 07    0057*           ld a,(ix+expA)
043C54 B7          0058*           or a ; check expA for zero
043C55 CA 5C 3C 04 0059*           jp z,@F
043C59 DD 35 07    0060*           dec (ix+expA)
043C5C             0061*   @@:
043C5C             0062*   ;     signZ = signF16UI( uiA );
043C5C DD 7E 06    0063*           ld a,(ix+signA)
043C5F             0064*   ;     if ( sigDiff < 0 ) {
043C5F             0065*           SIGN_HL
                       M1 Args: none
043C5F 19          0001*M1     add hl,de
043C60 B7          0002*M1     or a ; clear flags
043C61 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043C64 F2 74 3C 04 0066*           jp p,@F
043C68             0067*   ;         signZ = ! signZ;
043C68 EE 80       0068*               xor %10000000
043C6A DD 77 24    0069*               ld (ix+signZ),a
043C6D             0070*   ;         sigDiff = -sigDiff;
043C6D EB          0071*               ex de,hl
043C6E 21 00 00 00 0072*               ld hl,0
043C72 ED 52       0073*               sbc hl,de ; sigDiff = -sigDiff
043C74             0074*   ;     }
043C74             0075*   @@:
043C74 DD 77 24    0076*           ld (ix+signZ),a
043C77 DD 2F 29    0077*           ld (ix+sigDiff),hl
043C7A             0078*   ;     shiftDist = softfloat_countLeadingZeros16( sigDiff ) - 5;
043C7A AF          0079*           xor a ; zero shiftDist
043C7B             0080*   @shiftDist_loop:
043C7B CB 54       0081*           bit 2,h ; test for carry into assumed 1 place
043C7D C2 87 3C 04 0082*           jp nz,@shiftDist_done
043C81 29          0083*           add hl,hl ; shift left
043C82 3C          0084*           inc a ; increment shiftDist
043C83 C3 7B 3C 04 0085*           jp @shiftDist_loop
043C87             0086*   @shiftDist_done:
043C87             0087*   ;     expZ = expA - shiftDist;
043C87 ED 44       0088*           neg
043C89 DD 86 07    0089*           add a,(ix+expA)
043C8C             0090*   ;     if ( expZ < 0 ) {
043C8C F2 94 3C 04 0091*           jp p,@F
043C90             0092*   ;         shiftDist = expA;
043C90             0093*   ;         expZ = 0;
043C90 AF          0094*               xor a ; zero expZ
043C91 DD 27 29    0095*               ld hl,(ix+sigDiff) ; pre-shifted sigDiff
043C94             0096*   ;     }
043C94             0097*   @@:
043C94 47          0098*           ld b,a ; b = expZ
043C95 DD 4E 24    0099*           ld c,(ix+signZ) ; c = signZ
043C98             0100*   ;     sigZ = sigDiff<<shiftDist; // already did this when we counted leading zeros
043C98             0101*   ;     goto pack;
043C98 C3 05 34 04 0102*           jp packToF16UI
043C9C             0103*   ; } else {
043C9C             0104*   @expDiff_not_zero:
043C9C             0105*   ;     /*--------------------------------------------------------------------
043C9C             0106*   ;     *--------------------------------------------------------------------*/
043C9C             0107*   ;     signZ = signF16UI( uiA );
043C9C DD 7E 06    0108*           ld a,(ix+signA)
043C9F DD 77 24    0109*           ld (ix+signZ),a ; store signZ
043CA2             0110*   ;     if ( expDiff < 0 ) {
043CA2 F2 10 3D 04 0111*           jp p,@expDiff_positive
043CA6             0112*   ;         /*----------------------------------------------------------------
043CA6             0113*   ;         *----------------------------------------------------------------*/
043CA6             0114*   ;         signZ = ! signZ;
043CA6 EE 80       0115*               xor %10000000
043CA8 DD 77 24    0116*               ld (ix+signZ),a ; store signZ
043CAB 4F          0117*               ld c,a ; c = signZ
043CAC             0118*   ;         if ( expB == 0x1F ) {
043CAC DD 7E 10    0119*               ld a,(ix+expB)
043CAF FE 1F       0120*               cp 0x1F ; check expB for inf
043CB1 C2 CE 3C 04 0121*               jp nz,@expB_not_infB
043CB5             0122*   ;             if ( sigB ) goto propagateNaN;
043CB5 DD 27 0C    0123*                   ld hl,(ix+sigB)
043CB8             0124*                   SIGN_HL ; test sigB for zero
                       M1 Args: none
043CB8 19          0001*M1     add hl,de
043CB9 B7          0002*M1     or a ; clear flags
043CBA 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043CBD CA C6 3C 04 0125*                   jp z,@F
043CC1 21 00 7E 00 0126*                   ld hl,canonicalNaNF16
043CC5 C9          0127*                   ret
043CC6             0128*   @@:
043CC6             0129*   ;             uiZ = packToF16UI( signZ, 0x1F, 0 );
043CC6 21 00 7C 00 0130*                   ld hl,0x7C00 ; +inf
043CCA 79          0131*                   ld a,c ; signZ
043CCB B4          0132*                   or h ; reapply sign
043CCC 67          0133*                   ld h,a
043CCD             0134*   ;             goto uiZ;
043CCD C9          0135*                   ret
043CCE             0136*   ;         }
043CCE             0137*   @expB_not_infB:
043CCE             0138*   ;         if ( expDiff <= -13 ) {
043CCE DD 56 27    0139*               ld d,(ix+expDiff)
043CD1 3E F3       0140*               ld a,-13
043CD3 BA          0141*               cp d
043CD4 DA DF 3C 04 0142*               jp c,@expDiff_gt_neg13
043CD8             0143*   ;             uiZ = packToF16UI( signZ, expB, sigB );
043CD8             0144*   ;             if ( expA | sigA ) goto subEpsilon;
043CD8             0145*   ;             goto uiZ;
043CD8 DD 27 09    0146*                   ld hl,(ix+uiB)
043CDB 79          0147*                   ld a,c ; signZ
043CDC B4          0148*                   or h ; reapply sign
043CDD 67          0149*                   ld h,a
043CDE C9          0150*                   ret
043CDF             0151*   ;         }
043CDF             0152*   @expDiff_gt_neg13:
043CDF             0153*   ;         expZ = expA + 19;
043CDF DD 7E 07    0154*               ld a,(ix+expA)
043CE2 C6 13       0155*               add a,19
043CE4 DD 77 25    0156*               ld (ix+expZ),a
043CE7             0157*   ;         sigX = sigB | 0x0400;
043CE7 DD 27 0C    0158*               ld hl,(ix+sigB)
043CEA CB D4       0159*               set 2,h ; set implicit 1
043CEC DD 2F 12    0160*               ld (ix+sigX),hl ; store sigX
043CEF             0161*   ;         sigY = sigA + (expA ? 0x0400 : sigA);
043CEF DD 27 03    0162*               ld hl,(ix+sigA)
043CF2 DD 7E 07    0163*               ld a,(ix+expA)
043CF5 B7          0164*               or a
043CF6 CA 00 3D 04 0165*               jp z,@expA_Zero
043CFA CB D4       0166*               set 2,h ; set implicit 1
043CFC C3 01 3D 04 0167*               jp @set_sigY_to_sigA
043D00             0168*   @expA_Zero:
043D00 29          0169*               add hl,hl
043D01             0170*   @set_sigY_to_sigA:
043D01 DD 2F 18    0171*               ld (ix+sigY),hl ; store sigY
043D04             0172*   ;         expDiff = -expDiff;
043D04 DD 7E 27    0173*               ld a,(ix+expDiff)
043D07 ED 44       0174*               neg
043D09 DD 77 27    0175*               ld (ix+expDiff),a
043D0C C3 60 3D 04 0176*               jp @calc_sig32Z
043D10             0177*   ;     } else {
043D10             0178*   @expDiff_positive:
043D10             0179*   ;         /*----------------------------------------------------------------
043D10             0180*   ;         *----------------------------------------------------------------*/
043D10             0181*   ;         uiZ = uiA; // we do this below
043D10             0182*   ;         if ( expA == 0x1F ) {
043D10 DD 7E 07    0183*               ld a,(ix+expA)
043D13 FE 1F       0184*               cp 0x1F ; check expA for inf
043D15 C2 2E 3D 04 0185*               jp nz,@expA_not_infB
043D19             0186*   ;             if ( sigA ) goto propagateNaN;
043D19 DD 27 03    0187*                   ld hl,(ix+sigA)
043D1C             0188*                   SIGN_HL ; test sigA for zero
                       M1 Args: none
043D1C 19          0001*M1     add hl,de
043D1D B7          0002*M1     or a ; clear flags
043D1E 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043D21 CA 2A 3D 04 0189*                   jp z,@F
043D25 21 00 7E 00 0190*                   ld hl,canonicalNaNF16
043D29 C9          0191*                   ret
043D2A             0192*   @@:
043D2A             0193*   ;             goto uiZ;
043D2A DD 27 00    0194*                   ld hl,(ix+uiA) ; uiZ = uiA
043D2D C9          0195*                   ret
043D2E             0196*   ;         }
043D2E             0197*   @expA_not_infB:
043D2E             0198*   ;         if ( 13 <= expDiff ) {
043D2E DD 7E 27    0199*               ld a,(ix+expDiff)
043D31 FE 0D       0200*               cp 13
043D33 DA 3B 3D 04 0201*               jp c,@expDiff_lt_13
043D37             0202*   ;             if ( expB | sigB ) goto subEpsilon; // no need to do this
043D37             0203*   ;             goto uiZ;
043D37 DD 27 00    0204*                   ld hl,(ix+uiA) ; uiZ = uiA
043D3A C9          0205*                   ret
043D3B             0206*   ;         }
043D3B             0207*   @expDiff_lt_13:
043D3B             0208*   ;         expZ = expB + 19;
043D3B DD 7E 10    0209*               ld a,(ix+expB)
043D3E C6 13       0210*               add a,19
043D40 DD 77 25    0211*               ld (ix+expZ),a
043D43             0212*   ;         sigX = sigA | 0x0400;
043D43 DD 27 03    0213*               ld hl,(ix+sigA)
043D46 CB D4       0214*               set 2,h ; set implicit 1
043D48 DD 2F 12    0215*               ld (ix+sigX),hl ; store sigX
043D4B             0216*   ;         sigY = sigB + (expB ? 0x0400 : sigB);
043D4B DD 27 0C    0217*               ld hl,(ix+sigB)
043D4E DD 7E 10    0218*               ld a,(ix+expB)
043D51 B7          0219*               or a
043D52 CA 5C 3D 04 0220*               jp z,@expB_Zero
043D56 CB D4       0221*               set 2,h ; set implicit 1
043D58 C3 5D 3D 04 0222*               jp @set_sigY_to_sigB
043D5C             0223*   @expB_Zero:
043D5C 29          0224*               add hl,hl ; sigB + sigB
043D5D             0225*   @set_sigY_to_sigB:
043D5D DD 2F 18    0226*               ld (ix+sigY),hl
043D60             0227*   ;     }
043D60             0228*   @calc_sig32Z:
043D60             0229*   ;     sig32Z = ((uint_fast32_t) sigX<<expDiff) - sigY;
043D60 DD 46 27    0230*           ld b,(ix+expDiff)
043D63 AF          0231*           xor a ; clear a
043D64 DD 27 12    0232*           ld hl,(ix+sigX)
043D67             0233*   @sigX_shift:
043D67 29          0234*           add hl,hl
043D68 8F          0235*           adc a,a
043D69 10 FC       0236*           djnz @sigX_shift
043D6B             0237*   
043D6B DD 2F 12    0238*           ld (ix+sigX),hl ; store low 3 bytes of sigX
043D6E DD 5E 14    0239*           ld e,(ix+sigX+2) ; e = upper middle byte of sigX
043D71 57          0240*           ld d,a ; dehl is now sigX
043D72 DD 07 18    0241*           ld bc,(ix+sigY)
043D75             0242*       ;   dehl
043D75             0243*       ; - 00bc
043D75             0244*       ; = hlbc
043D75 B7          0245*           or a ; clear carry
043D76 52 ED 42    0246*           sbc.s hl,bc ; .s to force 16-bit subtraction
043D79 4D          0247*           ld c,l
043D7A 44          0248*           ld b,h
043D7B             0249*   
043D7B EB          0250*           ex de,hl
043D7C 11 00 00 00 0251*           ld de,0
043D80             0252*   
043D80 52 ED 52    0253*           sbc.s hl,de
043D83 59          0254*           ld e,c
043D84 50          0255*           ld d,b ; hlde = sigX<<expDiff - sigY
043D85             0256*   ;     shiftDist = softfloat_countLeadingZeros32( sig32Z ) - 1;
043D85 AF          0257*           xor a ; zero shiftDist
043D86             0258*   @shiftDist_loop32:
043D86 CB 74       0259*           bit 6,h
043D88 C2 97 3D 04 0260*           jp nz,@shiftDist_done32
043D8C EB          0261*           ex de,hl
043D8D 52 29       0262*           add.s hl,hl
043D8F EB          0263*           ex de,hl
043D90 ED 6A       0264*           adc hl,hl
043D92 3C          0265*           inc a ; increment shiftDist
043D93 C3 86 3D 04 0266*           jp @shiftDist_loop32
043D97             0267*   @shiftDist_done32:
043D97             0268*   ;     sig32Z <<= shiftDist; // already did this when we counted leading zeros
043D97             0269*   ;     expZ -= shiftDist;
043D97 DD 96 25    0270*           sub (ix+expZ)
043D9A ED 44       0271*           neg
043D9C 47          0272*           ld b,a ; b = expZ
043D9D DD 4E 24    0273*           ld c,(ix+signZ) ; c = signZ
043DA0             0274*   ;     sigZ = sig32Z>>16; // is already in hl
043DA0             0275*   ;     if ( sig32Z & 0xFFFF ) {
043DA0 EB          0276*           ex de,hl
043DA1             0277*           SIGN_HL ; test low word of sig32Z for zero
                       M1 Args: none
043DA1 19          0001*M1     add hl,de
043DA2 B7          0002*M1     or a ; clear flags
043DA3 52 ED 52    0003*M1     sbc.s hl,de ; 16-bit subtract so bit 7 of H is the sign. ***clears hlu***
043DA6 EB          0278*           ex de,hl
043DA7 CA B1 3D 04 0279*           jp z,@F
043DAB             0280*   ;         sigZ |= 1;
043DAB CB C5       0281*               set 0,l ; set the LSB of sigZ
043DAD C3 66 3B 04 0282*               jp softfloat_roundPackToF16
043DB1             0283*   ;     } else {
043DB1             0284*   @@:
043DB1             0285*   ;         if ( ! (sigZ & 0xF) && ((unsigned int) expZ < 0x1E) ) {
043DB1 7D          0286*               ld a,l
043DB2 E6 0F       0287*               and 0x0F ; test round bits for non-zero
043DB4 C2 66 3B 04 0288*               jp nz,softfloat_roundPackToF16
043DB8 78          0289*               ld a,b ; expZ
043DB9 FE 1E       0290*               cp 0x1E ; check expZ for 0x1E
043DBB D2 66 3B 04 0291*               jp nc,softfloat_roundPackToF16
043DBF             0292*   ;             sigZ >>= 4;
043DBF CB 3C       0293*                   srl h
043DC1 CB 1D       0294*                   rr l
043DC3 B7          0295*                   or a ; clear carry
043DC4 CB 3C       0296*                   srl h
043DC6 CB 1D       0297*                   rr l
043DC8 B7          0298*                   or a ; clear carry
043DC9 CB 3C       0299*                   srl h
043DCB CB 1D       0300*                   rr l
043DCD B7          0301*                   or a ; clear carry
043DCE CB 3C       0302*                   srl h
043DD0 CB 1D       0303*                   rr l
043DD2 B7          0304*                   or a ; clear carry
043DD3             0305*   ;             goto pack;
043DD3 DD 4E 24    0306*                   ld c,(ix+signZ) ; c = signZ
043DD6 C3 05 34 04 0307*                   jp packToF16UI
043DDA             0308*   ;         }
043DDA             0309*   ;     }
043DDA             0310*   ;     return softfloat_roundPackToF16( signZ, expZ, sigZ );
043DDA             0311*   ; }
043DDA             0312*   ; /*------------------------------------------------------------------------
043DDA             0313*   ; *------------------------------------------------------------------------*/
043DDA             0314*   ; propagateNaN:
043DDA             0315*   ; uiZ = softfloat_propagateNaNF16UI( uiA, uiB );
043DDA             0316*   ; goto uiZ;
043DDA             0317*   ; /*------------------------------------------------------------------------
043DDA             0318*   ; *------------------------------------------------------------------------*/
043DDA             0319*   ; subEpsilon:
043DDA             0320*   ; roundingMode = softfloat_roundingMode;
043DDA             0321*   ; if ( roundingMode != softfloat_round_near_even ) {
043DDA             0322*   ;     if (
043DDA             0323*   ;         (roundingMode == softfloat_round_minMag)
043DDA             0324*   ;             || (roundingMode
043DDA             0325*   ;                     == (signF16UI( uiZ ) ? softfloat_round_max
043DDA             0326*   ;                             : softfloat_round_min))
043DDA             0327*   ;     ) {
043DDA             0328*   ;         --uiZ;
043DDA             0329*   ;     }
043DDA             0330*   ; #ifdef SOFTFLOAT_ROUND_ODD
043DDA             0331*   ;     else if ( roundingMode == softfloat_round_odd ) {
043DDA             0332*   ;         uiZ = (uiZ - 1) | 1;
043DDA             0333*   ;     }
043DDA             0334*   ; #endif
043DDA             0335*   ; }
043DDA             0336*   ; softfloat_exceptionFlags |= softfloat_flag_inexact;
043DDA             0337*   ; goto uiZ;
043DDA             0338*   ; /*------------------------------------------------------------------------
043DDA             0339*   ; *------------------------------------------------------------------------*/
043DDA             0340*   ; pack:
043DDA             0341*   ; uiZ = packToF16UI( signZ, expZ, sigZ );
043DDA             0342*   ; uiZ:
043DDA             0343*   ; uZ.ui = uiZ;
043DDA             0344*   ; return uZ.f;
043DDA             0345*   
043DDA             0346*   ; }
043DDA             0347*   
043DDA             0348*   
043DDA C9          0349*   ret
043DDB             0060    
043DDB             0061        include "f16_test_add.inc"
043DDB             0001*   test_f16_add:
043DDB             0002*   ; copy test filename
043DDB 21 6C 3E 04 0003*       ld hl,@test_filename
043DDF 11 00 45 04 0004*       ld de,test_filename
043DE3 CD 50 44 04 0005*       call test_copy_filename
043DE7             0006*   
043DE7             0007*   ; do the test
043DE7 CD E5 20 04 0008*       call printInline
043DEB 0D 0A 66 31 0009*       asciz "\r\nf16_add test\r\n"
       36 5F 61 64 
       64 20 74 65 
       73 74 0D 0A 
       00          
043DFC 21 08 00 00 0010*       ld hl,8
043E00 22 C0 42 04 0011*       ld (bytes_per_record),hl
043E04 21 00 71 02 0012*       ld hl,160000
043E08 22 BD 42 04 0013*       ld (bytes_read_max),hl
043E0C CD C3 42 04 0014*       call test_init ; open files for reading and writing
043E10 C8          0015*       ret z ; error opening files
043E11             0016*   @read_loop:
043E11 CD 46 43 04 0017*       call test_read_data
043E15 28 51       0018*       jr z,@read_end
043E17 FD 21 00 46 0019*       ld iy,filedata
       04          
043E1C             0020*   @calc_loop:
043E1C             0021*   ; perform operation
043E1C FD 27 00    0022*       ld hl,(iy+0) ; op1
043E1F FD 17 02    0023*       ld de,(iy+2) ; op2
043E22 CD 8C 34 04 0024*       call f16_add
043E26             0025*   ; write results to file buffer
043E26 FD 75 06    0026*       ld (iy+6),l ; assembly result low byte
043E29 FD 74 07    0027*       ld (iy+7),h ; assembly result high byte
043E2C             0028*   ; check for error
043E2C FD 5E 04    0029*       ld e,(iy+4) ; python result low byte
043E2F FD 56 05    0030*       ld d,(iy+5) ; python result high byte
043E32 B7          0031*       or a ; clear carry
043E33 52 ED 52    0032*       sbc.s hl,de
043E36 28 09       0033*       jr z,@next_record
043E38             0034*   ; bump error count
043E38 2A AE 42 04 0035*       ld hl,(errors)
043E3C 23          0036*       inc hl
043E3D 22 AE 42 04 0037*       ld (errors),hl
043E41             0038*   @next_record:
043E41             0039*   ; write results to file buffer
043E41 ED 5B C0 42 0040*       ld de,(bytes_per_record)
       04          
043E46 FD 19       0041*       add iy,de; bump data pointer
043E48 2A B1 42 04 0042*       ld hl,(records)
043E4C 23          0043*       inc hl
043E4D 22 B1 42 04 0044*       ld (records),hl
043E51 2A B4 42 04 0045*       ld hl,(counter)
043E55 2B          0046*       dec hl
043E56 22 B4 42 04 0047*       ld (counter),hl
043E5A             0048*       SIGN_UHL
                       M1 Args: none
043E5A 19          0001*M1     add hl,de ; 1 cycle
043E5B B7          0002*M1     or a ; clear flags ; 1 cycle
043E5C ED 52       0003*M1     sbc hl,de ; 2 cycles
043E5E             0004*M1     ; 4 cycles total
043E5E 20 BC       0049*       jr nz,@calc_loop
043E60             0050*   ; write to file
043E60 CD B0 43 04 0051*       call test_write_data
043E64             0052*   ; read next batch from file
043E64 C3 11 3E 04 0053*       jp @read_loop
043E68             0054*   @read_end:
043E68 C3 EB 43 04 0055*       jp test_complete
043E6C             0056*   
043E6C 2E 2E 2F 74 0057*   @test_filename: asciz "../tests/f16_add.bin"
       65 73 74 73 
       2F 66 31 36 
       5F 61 64 64 
       2E 62 69 6E 
       00          
043E81             0062        include "f16_test_div.inc"
043E81             0001*   test_f16_div:
043E81             0002*   ; copy test filename
043E81 21 12 3F 04 0003*       ld hl,@test_filename
043E85 11 00 45 04 0004*       ld de,test_filename
043E89 CD 50 44 04 0005*       call test_copy_filename
043E8D             0006*   
043E8D             0007*   ; do the test
043E8D CD E5 20 04 0008*       call printInline
043E91 0D 0A 66 31 0009*       asciz "\r\nf16_div test\r\n"
       36 5F 64 69 
       76 20 74 65 
       73 74 0D 0A 
       00          
043EA2 21 08 00 00 0010*       ld hl,8
043EA6 22 C0 42 04 0011*       ld (bytes_per_record),hl
043EAA 21 00 71 02 0012*       ld hl,160000
043EAE 22 BD 42 04 0013*       ld (bytes_read_max),hl
043EB2 CD C3 42 04 0014*       call test_init ; open files for reading and writing
043EB6 C8          0015*       ret z ; error opening files
043EB7             0016*   @read_loop:
043EB7 CD 46 43 04 0017*       call test_read_data
043EBB 28 51       0018*       jr z,@read_end
043EBD FD 21 00 46 0019*       ld iy,filedata
       04          
043EC2             0020*   @calc_loop:
043EC2             0021*   ; perform operation
043EC2 FD 27 00    0022*       ld hl,(iy+0) ; op1
043EC5 FD 17 02    0023*       ld de,(iy+2) ; op2
043EC8 CD A5 34 04 0024*       call f16_div
043ECC             0025*   ; write results to file buffer
043ECC FD 75 06    0026*       ld (iy+6),l ; assembly result low byte
043ECF FD 74 07    0027*       ld (iy+7),h ; assembly result high byte
043ED2             0028*   ; check for error
043ED2 FD 5E 04    0029*       ld e,(iy+4) ; python result low byte
043ED5 FD 56 05    0030*       ld d,(iy+5) ; python result high byte
043ED8 B7          0031*       or a ; clear carry
043ED9 52 ED 52    0032*       sbc.s hl,de
043EDC 28 09       0033*       jr z,@next_record
043EDE             0034*   ; bump error count
043EDE 2A AE 42 04 0035*       ld hl,(errors)
043EE2 23          0036*       inc hl
043EE3 22 AE 42 04 0037*       ld (errors),hl
043EE7             0038*   @next_record:
043EE7             0039*   ; write results to file buffer
043EE7 ED 5B C0 42 0040*       ld de,(bytes_per_record)
       04          
043EEC FD 19       0041*       add iy,de; bump data pointer
043EEE 2A B1 42 04 0042*       ld hl,(records)
043EF2 23          0043*       inc hl
043EF3 22 B1 42 04 0044*       ld (records),hl
043EF7 2A B4 42 04 0045*       ld hl,(counter)
043EFB 2B          0046*       dec hl
043EFC 22 B4 42 04 0047*       ld (counter),hl
043F00             0048*       SIGN_UHL
                       M1 Args: none
043F00 19          0001*M1     add hl,de ; 1 cycle
043F01 B7          0002*M1     or a ; clear flags ; 1 cycle
043F02 ED 52       0003*M1     sbc hl,de ; 2 cycles
043F04             0004*M1     ; 4 cycles total
043F04 20 BC       0049*       jr nz,@calc_loop
043F06             0050*   ; write to file
043F06 CD B0 43 04 0051*       call test_write_data
043F0A             0052*   ; read next batch from file
043F0A C3 B7 3E 04 0053*       jp @read_loop
043F0E             0054*   @read_end:
043F0E C3 EB 43 04 0055*       jp test_complete
043F12             0056*   
043F12 2E 2E 2F 74 0057*   @test_filename: asciz "../tests/f16_div.bin"
       65 73 74 73 
       2F 66 31 36 
       5F 64 69 76 
       2E 62 69 6E 
       00          
043F27             0063        include "f16_test_mul.inc"
043F27             0001*   test_f16_mul:
043F27             0002*   ; copy test filename
043F27 21 B8 3F 04 0003*       ld hl,@test_filename
043F2B 11 00 45 04 0004*       ld de,test_filename
043F2F CD 50 44 04 0005*       call test_copy_filename
043F33             0006*   
043F33             0007*   ; do the test
043F33 CD E5 20 04 0008*       call printInline
043F37 0D 0A 66 31 0009*       asciz "\r\nf16_mul test\r\n"
       36 5F 6D 75 
       6C 20 74 65 
       73 74 0D 0A 
       00          
043F48 21 08 00 00 0010*       ld hl,8
043F4C 22 C0 42 04 0011*       ld (bytes_per_record),hl
043F50 21 00 71 02 0012*       ld hl,160000
043F54 22 BD 42 04 0013*       ld (bytes_read_max),hl
043F58 CD C3 42 04 0014*       call test_init ; open files for reading and writing
043F5C C8          0015*       ret z ; error opening files
043F5D             0016*   @read_loop:
043F5D CD 46 43 04 0017*       call test_read_data
043F61 28 51       0018*       jr z,@read_end
043F63 FD 21 00 46 0019*       ld iy,filedata
       04          
043F68             0020*   @calc_loop:
043F68             0021*   ; perform operation
043F68 FD 27 00    0022*       ld hl,(iy+0) ; op1
043F6B FD 17 02    0023*       ld de,(iy+2) ; op2
043F6E CD 15 36 04 0024*       call f16_mul
043F72             0025*   ; write results to file buffer
043F72 FD 75 06    0026*       ld (iy+6),l ; assembly result low byte
043F75 FD 74 07    0027*       ld (iy+7),h ; assembly result high byte
043F78             0028*   ; check for error
043F78 FD 5E 04    0029*       ld e,(iy+4) ; python result low byte
043F7B FD 56 05    0030*       ld d,(iy+5) ; python result high byte
043F7E B7          0031*       or a ; clear carry
043F7F 52 ED 52    0032*       sbc.s hl,de
043F82 28 09       0033*       jr z,@next_record
043F84             0034*   ; bump error count
043F84 2A AE 42 04 0035*       ld hl,(errors)
043F88 23          0036*       inc hl
043F89 22 AE 42 04 0037*       ld (errors),hl
043F8D             0038*   @next_record:
043F8D             0039*   ; write results to file buffer
043F8D ED 5B C0 42 0040*       ld de,(bytes_per_record)
       04          
043F92 FD 19       0041*       add iy,de; bump data pointer
043F94 2A B1 42 04 0042*       ld hl,(records)
043F98 23          0043*       inc hl
043F99 22 B1 42 04 0044*       ld (records),hl
043F9D 2A B4 42 04 0045*       ld hl,(counter)
043FA1 2B          0046*       dec hl
043FA2 22 B4 42 04 0047*       ld (counter),hl
043FA6             0048*       SIGN_UHL
                       M1 Args: none
043FA6 19          0001*M1     add hl,de ; 1 cycle
043FA7 B7          0002*M1     or a ; clear flags ; 1 cycle
043FA8 ED 52       0003*M1     sbc hl,de ; 2 cycles
043FAA             0004*M1     ; 4 cycles total
043FAA 20 BC       0049*       jr nz,@calc_loop
043FAC             0050*   ; write to file
043FAC CD B0 43 04 0051*       call test_write_data
043FB0             0052*   ; read next batch from file
043FB0 C3 5D 3F 04 0053*       jp @read_loop
043FB4             0054*   @read_end:
043FB4 C3 EB 43 04 0055*       jp test_complete
043FB8             0056*   
043FB8 2E 2E 2F 74 0057*   @test_filename: asciz "../tests/f16_mul.bin"
       65 73 74 73 
       2F 66 31 36 
       5F 6D 75 6C 
       2E 62 69 6E 
       00          
043FCD             0064        include "f16_test_sub.inc"
043FCD             0001*   test_f16_sub:
043FCD             0002*   ; copy test filename
043FCD 21 5E 40 04 0003*       ld hl,@test_filename
043FD1 11 00 45 04 0004*       ld de,test_filename
043FD5 CD 50 44 04 0005*       call test_copy_filename
043FD9             0006*   
043FD9             0007*   ; do the test
043FD9 CD E5 20 04 0008*       call printInline
043FDD 0D 0A 66 31 0009*       asciz "\r\nf16_sub test\r\n"
       36 5F 73 75 
       62 20 74 65 
       73 74 0D 0A 
       00          
043FEE 21 08 00 00 0010*       ld hl,8
043FF2 22 C0 42 04 0011*       ld (bytes_per_record),hl
043FF6 21 00 71 02 0012*       ld hl,160000
043FFA 22 BD 42 04 0013*       ld (bytes_read_max),hl
043FFE CD C3 42 04 0014*       call test_init ; open files for reading and writing
044002 C8          0015*       ret z ; error opening files
044003             0016*   @read_loop:
044003 CD 46 43 04 0017*       call test_read_data
044007 28 51       0018*       jr z,@read_end
044009 FD 21 00 46 0019*       ld iy,filedata
       04          
04400E             0020*   @calc_loop:
04400E             0021*   ; perform operation
04400E FD 27 00    0022*       ld hl,(iy+0) ; op1
044011 FD 17 02    0023*       ld de,(iy+2) ; op2
044014 CD BD 39 04 0024*       call f16_sub
044018             0025*   ; write results to file buffer
044018 FD 75 06    0026*       ld (iy+6),l ; assembly result low byte
04401B FD 74 07    0027*       ld (iy+7),h ; assembly result high byte
04401E             0028*   ; check for error
04401E FD 5E 04    0029*       ld e,(iy+4) ; python result low byte
044021 FD 56 05    0030*       ld d,(iy+5) ; python result high byte
044024 B7          0031*       or a ; clear carry
044025 52 ED 52    0032*       sbc.s hl,de
044028 28 09       0033*       jr z,@next_record
04402A             0034*   ; bump error count
04402A 2A AE 42 04 0035*       ld hl,(errors)
04402E 23          0036*       inc hl
04402F 22 AE 42 04 0037*       ld (errors),hl
044033             0038*   @next_record:
044033             0039*   ; write results to file buffer
044033 ED 5B C0 42 0040*       ld de,(bytes_per_record)
       04          
044038 FD 19       0041*       add iy,de; bump data pointer
04403A 2A B1 42 04 0042*       ld hl,(records)
04403E 23          0043*       inc hl
04403F 22 B1 42 04 0044*       ld (records),hl
044043 2A B4 42 04 0045*       ld hl,(counter)
044047 2B          0046*       dec hl
044048 22 B4 42 04 0047*       ld (counter),hl
04404C             0048*       SIGN_UHL
                       M1 Args: none
04404C 19          0001*M1     add hl,de ; 1 cycle
04404D B7          0002*M1     or a ; clear flags ; 1 cycle
04404E ED 52       0003*M1     sbc hl,de ; 2 cycles
044050             0004*M1     ; 4 cycles total
044050 20 BC       0049*       jr nz,@calc_loop
044052             0050*   ; write to file
044052 CD B0 43 04 0051*       call test_write_data
044056             0052*   ; read next batch from file
044056 C3 03 40 04 0053*       jp @read_loop
04405A             0054*   @read_end:
04405A C3 EB 43 04 0055*       jp test_complete
04405E             0056*   
04405E 2E 2E 2F 74 0057*   @test_filename: asciz "../tests/f16_sub.bin"
       65 73 74 73 
       2F 66 31 36 
       5F 73 75 62 
       2E 62 69 6E 
       00          
044073             0065        include "f16_test_sqrt.inc"
044073             0001*   test_f16_sqrt:
044073             0002*   ; copy test filename
044073 21 02 41 04 0003*       ld hl,@test_filename
044077 11 00 45 04 0004*       ld de,test_filename
04407B CD 50 44 04 0005*       call test_copy_filename
04407F             0006*   
04407F             0007*   ; do the test
04407F CD E5 20 04 0008*       call printInline
044083 0D 0A 66 31 0009*       asciz "\r\nf16_sqrt test\r\n"
       36 5F 73 71 
       72 74 20 74 
       65 73 74 0D 
       0A 00       
044095 21 06 00 00 0010*       ld hl,6
044099 22 C0 42 04 0011*       ld (bytes_per_record),hl
04409D 21 C0 D4 01 0012*       ld hl,120000
0440A1 22 BD 42 04 0013*       ld (bytes_read_max),hl
0440A5 CD C3 42 04 0014*       call test_init ; open files for reading and writing
0440A9 C8          0015*       ret z ; error opening files
0440AA             0016*   @read_loop:
0440AA CD 46 43 04 0017*       call test_read_data
0440AE 28 4E       0018*       jr z,@read_end
0440B0 FD 21 00 46 0019*       ld iy,filedata
       04          
0440B5             0020*   @calc_loop:
0440B5             0021*   ; perform operation
0440B5 FD 27 00    0022*       ld hl,(iy+0) ; op1
0440B8 CD 6E 38 04 0023*       call f16_sqrt
0440BC             0024*   ; write results to file buffer
0440BC FD 75 04    0025*       ld (iy+4),l ; assembly result low byte
0440BF FD 74 05    0026*       ld (iy+5),h ; assembly result high byte
0440C2             0027*   ; check for error
0440C2 FD 5E 02    0028*       ld e,(iy+2) ; python result low byte
0440C5 FD 56 03    0029*       ld d,(iy+3) ; python result high byte
0440C8 B7          0030*       or a ; clear carry
0440C9 52 ED 52    0031*       sbc.s hl,de
0440CC 28 09       0032*       jr z,@next_record
0440CE             0033*   ; bump error count
0440CE 2A AE 42 04 0034*       ld hl,(errors)
0440D2 23          0035*       inc hl
0440D3 22 AE 42 04 0036*       ld (errors),hl
0440D7             0037*   @next_record:
0440D7             0038*   ; write results to file buffer
0440D7 ED 5B C0 42 0039*       ld de,(bytes_per_record)
       04          
0440DC FD 19       0040*       add iy,de; bump data pointer
0440DE 2A B1 42 04 0041*       ld hl,(records)
0440E2 23          0042*       inc hl
0440E3 22 B1 42 04 0043*       ld (records),hl
0440E7 2A B4 42 04 0044*       ld hl,(counter)
0440EB 2B          0045*       dec hl
0440EC 22 B4 42 04 0046*       ld (counter),hl
0440F0             0047*       SIGN_UHL
                       M1 Args: none
0440F0 19          0001*M1     add hl,de ; 1 cycle
0440F1 B7          0002*M1     or a ; clear flags ; 1 cycle
0440F2 ED 52       0003*M1     sbc hl,de ; 2 cycles
0440F4             0004*M1     ; 4 cycles total
0440F4 20 BF       0048*       jr nz,@calc_loop
0440F6             0049*   ; write to file
0440F6 CD B0 43 04 0050*       call test_write_data
0440FA             0051*   ; read next batch from file
0440FA C3 AA 40 04 0052*       jp @read_loop
0440FE             0053*   @read_end:
0440FE C3 EB 43 04 0054*       jp test_complete
044102             0055*   
044102 2E 2E 2F 74 0056*   @test_filename: asciz "../tests/f16_sqrt.bin"
       65 73 74 73 
       2F 66 31 36 
       5F 73 71 72 
       74 2E 62 69 
       6E 00       
044118             0066        include "f16_test_print.inc"
044118             0001*   test_f16_print:
044118             0002*   ; copy test filename
044118 21 B8 41 04 0003*       ld hl,@test_filename
04411C 11 00 45 04 0004*       ld de,test_filename
044120 CD 50 44 04 0005*       call test_copy_filename
044124             0006*   
044124             0007*   ; do the test
044124 CD E5 20 04 0008*       call printInline
044128 0D 0A 66 31 0009*       asciz "\r\nf16_print test\r\n"
       36 5F 70 72 
       69 6E 74 20 
       74 65 73 74 
       0D 0A 00    
04413B 21 40 00 00 0010*       ld hl,64
04413F 22 C0 42 04 0011*       ld (bytes_per_record),hl
044143 21 00 00 04 0012*       ld hl,262144
044147 22 BD 42 04 0013*       ld (bytes_read_max),hl
04414B CD C3 42 04 0014*       call test_init ; open files for reading and writing
04414F C8          0015*       ret z ; error opening files
044150             0016*   @read_loop:
044150 CD 46 43 04 0017*       call test_read_data
044154 28 5E       0018*       jr z,@read_end
044156 FD 21 00 46 0019*       ld iy,filedata
       04          
04415B             0020*   @calc_loop:
04415B             0021*   ; ; DEBUG
04415B             0022*   ;     call printNewLine
04415B             0023*   ;     push iy
04415B             0024*   ;     pop hl
04415B             0025*   ;     ld hl,(hl)
04415B             0026*   ;     call printHexHL
04415B             0027*   ;     ld a,' '
04415B             0028*   ;     rst.lil 10h
04415B             0029*   ; ; END DEBUG
04415B             0030*   
04415B             0031*   ; ; DEBUG
04415B             0032*   ;     push iy
04415B             0033*   ;     pop hl
04415B             0034*   ;     inc hl
04415B             0035*   ;     inc hl
04415B             0036*   ;     call printString
04415B             0037*   ;     ld a,' '
04415B             0038*   ;     rst.lil 10h
04415B             0039*   ; ; END DEBUG
04415B             0040*   
04415B             0041*   ; perform operation
04415B FD 27 00    0042*       ld hl,(iy+0) ; op1
04415E FD E5       0043*       push iy
044160 CD D2 36 04 0044*       call f16_print
044164 FD E1       0045*       pop iy
044166             0046*   
044166             0047*   ; ; DEBUG
044166             0048*   ;     push hl
044166             0049*   ;     call printString
044166             0050*   ;     pop hl
044166             0051*   ; ; END DEBUG
044166             0052*   
044166             0053*   ; ; DEBUG
044166             0054*   ;     call waitKeypress
044166             0055*   ; ; END DEBUG
044166             0056*   
044166 FD E5       0057*       push iy
044168 E5          0058*       push hl
044169             0059*   ; write results to file buffer
044169 ED 33 21    0060*       lea iy,iy+33
04416C FD E5       0061*       push iy
04416E D1          0062*       pop de
04416F D5          0063*       push de
044170 01 1F 00 00 0064*       ld bc,31
044174 ED B0       0065*       ldir
044176             0066*   ; check for error
044176 D1          0067*       pop de
044177 E1          0068*       pop hl
044178 06 1F       0069*       ld b,31
04417A             0070*   @error_loop:
04417A 1A          0071*       ld a,(de)
04417B BE          0072*       cp (hl)
04417C 20 04       0073*       jr nz,@count_error
04417E 10 FA       0074*       djnz @error_loop
044180 18 09       0075*       jr @next_record
044182             0076*   @count_error:
044182             0077*   ; bump error count
044182 2A AE 42 04 0078*       ld hl,(errors)
044186 23          0079*       inc hl
044187 22 AE 42 04 0080*       ld (errors),hl
04418B             0081*   @next_record:
04418B             0082*   ; write results to file buffer
04418B FD E1       0083*       pop iy
04418D ED 5B C0 42 0084*       ld de,(bytes_per_record)
       04          
044192 FD 19       0085*       add iy,de; bump data pointer
044194 2A B1 42 04 0086*       ld hl,(records)
044198 23          0087*       inc hl
044199 22 B1 42 04 0088*       ld (records),hl
04419D 2A B4 42 04 0089*       ld hl,(counter)
0441A1 2B          0090*       dec hl
0441A2 22 B4 42 04 0091*       ld (counter),hl
0441A6             0092*       SIGN_UHL
                       M1 Args: none
0441A6 19          0001*M1     add hl,de ; 1 cycle
0441A7 B7          0002*M1     or a ; clear flags ; 1 cycle
0441A8 ED 52       0003*M1     sbc hl,de ; 2 cycles
0441AA             0004*M1     ; 4 cycles total
0441AA 20 AF       0093*       jr nz,@calc_loop
0441AC             0094*   ; write to file
0441AC CD B0 43 04 0095*       call test_write_data
0441B0             0096*   ; read next batch from file
0441B0 C3 50 41 04 0097*       jp @read_loop
0441B4             0098*   @read_end:
0441B4 C3 EB 43 04 0099*       jp test_complete
0441B8             0100*   
0441B8 2E 2E 2F 73 0101*   @test_filename: asciz "../scratch/tests/f16_print_all.bin"
       63 72 61 74 
       63 68 2F 74 
       65 73 74 73 
       2F 66 31 36 
       5F 70 72 69 
       6E 74 5F 61 
       6C 6C 2E 62 
       69 6E 00    
0441DB             0067        include "mul_32x16_48.inc"
0441DB             0001*   test_mul_32x16_48:
0441DB             0002*   ; copy test filename
0441DB 21 8F 42 04 0003*       ld hl,@test_filename
0441DF 11 00 45 04 0004*       ld de,test_filename
0441E3 CD 50 44 04 0005*       call test_copy_filename
0441E7             0006*   
0441E7             0007*   ; do the test
0441E7 CD E5 20 04 0008*       call printInline
0441EB 0D 0A 6D 75 0009*       asciz "\r\nmul_32x16_48 test\r\n"
       6C 5F 33 32 
       78 31 36 5F 
       34 38 20 74 
       65 73 74 0D 
       0A 00       
044201 21 12 00 00 0010*       ld hl,18
044205 22 C0 42 04 0011*       ld (bytes_per_record),hl
044209 21 40 7E 05 0012*       ld hl,360000
04420D 22 BD 42 04 0013*       ld (bytes_read_max),hl
044211 CD C3 42 04 0014*       call test_init ; open files for reading and writing
044215 C8          0015*       ret z ; error opening files
044216             0016*   @read_loop:
044216 CD 46 43 04 0017*       call test_read_data
04421A 28 6F       0018*       jr z,@read_end
04421C FD 21 00 46 0019*       ld iy,filedata
       04          
044221             0020*   @calc_loop:
044221             0021*   ; perform operation
044221 FD 17 00    0022*       ld de,(iy+0) ; op1 low word
044224 FD 27 02    0023*       ld hl,(iy+2) ; op1 high word
044227 FD 07 04    0024*       ld bc,(iy+4) ; op2
04422A CD 6C 33 04 0025*       call mul_32x16_48
04422E             0026*   ; write results to file buffer
04422E FD 0F 0C    0027*       ld (iy+12),bc ; assembly result low word
044231 FD 1F 0E    0028*       ld (iy+14),de ; assembly result middle word
044234 FD 75 10    0029*       ld (iy+16),l ; assembly result high word low byte
044237 FD 74 11    0030*       ld (iy+17),h ; assembly result high word high byte
04423A             0031*   ; compare high word
04423A FD 17 0A    0032*       ld de,(iy+10) ; python high
04423D B7          0033*       or a
04423E 52 ED 52    0034*       sbc.s hl,de
044241 20 18       0035*       jr nz,@error
044243             0036*   ; compare mid word
044243 FD 27 0E    0037*       ld hl,(iy+14) ; asm mid
044246 FD 17 08    0038*       ld de,(iy+8)  ; python mid
044249 B7          0039*       or a
04424A 52 ED 52    0040*       sbc.s hl,de
04424D 20 0C       0041*       jr nz,@error
04424F             0042*   ; compare low word
04424F FD 27 0C    0043*       ld hl,(iy+12) ; asm low
044252 FD 17 06    0044*       ld de,(iy+6)  ; python low
044255 B7          0045*       or a
044256 52 ED 52    0046*       sbc.s hl,de
044259 28 09       0047*       jr z,@next_record
04425B             0048*   @error:
04425B             0049*   ; bump error count
04425B 2A AE 42 04 0050*       ld hl,(errors)
04425F 23          0051*       inc hl
044260 22 AE 42 04 0052*       ld (errors),hl
044264             0053*   @next_record:
044264             0054*   ; write results to file buffer
044264 ED 5B C0 42 0055*       ld de,(bytes_per_record)
       04          
044269 FD 19       0056*       add iy,de; bump data pointer
04426B 2A B1 42 04 0057*       ld hl,(records)
04426F 23          0058*       inc hl
044270 22 B1 42 04 0059*       ld (records),hl
044274 2A B4 42 04 0060*       ld hl,(counter)
044278 2B          0061*       dec hl
044279 22 B4 42 04 0062*       ld (counter),hl
04427D             0063*       SIGN_UHL
                       M1 Args: none
04427D 19          0001*M1     add hl,de ; 1 cycle
04427E B7          0002*M1     or a ; clear flags ; 1 cycle
04427F ED 52       0003*M1     sbc hl,de ; 2 cycles
044281             0004*M1     ; 4 cycles total
044281 20 9E       0064*       jr nz,@calc_loop
044283             0065*   ; write to file
044283 CD B0 43 04 0066*       call test_write_data
044287             0067*   ; read next batch from file
044287 C3 16 42 04 0068*       jp @read_loop
04428B             0069*   @read_end:
04428B C3 EB 43 04 0070*       jp test_complete
04428F 2E 2E 2F 74 0071*   @test_filename: asciz "../tests/mul_32x16_48.bin"
       65 73 74 73 
       2F 6D 75 6C 
       5F 33 32 78 
       31 36 5F 34 
       38 2E 62 69 
       6E 00       
0442A9             0072*   ; end of test_mul_32x16_48
0442A9             0068    main:
0442A9             0069    
0442A9             0070        ; call test_f16_add
0442A9             0071        ; call test_f16_sub
0442A9             0072        ; call test_f16_mul
0442A9             0073        ; call test_f16_div
0442A9             0074        ; call test_f16_sqrt
0442A9 CD 18 41 04 0075        call test_f16_print
0442AD             0076        ; call test_mul_32x16_48
0442AD             0077    
0442AD C9          0078        ret
0442AE             0079    
0442AE             0080    ; must be final include so filedata doesn't stomp other application code or data
0442AE             0081        include "f16_test_all.inc"
0442AE 00 00 00    0001*   errors: dl 0
0442B1 00 00 00    0002*   records: dl 0
0442B4 00 00 00    0003*   counter: dl 0
0442B7 00 00 00    0004*   time: dl 0
0442BA 00 00 00    0005*   bytes_read: dl 0
0442BD 00 00 00    0006*   bytes_read_max: dl 0
0442C0 00 00 00    0007*   bytes_per_record: dl 0
0442C3             0008*   
0442C3             0009*   test_init:
0442C3             0010*   ; set up counters
0442C3 21 00 00 00 0011*       ld hl,0 ; error counter
0442C7 22 AE 42 04 0012*       ld (errors),hl ; error counter
0442CB 22 B1 42 04 0013*       ld (records),hl ; record counter
0442CF 22 B7 42 04 0014*       ld (time),hl ; time counter
0442D3             0015*   ; open file for reading
0442D3 CD 5E 44 04 0016*       call open_testfile_read
0442D7 B7          0017*       or a
0442D8 20 33       0018*       jr nz,@open_writefile
0442DA CD E5 20 04 0019*       call printInline
0442DE 45 72 72 6F 0020*       asciz "Error opening file for reading\r\n"
       72 20 6F 70 
       65 6E 69 6E 
       67 20 66 69 
       6C 65 20 66 
       6F 72 20 72 
       65 61 64 69 
       6E 67 0D 0A 
       00          
0442FF 21 00 45 04 0021*       ld hl,test_filename
044303 CD EC 20 04 0022*       call printString
044307 CD 01 21 04 0023*       call printNewLine
04430B 18 37       0024*       jr @error
04430D             0025*   @open_writefile:
04430D             0026*   ; open file for writing
04430D CD 6D 44 04 0027*       call open_testfile_write
044311 B7          0028*       or a
044312 C0          0029*       ret nz
044313 CD E5 20 04 0030*       call printInline
044317 45 72 72 6F 0031*       asciz "Error opening file for writing\r\n"
       72 20 6F 70 
       65 6E 69 6E 
       67 20 66 69 
       6C 65 20 66 
       6F 72 20 77 
       72 69 74 69 
       6E 67 0D 0A 
       00          
044338 21 00 45 04 0032*       ld hl,test_filename
04433C CD EC 20 04 0033*       call printString
044340 CD 01 21 04 0034*       call printNewLine
044344             0035*   @error:
044344 AF          0036*       xor a ; return zero indicating error
044345 C9          0037*       ret
044346             0038*   
044346             0039*   test_read_data:
044346             0040*   ; read data from file
044346 3A 90 44 04 0041*       ld a,(testfile_read_handle)
04434A 4F          0042*       ld c,a
04434B 21 00 46 04 0043*       ld hl,filedata
04434F ED 5B BD 42 0044*       ld de,(bytes_read_max) ; max bytes to read
       04          
044354             0045*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
044354 3E 1A       0001*M1 			LD	A, function
044356 5B CF       0002*M1 			RST.LIL	08h
044358 ED 53 BA 42 0046*       ld (bytes_read),de
       04          
04435D EB          0047*       ex de,hl
04435E             0048*       SIGN_UHL
                       M1 Args: none
04435E 19          0001*M1     add hl,de ; 1 cycle
04435F B7          0002*M1     or a ; clear flags ; 1 cycle
044360 ED 52       0003*M1     sbc hl,de ; 2 cycles
044362             0004*M1     ; 4 cycles total
044362 C8          0049*       ret z
044363             0050*   ; compute number of records in batch
044363 E5          0051*       push hl
044364 ED 5B C0 42 0052*       ld de,(bytes_per_record) ; bytes per record
       04          
044369 CD 24 04 04 0053*       call udiv24
04436D ED 53 B4 42 0054*       ld (counter),de ; record counter
       04          
044372 EB          0055*       ex de,hl
044373 CD 51 21 04 0056*       call printDec
044377 CD E5 20 04 0057*       call printInline
04437B 20 72 65 63 0058*       asciz " records in batch"
       6F 72 64 73 
       20 69 6E 20 
       62 61 74 63 
       68 00       
04438D E1          0059*       pop hl
04438E             0060*   ; output bytes read
04438E CD 51 21 04 0061*       call printDec
044392 CD E5 20 04 0062*       call printInline
044396 20 62 79 74 0063*       asciz " bytes read"
       65 73 20 72 
       65 61 64 00 
0443A2             0064*   ; start stopwatch
0443A2 CD 33 2F 04 0065*       call vdu_flip
0443A6 CD 4A 29 04 0066*       call stopwatch_set
0443AA             0067*   ; reset data pointer
0443AA DD 21 00 46 0068*       ld ix,filedata
       04          
0443AF C9          0069*       ret
0443B0             0070*   
0443B0             0071*   test_write_data:
0443B0             0072*   ; get elapsed time
0443B0 CD 56 29 04 0073*       call stopwatch_get
0443B4 ED 5B B7 42 0074*       ld de,(time)
       04          
0443B9 19          0075*       add hl,de
0443BA 22 B7 42 04 0076*       ld (time),hl
0443BE             0077*   ; write data to file
0443BE 3A 91 44 04 0078*       ld a,(testfile_write_handle)
0443C2 4F          0079*       ld c,a
0443C3 21 00 46 04 0080*       ld hl,filedata
0443C7 ED 5B BA 42 0081*       ld de,(bytes_read) ; bytes to write
       04          
0443CC             0082*       MOSCALL mos_fwrite
                       M1 Args: function=mos_fwrite 
0443CC 3E 1B       0001*M1 			LD	A, function
0443CE 5B CF       0002*M1 			RST.LIL	08h
0443D0 EB          0083*       ex de,hl
0443D1 CD 51 21 04 0084*       call printDec
0443D5 CD E5 20 04 0085*       call printInline
0443D9 20 62 79 74 0086*       asciz " bytes written\r\n"
       65 73 20 77 
       72 69 74 74 
       65 6E 0D 0A 
       00          
0443EA C9          0087*       ret
0443EB             0088*   
0443EB             0089*   test_complete:
0443EB             0090*   ; close files
0443EB CD 7C 44 04 0091*       call close_testfile_read
0443EF CD 86 44 04 0092*       call close_testfile_write
0443F3             0093*   ; report elapsed time
0443F3 2A B7 42 04 0094*       ld hl,(time)
0443F7 29          0095*       add hl,hl
0443F8 29          0096*       add hl,hl
0443F9 29          0097*       add hl,hl
0443FA 29          0098*       add hl,hl
0443FB 29          0099*       add hl,hl
0443FC 29          0100*       add hl,hl
0443FD 29          0101*       add hl,hl
0443FE 29          0102*       add hl,hl
0443FF 11 00 78 00 0103*       ld de,120*256 ; ticks per second in 16.8 fixed point
044403 CD 1A 06 04 0104*       call udiv168
044407 CD 30 23 04 0105*       call print_s168_de
04440B CD E5 20 04 0106*       call printInline
04440F 20 73 65 63 0107*       asciz " seconds elapsed\r\n"
       6F 6E 64 73 
       20 65 6C 61 
       70 73 65 64 
       0D 0A 00    
044422             0108*   ; display error count
044422 2A AE 42 04 0109*       ld hl,(errors)
044426 CD 51 21 04 0110*       call printDec
04442A CD E5 20 04 0111*       call printInline
04442E 20 65 72 72 0112*       asciz " errors\r\n"
       6F 72 73 0D 
       0A 00       
044438             0113*   ; display record count
044438 2A B1 42 04 0114*       ld hl,(records)
04443C CD 51 21 04 0115*       call printDec
044440 CD E5 20 04 0116*       call printInline
044444 20 72 65 63 0117*       asciz " records\r\n"
       6F 72 64 73 
       0D 0A 00    
04444F C9          0118*       ret
044450             0119*   
044450             0120*   ; copy a zero-terminated filname to the target address
044450             0121*   ; inputs: hl = pointer to filename, de = target address
044450             0122*   ; returns: hl = pointer to end of filename, de = pointer to end of target address, bc=0, a=0
044450             0123*   ; destroys: af, hl, de, bc
044450             0124*   test_copy_filename:
044450 E5          0125*       push hl ; save filename pointer
044451 01 00 00 00 0126*       ld bc,0 ; init byte counter
044455             0127*   @loop:
044455 23          0128*       inc hl ; assume filename is at least one character
044456 03          0129*       inc bc ; ditto
044457 7E          0130*       ld a,(hl)
044458 B7          0131*       or a
044459 20 FA       0132*       jr nz,@loop
04445B E1          0133*       pop hl ; get back filename pointer
04445C ED B0       0134*       ldir ; copy the filename to target address
04445E             0135*   
04445E             0136*   open_testfile_read:
04445E             0137*   ; open file for reading
04445E 21 00 45 04 0138*       ld hl,test_filename
044462 0E 01       0139*       ld c,fa_read
044464             0140*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
044464 3E 0A       0001*M1 			LD	A, function
044466 5B CF       0002*M1 			RST.LIL	08h
044468 32 90 44 04 0141*       ld (testfile_read_handle),a
04446C C9          0142*       ret
04446D             0143*   
04446D             0144*   open_testfile_write:
04446D             0145*   ; open file for writing
04446D 21 00 45 04 0146*       ld hl,test_filename
044471 0E 02       0147*       ld c,fa_write | fa_open_existing
044473             0148*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
044473 3E 0A       0001*M1 			LD	A, function
044475 5B CF       0002*M1 			RST.LIL	08h
044477 32 91 44 04 0149*       ld (testfile_write_handle),a
04447B C9          0150*       ret
04447C             0151*   
04447C             0152*   close_testfile_read:
04447C 3A 90 44 04 0153*       ld a,(testfile_read_handle)
044480 4F          0154*       ld c,a
044481             0155*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
044481 3E 0B       0001*M1 			LD	A, function
044483 5B CF       0002*M1 			RST.LIL	08h
044485 C9          0156*       ret
044486             0157*   
044486             0158*   close_testfile_write:
044486 3A 91 44 04 0159*       ld a,(testfile_write_handle)
04448A 4F          0160*       ld c,a
04448B             0161*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
04448B 3E 0B       0001*M1 			LD	A, function
04448D 5B CF       0002*M1 			RST.LIL	08h
04448F C9          0162*       ret
044490             0163*   
044490 00          0164*   testfile_read_handle: db 0
044491 00          0165*   testfile_write_handle: db 0
044492             0166*   
044492             0167*   test_fil: equ $
044492             0168*   test_filinfo: equ test_fil + fil_struct_size
044492             0169*   
044492             0170*   test_fil_out: equ test_filinfo + filinfo_struct_size
044492             0171*   test_filinfo_out: equ test_fil_out + fil_struct_size
044492             0172*   
044492             0173*       align 256
044500             0174*   
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
044500 00 00 00 00 0175*   test_filename: blkb 256,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044600             0176*   
044600             0177*   ; this must be the final label included in the application
044600             0178*   ; so that data written here doesn't stomp on other code or data
044600             0179*   filedata: equ $
